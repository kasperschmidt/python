# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# Scripts, functions and routines to (enable) search for UV emission lines in MUSE data
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
import pdb
import os
import commands
import sys
import glob
import astropy
import scipy
import MiGs
import astropy.io.fits as afits
import pyfits as pyfitsOLD
import datetime
import numpy as np
import shutil
import time
import fits2ascii as f2a
import MUSEWideUtilities as mu
import MUSEWidePlots as mwp
import kbsutilities as kbs
import tdose_utilities as tu
from astropy import wcs
from astropy.coordinates import SkyCoord
from astropy import units as u
import subprocess
import collections
import uvEmissionlineSearch as uves
from uncertainties import unumpy
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.ticker import NullFormatter
import NEOGALmodels as nm
import rxj2248_BooneBalestraSource as bbs
import felis_build_template as fbt
import felis
import pickle
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def buildANDgenerate(clobber=True):
    """
    Convenience wrapper to build and generate all the files needed for the TDOSE run

    --- Needs to be updated to be used as of 171019 ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.buildANDgenerate()

    """
    LAEinfofile = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    uves.build_LAEfitstable(fitsname=LAEinfofile,clobber=clobber)

    sourcecatdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats/'
    uves.gen_LAEsourceCats(sourcecatdir,LAEinfofile,modelcoord=True)

    SETUPinfofile = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_setupfiles/MUSEWide_infofile_arche_PSFupdate_LAEs.txt'
    uves.gen_TDOSEsetupfiles(SETUPinfofile,clobber=clobber)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def run_TDOSEextraction():
    """
    Command (to copy-paste into arche) to run TDOSE on setup files generated with uves.gen_TDOSEsetupfiles()

    --- EXAMPLE OF USE ---
    copy-past into Max terminal (for copying over files to arche) and on arche (for running TDOSE)

    """
    # ---------------------------- Copying over files from Mac ----------------------------
    # scp /Users/kschmidt/work/MUSE/uvEmissionlineSearch/ref_image_galfit_models/*.fits kasper@arche.aip.de:/store/data/musewide/TDOSE/ref_image_galfit_models/

    # scp /Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_setupfiles/*candels*.txt kasper@arche.aip.de:/store/data/musewide/TDOSE/tdose_setupfiles/

    # scp /Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats/*.fits kasper@arche.aip.de:/store/data/musewide/TDOSE/tdose_sourcecats/

    # ------------------------ Running TDOSE on Arche - FewFileRun ------------------------
    # mkdir tdose_models tdose_cutouts tdose_spectra
    # ur_setup
    # ipython
    import tdose, glob
    import numpy as np
    Nsessions = 1

    setupfiles = [glob.glob('/store/data/musewide/TDOSE/tdose_setupfiles/MUSEWide_tdose_setup_LAEs_candels-*.txt')[0]] # COSMOS 06
    setupfiles = [glob.glob('/store/data/musewide/TDOSE/tdose_setupfiles/MUSEWide_tdose_setup_LAEs_candels-*.txt')[1]] # CDFS 01

    bundles, paralleldic = tdose.perform_extractions_in_parallel(setupfiles,Nsessions=Nsessions,clobber=True,performcutout=True,store1Dspectra=True,plot1Dspectra=True,generateFullFoVmodel=True,generateOverviewPlots=True,skipextractedobjects=False,logterminaloutput=True,verbosePE=True,verbosefull=True)

    # -------------------------- Running TDOSE on Arche - Full Run -------------------------
    # mkdir tdose_models, tdose_cutouts, tdose_spectra
    # ur_setup
    # nice ipython
    import tdose, glob
    import numpy as np
    Nsessions = 30

    setupfiles = glob.glob('/store/data/musewide/TDOSE/tdose_setupfiles/MUSEWide_tdose_setup_LAEs_candels-*.txt')

    bundles, paralleldic = tdose.perform_extractions_in_parallel(setupfiles,Nsessions=Nsessions,clobber=True,performcutout=True,store1Dspectra=True,plot1Dspectra=True,generateFullFoVmodel=True,generateOverviewPlots=True,skipextractedobjects=True,logterminaloutput=True)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def build_LAEfitstable(fitsname='./LAEinfoRENAME.fits',genDS9region=True,clobber=False,verbose=True):
    """
    Building a fits table containing information on the sources.
    Generated by combining multiple sources of information.

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.build_LAEfitstable(clobber=True)

    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Loading fits catalogs for LAEs:')
    catPSF            = '/Users/kschmidt/work/catalogs/MUSE_GTO/psf_all_Converted_cleaned.fits'
    catE24eltab       = '/Users/kschmidt/work/catalogs/MUSE_GTO/MW_1-24_emline_table_v3.2.fits'

    if verbose: print('   '+catPSF)
    datPSF      = afits.open(catPSF)[1].data
    if verbose: print('   Columns: '+str(datPSF.dtype.names)+'\n')

    if verbose: print('   '+catE24eltab)
    datE24eltab = afits.open(catE24eltab)[1].data
    if verbose: print('   Columns: '+str(datE24eltab.dtype.names)+'\n')

    catE24main        = '/Users/kschmidt/work/catalogs/MUSE_GTO/MW_1-24_main_table_v3.2.fits'
    catE36main        = '/Users/kschmidt/work/catalogs/MUSE_GTO/merged_catalog_e36_v1.0.fits'
    catE40main        = '/Users/kschmidt/work/catalogs/MUSE_GTO/merged_catalog_e40_v0.9.fits'
    catUDFSmain       = '/Users/kschmidt/work/catalogs/MUSE_GTO/merged_catalog_mosaic_shallow_v0.9.fits'
    catU10main        = '/Users/kschmidt/work/catalogs/MUSE_GTO/object_catalog_udf-10_v0.9.fits'
    catUDFmain        = '/Users/kschmidt/work/catalogs/MUSE_GTO/merged_catalog_udf-mosaic_v0.9.fits'
    # IDs in UDF mosaic catalog consist of 4 digits id followed by 4 digits running line number


    if verbose: print('   '+catE24main)
    datE24main  = afits.open(catE24main)[1].data
    if verbose: print('   Columns: '+str(datE24main.dtype.names)+'\n')

    if verbose: print('   '+catE36main)
    datE36main  = afits.open(catE36main)[1].data
    if verbose: print('   Columns: '+str(datE36main.dtype.names)+'\n')

    if verbose: print('   '+catE40main)
    datE40main  = afits.open(catE40main)[1].data
    if verbose: print('   Columns: '+str(datE40main.dtype.names)+'\n')

    if verbose: print('   '+catUDFSmain)
    datUDFSmain  = afits.open(catUDFSmain)[1].data
    if verbose: print('   Columns: '+str(datUDFSmain.dtype.names)+'\n')

    if verbose: print('   '+catUDFmain)
    datUDFmain  = afits.open(catUDFmain)[1].data
    if verbose: print('   Columns: '+str(datUDFmain.dtype.names)+'\n')

    if verbose: print('   '+catU10main)
    datU10main= afits.open(catU10main)[1].data
    if verbose: print('   Columns: '+str(datU10main.dtype.names)+'\n')


    catE24lineprops   = '/Users/kschmidt/work/catalogs/MUSE_GTO/MW_1-24_v3.1_LAEs_line_props.fits'
    catE36lineprops   = '/Users/kschmidt/work/catalogs/MUSE_GTO/e36_emline_master_v1.0_LAEs_line_props.fits'
    catE40lineprops   = 'None'
    catUDFSlineprops  = 'None'
    catUDFlineprops   = 'None'
    catU10lineprops   = 'None'

    if verbose: print('   '+catE24lineprops)
    datE24lp  = afits.open(catE24lineprops)[1].data
    if verbose: print('   Columns: '+str(datE24lp.dtype.names)+'\n')

    if verbose: print('   '+catE36lineprops)
    datE36lp    = afits.open(catE36lineprops)[1].data
    if verbose: print('   Columns: '+str(datE36lp.dtype.names)+'\n')

    catLyaEW          = '/Users/kschmidt/work/catalogs/MUSE_GTO/fluxes_EWs_line_props.fits'
    if verbose: print('   '+catLyaEW)
    datLyaEW  = afits.open(catLyaEW)[1].data
    if verbose: print('   Columns: '+str(datLyaEW.dtype.names)+'\n')

    catGuo     = '/Users/kschmidt/work/catalogs/guo/CANDELS.GOODSS.F160W.v1.fits'
    if verbose: print('   '+catGuo)
    datGuo     = afits.open(catGuo)[1].data

    catSkeltonGS  = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
    if verbose: print('   '+catSkeltonGS)
    datSkeltonGS  = afits.open(catSkeltonGS)[1].data

    catSkeltonCOS = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
    if verbose: print('   '+catSkeltonCOS)
    datSkeltonCOS = afits.open(catSkeltonCOS)[1].data

    catRafelski = '/Users/kschmidt/work/catalogs/rafelski/uvudf_rafelski_2015.fits'
    if verbose: print('   '+catRafelski)
    datRafelski = afits.open(catRafelski)[1].data

    #catLaigle = '/Users/kschmidt/work/catalogs/COSMOS2015_Laigle_v1.1.fits'
    catLaigle = '/Users/kschmidt/work/catalogs/COSMOS2015_Laigle_v1.1_candelsregion.fits' # generated with TOPCAT
    if verbose: print('   '+catLaigle )
    datLaigle  = afits.open(catLaigle)[1].data

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Counting LAEs and putting together ID list')
    e24_ids  = datE24main['UNIQUE_ID'].astype(str)
    e36_ids  = datE36main['ID'].astype(str)
    e40_ids  = datE40main['ID'].astype(str)
    udfs_ids = datUDFSmain['ID'].astype(str)
    udf_ids  = np.asarray(["6"+str("%08d" % udfid) for udfid in datUDFmain['ID']])
    u10_ids  = np.asarray(["7"+str("%08d" % u10id) for u10id in datU10main['ID']])
    objids   = []

    zcut     = 2.7 # LAEs
    zcut     = 1.5 # UVemitters; objects with potential CIII]1909 (or below) and no OII
    # - - - - - - - - - - - - - E24 - - - - - - - - - - - - - -
    for ii,id in enumerate(e24_ids):
        if datE24main['Z'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - E36 - - - - - - - - - - - - - -
    for ii,id in enumerate(e36_ids):
        if datE36main['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - E40 - - - - - - - - - - - - - -
    for ii,id in enumerate(e40_ids):
        if datE40main['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - UDF Shallow - - - - - - - - - - - - - -
    for ii,id in enumerate(udfs_ids):
        if datUDFSmain['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - UDF Mosaic - - - - - - - - - - - - - -
    for ii,id in enumerate(udf_ids):
        if datUDFmain['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - UDF-10 - - - - - - - - - - - - - -
    for ii,id in enumerate(u10_ids):
        if datU10main['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    objids = np.sort(np.asarray(objids).astype(int))
    # objids[0] = 1: CDFS
    # objids[0] = 2: COSMOS
    # objids[0] = 3: Parallel hudf09-1
    # objids[0] = 4: Parallel hudf09-2
    # objids[0] = 5: UDF-mosaic-shallow
    # objids[0] = 6: UDF-mosaic
    # objids[0] = 7: UDF-10
    #objids = np.array([106003018,131016105,153024080,206004030,302038138,404010192,509084195,600100628,614564367,720060067])
    NLAEs  = len(objids)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Assembling info for the '+str(NLAEs)+' LAEs found')
    galfitmodeldir  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/imgblocks_josieGALFITmodels/'
    redshifts       = []
    ras             = []
    decs            = []
    pointing        = []
    x_image         = []
    y_image         = []
    name_model      = []
    N_model_comp    = []
    ras_model       = []
    decs_model      = []
    delta_coords    = []
    x_image_model   = []
    y_image_model   = []

    # v v v    line props    v v v
    z_vac_red           = []
    z_vac_error         = []
    z_vac_mean          = []
    num_peaks           = []
    fwhm_A              = []
    fwhm_A_std          = []
    fwhm_kms            = []
    fwhm_kms_std        = []
    peak_sep_A          = []
    peak_sep_A_std      = []
    peak_sep_kms        = []
    peak_sep_kms_std    = []
    sum_fit             = []
    sum_fit_std         = []
    sum_fit_blue        = []
    sum_fit_blue_std    = []
    sum_fit_red         = []
    sum_fit_red_std     = []
    sum_lsdcat          = []
    sum_lsdcat_std      = []

    red_peak_shift_V18_kms      = []  # Red peak shift estimate based on A. Verhamme et al. (2017) relations
    red_peak_shift_V18_kms_err  = []
    z_sys_V18                   = []  # Systemic redshift estimate based on A. Verhamme et al. (2017) relations
    z_sys_V18_err               = []

    # v v v    Lya EW props  v v v
    EW_0                 = []
    EW_0_err             = []
    beta                 = []
    beta_err             = []
    flux_acs_606w        = []
    flux_err_acs_606w    = []
    flux_acs_775w        = []
    flux_err_acs_775w    = []
    flux_acs_814w        = []
    flux_err_acs_814w    = []
    flux_wfc3_125w       = []
    flux_err_wfc3_125w   = []
    flux_wfc3_160w       = []
    flux_err_wfc3_160w   = []

    # v v v    Phot Cat Match  v v v
    idsGuo      = []
    sepsGuo     = []
    rasGuo      = []
    decsGuo     = []

    idsSkelton  = []
    sepsSkelton = []
    rasSkelton  = []
    decsSkelton = []

    idsRafelski  = []
    sepsRafelski = []
    rasRafelski  = []
    decsRafelski = []

    idsLaigle  = []
    sepsLaigle = []
    rasLaigle  = []
    decsLaigle = []

    leadline    = []
    leadlineSN  = []

    for ii,id in enumerate(objids):
        if verbose:
            infostr = '  >Getting info for '+str(id)+' ('+str("%.5d" % (ii+1))+' / '+str("%.5d" % NLAEs)+')  '
            if verbose: print(infostr)
            # sys.stdout.write("%s\r" % infostr)
            # sys.stdout.flush()
        imgignorstr = '_wht_'
        # - - - - - - - - - - GET LSDCAT COORDINATES - - - - - - - - - -
        if str(id) in e24_ids:
            pointingname = mu.gen_pointingname(id)
            pointing.append(pointingname)

            objent = np.where(datE24main['UNIQUE_ID'] == str(id))[0]
            redshifts.append(datE24main['Z'][objent][0])
            ras.append(datE24main['RA'][objent][0])
            decs.append(datE24main['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datE24main['RA'][objent],datE24main['DEC'][objent],pointingname,pixorigin=0,
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*814*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datE24main['LEAD_LINE'][objent][0])
            leadlineSN.append(datE24main['SN'][objent][0])
        elif str(id) in e36_ids:
            pointingname = mu.gen_pointingname(id)
            pointing.append(pointingname)

            objent = np.where(datE36main['ID'] == id)[0]
            redshifts.append(datE36main['REDSHIFT'][objent][0])
            ras.append(datE36main['RA'][objent][0])
            decs.append(datE36main['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datE36main['RA'][objent],datE36main['DEC'][objent],pointingname,
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*814*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datE36main['LINE_ID'][objent][0])
            leadlineSN.append(datE36main['S2N'][objent][0])
        elif str(id) in e40_ids:
            pointingname = mu.gen_pointingname(id)
            pointing.append(pointingname)

            objent = np.where(datE40main['ID'] == id)[0]
            redshifts.append(datE40main['REDSHIFT'][objent][0])
            ras.append(datE40main['RA'][objent][0])
            decs.append(datE40main['DEC'][objent][0])
            if str(id).startswith('1') or str(id).startswith('2'):
                imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*814*'
            else:
                imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*775*'
            ximg, yimg = mu.get_pixelpos(datE40main['RA'][objent],datE40main['DEC'][objent],pointingname,
                                         ignorestr=imgignorstr,imgdir=imgdir,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datE40main['LINE_ID'][objent][0])
            leadlineSN.append(datE40main['S2N'][objent][0])
        elif str(id) in udfs_ids:
            objent = np.where(udfs_ids == str(id))[0]

            pointingname = mu.gen_pointingname(id)
            pointing.append(pointingname)

            redshifts.append(datUDFSmain['REDSHIFT'][objent][0])
            ras.append(datUDFSmain['RA'][objent][0])
            decs.append(datUDFSmain['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datUDFSmain['RA'][objent],datUDFSmain['DEC'][objent],pointingname,
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*775*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datUDFSmain['LINE_ID'][objent][0])
            leadlineSN.append(datUDFSmain['S2N'][objent][0])
        elif str(id) in udf_ids:
            objent = np.where(udf_ids == str(id))[0]

            pointingname = 'udf-mosaic'
            pointing.append(pointingname)

            redshifts.append(datUDFmain['REDSHIFT'][objent][0])
            ras.append(datUDFmain['RA'][objent][0])
            decs.append(datUDFmain['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datUDFmain['RA'][objent],datUDFmain['DEC'][objent],pointingname,
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*775*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datUDFmain['LINE_ID'][objent][0])
            leadlineSN.append(datUDFmain['S2N'][objent][0])
        elif str(id) in u10_ids:
            objent = np.where(u10_ids == str(id))[0]

            pointingname = 'udf-10'
            pointing.append(pointingname)

            redshifts.append(datU10main['REDSHIFT'][objent][0])
            ras.append(datU10main['RA'][objent][0])
            decs.append(datU10main['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datU10main['RA'][objent],datU10main['DEC'][objent],'udf-mosaic_v1.5',
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*775*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datU10main['LINE_ID'][objent][0])
            leadlineSN.append(datU10main['S2N'][objent][0])
        else:
            print('Weird... ID not found in E24, E36, E40, UDF10, UDF-shallow or UDF-mosaic id-list... #1')
            pdb.set_trace()
        # - - - - - - - - - - GET MODEL COORDINATES - - - - - - - - - -
        modelfile = glob.glob(galfitmodeldir+'imgblock_'+str("%.9d" % id)+'.fits')

        if len(modelfile) == 0:
            if verbose: print('   No model found; ')
            name_model.append("NoModelFoundIn_"+galfitmodeldir)
            N_model_comp.append(0)
            ras_model.append(0)
            decs_model.append(0)
            delta_coords.append(0)
            x_image_model.append(0)
            y_image_model.append(0)
        elif len(modelfile) > 1:
            sys.exit('Found more than one model file for '+str("%.9d" % id)+'; Found the models '+modelfile)
        else:
            refimg_hdr  = afits.open(modelfile[0])[1].header
            model_hdr   = afits.open(modelfile[0])[2].header
            comps       = []
            for hdrkey in model_hdr.keys():
                if ('COMP_' in hdrkey) & (model_hdr[hdrkey] != 'sky'):
                    comps.append(hdrkey)

            imgwcs      = wcs.WCS(tu.strip_header(refimg_hdr.copy()))

            pix_based_on_model = False
            if pix_based_on_model:
                xstr        = model_hdr['1_XC'].split(' ')
                ystr        = model_hdr['1_YC'].split(' ')

                if len(xstr) > 1:
                    xpix    = int(float(xstr[0]))
                else:
                    if verbose: print('   Model xpix has no err; ')
                    xpix    = int(float(xstr[0][1:-1]))

                if len(ystr) > 1:
                    ypix    = int(float(ystr[0]))
                else:
                    if verbose: print('   Model ypix has no err; ')
                    ypix    = int(float(ystr[0][1:-1]))
            else:
                fit_region     = model_hdr['FITSECT']
                cutrange_low_x = int(float(fit_region.split(':')[0].split('[')[-1]))
                cutrange_low_y = int(float(fit_region.split(',')[-1].split(':')[0]))
                xsize          = model_hdr['NAXIS1']
                ysize          = model_hdr['NAXIS2']

                xpix           = cutrange_low_x + int(xsize/2.)
                ypix           = cutrange_low_y + int(ysize/2.)

            if 'cdfs' in pointingname:
                skycoord    = wcs.utils.pixel_to_skycoord(xpix,ypix,imgwcs, origin=1)
            elif 'cosmos' in pointingname:
                skycoord    = wcs.utils.pixel_to_skycoord(xpix,ypix,imgwcs, origin=0)

            ra_model    = skycoord.ra.value
            dec_model   = skycoord.dec.value

            delta_coord = np.sqrt( (np.cos(np.deg2rad(dec_model))*(ras[ii]-ra_model))**2.0 + (decs[ii]-dec_model)**2.0 )

            name_model.append(modelfile[0])
            N_model_comp.append(len(comps))
            ras_model.append(ra_model)
            decs_model.append(dec_model)
            delta_coords.append(delta_coord*3600.)
            x_image_model.append(xpix)
            y_image_model.append(ypix)

        # - - - - - - - - - - ADD INFO FROM LINE PROPS TABLES - - - - - - - - - -
        if len(modelfile) == 0:
            z_vac_red.append(0.0)
            z_vac_error.append(0.0)
            z_vac_mean.append(0.0)
            num_peaks.append(0.0)
            fwhm_A.append(0.0)
            fwhm_A_std.append(0.0)
            fwhm_kms.append(0.0)
            fwhm_kms_std.append(0.0)
            peak_sep_A.append(0.0)
            peak_sep_A_std.append(0.0)
            peak_sep_kms.append(0.0)
            peak_sep_kms_std.append(0.0)
            sum_fit.append(0.0)
            sum_fit_std.append(0.0)
            sum_fit_blue.append(0.0)
            sum_fit_blue_std.append(0.0)
            sum_fit_red.append(0.0)
            sum_fit_red_std.append(0.0)
            sum_lsdcat.append(0.0)
            sum_lsdcat_std.append(0.0)
            red_peak_shift_V18_kms.append(0.0)
            red_peak_shift_V18_kms_err.append(0.0)
            z_sys_V18.append(0.0)
            z_sys_V18_err.append(0.0)
        else:
            if str(id) in e24_ids:
                objent = np.where(datE24lp['UNIQUE_ID'] == str(id))[0]
                z_vac_red.append(datE24lp['z_vac_red'][objent][0])
                z_vac_error.append(datE24lp['z_vac_error'][objent][0])
                z_vac_mean.append(datE24lp['z_vac_mean'][objent][0])
                num_peaks.append(datE24lp['num_peaks'][objent][0])
                fwhm_A.append(datE24lp['fwhm_A'][objent][0])
                fwhm_A_std.append(datE24lp['fwhm_A_std'][objent][0])
                fwhm_kms.append(datE24lp['fwhm_kms'][objent][0])
                fwhm_kms_std.append(datE24lp['fwhm_kms_std'][objent][0])
                peak_sep_A.append(datE24lp['peak_sep_A'][objent][0])
                peak_sep_A_std.append(datE24lp['peak_sep_A_std'][objent][0])
                peak_sep_kms.append(datE24lp['peak_sep_kms'][objent][0])
                peak_sep_kms_std.append(datE24lp['peak_sep_kms_std'][objent][0])
                sum_fit.append(datE24lp['sum_fit'][objent][0])
                sum_fit_std.append(datE24lp['sum_fit_std'][objent][0])
                sum_fit_blue.append(datE24lp['sum_fit_blue'][objent][0])
                sum_fit_blue_std.append(datE24lp['sum_fit_blue_std'][objent][0])
                sum_fit_red.append(datE24lp['sum_fit_red'][objent][0])
                sum_fit_red_std.append(datE24lp['sum_fit_red_std'][objent][0])
                sum_lsdcat.append(datE24lp['sum_lsdcat'][objent][0])
                sum_lsdcat_std.append(datE24lp['sum_lsdcat_std'][objent][0])
            elif str(id) in e36_ids:
                objent = np.where(datE36lp['UNIQUE_ID'] == str(id))[0]
                z_vac_red.append(datE36lp['z_vac_red'][objent][0])
                z_vac_error.append(datE36lp['z_vac_error'][objent][0])
                z_vac_mean.append(datE36lp['z_vac_mean'][objent][0])
                num_peaks.append(datE36lp['num_peaks'][objent][0])
                fwhm_A.append(datE36lp['fwhm_A'][objent][0])
                fwhm_A_std.append(datE36lp['fwhm_A_std'][objent][0])
                fwhm_kms.append(datE36lp['fwhm_kms'][objent][0])
                fwhm_kms_std.append(datE36lp['fwhm_kms_std'][objent][0])
                peak_sep_A.append(datE36lp['peak_sep_A'][objent][0])
                peak_sep_A_std.append(datE36lp['peak_sep_A_std'][objent][0])
                peak_sep_kms.append(datE36lp['peak_sep_kms'][objent][0])
                peak_sep_kms_std.append(datE36lp['peak_sep_kms_std'][objent][0])
                sum_fit.append(datE36lp['sum_fit'][objent][0])
                sum_fit_std.append(datE36lp['sum_fit_std'][objent][0])
                sum_fit_blue.append(datE36lp['sum_fit_blue'][objent][0])
                sum_fit_blue_std.append(datE36lp['sum_fit_blue_std'][objent][0])
                sum_fit_red.append(datE36lp['sum_fit_red'][objent][0])
                sum_fit_red_std.append(datE36lp['sum_fit_red_std'][objent][0])
                sum_lsdcat.append(datE36lp['sum_lsdcat'][objent][0])
                sum_lsdcat_std.append(datE36lp['sum_lsdcat_std'][objent][0])
            elif (str(id) in e40_ids) or (str(id) in udfs_ids) or (str(id) in udf_ids) or (str(id) in u10_ids):
                z_vac_red.append(-99)
                z_vac_error.append(-99)
                z_vac_mean.append(-99)
                num_peaks.append(-99)
                fwhm_A.append(-99)
                fwhm_A_std.append(-99)
                fwhm_kms.append(-99)
                fwhm_kms_std.append(-99)
                peak_sep_A.append(-99)
                peak_sep_A_std.append(-99)
                peak_sep_kms.append(-99)
                peak_sep_kms_std.append(-99)
                sum_fit.append(-99)
                sum_fit_std.append(-99)
                sum_fit_blue.append(-99)
                sum_fit_blue_std.append(-99)
                sum_fit_red.append(-99)
                sum_fit_red_std.append(-99)
                sum_lsdcat.append(-99)
                sum_lsdcat_std.append(-99)
            else:
                print('Weird... ID not found in E24, E36, E40, UDF-10, UDF-shallow or UDF-mosaic id-list... #2')
                pdb.set_trace()

            if peak_sep_kms[ii] != 0.0:
                rp_shift_V18_kms     = 1.00 * peak_sep_kms[ii]/2.
                rp_shift_V18_kms_err = np.abs(rp_shift_V18_kms) * \
                                        np.sqrt( (peak_sep_kms_std[ii]/peak_sep_kms[ii])**2 + (0.04/1.00)**2)
            elif peak_sep_kms[ii] == -99:
                rp_shift_V18_kms     = -99
                rp_shift_V18_kms_err = -99
            else:
                rp_shift_V18_kms     = 0.86 * fwhm_kms[ii]
                rp_shift_V18_kms_err = np.abs(rp_shift_V18_kms) * \
                                        np.sqrt( (fwhm_kms_std[ii]/fwhm_kms[ii])**2 + (0.04/0.86)**2)

            # Estimate systemic redshift using Lya offest from Verhamme+17 and Eq. (5) Erb+14 relating this to z_sys
            if rp_shift_V18_kms == -99:
                z_sys           = -99
                z_sys_err       = -99
            else:
                c_val           = astropy.constants.c.value/1000.
                numerator       = ( z_vac_red[ii] - rp_shift_V18_kms/c_val)
                numerator_err   = np.sqrt( z_vac_error[ii]**2.0 + (rp_shift_V18_kms_err/rp_shift_V18_kms)**2.0 )
                denominator     = (rp_shift_V18_kms/c_val + 1.0)
                denominator_err = rp_shift_V18_kms_err/np.abs(rp_shift_V18_kms)
                z_sys           = numerator / denominator
                z_sys_err       = np.abs(z_sys) * \
                                  np.sqrt( (numerator_err/numerator)**2.0 + (denominator_err/denominator)**2.0 )

            red_peak_shift_V18_kms.append(rp_shift_V18_kms)
            red_peak_shift_V18_kms_err.append(rp_shift_V18_kms_err)
            z_sys_V18.append(z_sys)
            z_sys_V18_err.append(z_sys_err)

        # - - - - - - - - - - ADD INFO FROM EW LINE PROPS TABLE - - - - - - - - - -
        if len(modelfile) == 0:
            EW_0.append(0.0)
            EW_0_err.append(0.0)
            beta.append(0.0)
            beta_err.append(0.0)
            flux_acs_606w.append(0.0)
            flux_err_acs_606w.append(0.0)
            flux_acs_775w.append(0.0)
            flux_err_acs_775w.append(0.0)
            flux_acs_814w.append(0.0)
            flux_err_acs_814w.append(0.0)
            flux_wfc3_125w.append(0.0)
            flux_err_wfc3_125w.append(0.0)
            flux_wfc3_160w.append(0.0)
            flux_err_wfc3_160w.append(0.0)
        else:
            objent = np.where(datLyaEW['IDs'] == str(id))[0]
            EW_0.append(datLyaEW['EW_0'][objent][0])
            EW_0_err.append(datLyaEW['EW_0_err'][objent][0])
            beta.append(datLyaEW['beta'][objent][0])
            beta_err.append(datLyaEW['beta_err'][objent][0])
            flux_acs_606w.append(datLyaEW['flux_acs_606w'][objent][0])
            flux_err_acs_606w.append(datLyaEW['flux_err_acs_606w'][objent][0])
            flux_acs_775w.append(datLyaEW['flux_acs_775w'][objent][0])
            flux_err_acs_775w.append(datLyaEW['flux_err_acs_775w'][objent][0])
            flux_acs_814w.append(datLyaEW['flux_acs_814w'][objent][0])
            flux_err_acs_814w.append(datLyaEW['flux_err_acs_814w'][objent][0])
            flux_wfc3_125w.append(datLyaEW['flux_wfc3_125w'][objent][0])
            flux_err_wfc3_125w.append(datLyaEW['flux_err_wfc3_125w'][objent][0])
            flux_wfc3_160w.append(datLyaEW['flux_wfc3_160w'][objent][0])
            flux_err_wfc3_160w.append(datLyaEW['flux_err_wfc3_160w'][objent][0])

        # - - - - - - - - - - ADD MATCHES TO PHOTOMETRIC CATALOGS - - - - - - - - - -
        coordMUSE = SkyCoord(ra=ras[ii]*u.degree, dec=decs[ii]*u.degree)

        if str(id)[0] in ['1','5','6','7']: # <------- Match to Guo catalog
            coordGuo  = SkyCoord(ra=datGuo['RA']*u.degree, dec=datGuo['DEC']*u.degree)
            entGuo, match_2DGuo, match_3DGuo = coordMUSE.match_to_catalog_sky(coordGuo)
            idsGuo.append(datGuo['ID'][entGuo])
            sepsGuo.append(match_2DGuo.value[0] * 3600.0)
            rasGuo.append(datGuo['RA'][entGuo])
            decsGuo.append(datGuo['DEC'][entGuo])
        else:
            idsGuo.append(-99)
            sepsGuo.append(-99)
            rasGuo.append(-99)
            decsGuo.append(-99)

        if str(id)[0] in ['1','3','4','5','6','7']: # <------- Match to Skelton GOODS-SOUTH catalog
            coordSkelton  = SkyCoord(ra=datSkeltonGS['RA']*u.degree, dec=datSkeltonGS['DEC']*u.degree)
            entSkelton, match_2DSkelton, match_3DSkelton = coordMUSE.match_to_catalog_sky(coordSkelton)
            idsSkelton.append(datSkeltonGS['ID'][entSkelton])
            sepsSkelton.append(match_2DSkelton.value[0] * 3600.0)
            rasSkelton.append(datSkeltonGS['RA'][entSkelton])
            decsSkelton.append(datSkeltonGS['DEC'][entSkelton])
        elif str(id)[0] in ['2']: # <------- Match to Skelton COSMOS catalog
            coordSkelton  = SkyCoord(ra=datSkeltonCOS['RA']*u.degree, dec=datSkeltonCOS['DEC']*u.degree)
            entSkelton, match_2DSkelton, match_3DSkelton = coordMUSE.match_to_catalog_sky(coordSkelton)
            idsSkelton.append(datSkeltonCOS['ID'][entSkelton])
            sepsSkelton.append(match_2DSkelton.value[0] * 3600.0)
            rasSkelton.append(datSkeltonCOS['RA'][entSkelton])
            decsSkelton.append(datSkeltonCOS['DEC'][entSkelton])
        else:
            idsSkelton.append(-99)
            sepsSkelton.append(-99)
            rasSkelton.append(-99)
            decsSkelton.append(-99)

        if str(id)[0] in ['1','5','6','7']: # <------- Match to Rafelski catalog
            coordRafelski  = SkyCoord(ra=datRafelski['RA']*u.degree, dec=datRafelski['DEC']*u.degree)
            entRafelski, match_2DRafelski, match_3DRafelski = coordMUSE.match_to_catalog_sky(coordRafelski)
            idsRafelski.append(datRafelski['ID'][entRafelski])
            sepsRafelski.append(match_2DRafelski.value[0] * 3600.0)
            rasRafelski.append(datRafelski['RA'][entRafelski])
            decsRafelski.append(datRafelski['DEC'][entRafelski])
        else:
            idsRafelski.append(-99)
            sepsRafelski.append(-99)
            rasRafelski.append(-99)
            decsRafelski.append(-99)

        if str(id)[0] in ['2']: # <------- Match to Laigle cosmos catalog
            coordLaigle  = SkyCoord(ra=datLaigle['ALPHA_J2000']*u.degree, dec=datLaigle['DELTA_J2000']*u.degree)
            entLaigle, match_2DLaigle, match_3DLaigle = coordMUSE.match_to_catalog_sky(coordLaigle)
            idsLaigle.append(datLaigle['NUMBER'][entLaigle])
            sepsLaigle.append(match_2DLaigle.value[0] * 3600.0)
            rasLaigle.append(datLaigle['ALPHA_J2000'][entLaigle])
            decsLaigle.append(datLaigle['DELTA_J2000'][entLaigle])
        else:
            idsLaigle.append(-99)
            sepsLaigle.append(-99)
            rasLaigle.append(-99)
            decsLaigle.append(-99)

    if verbose: print('\n   done...')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Defining fits table and filling it with data')
    c1  = pyfitsOLD.Column(name='id', format='J', unit='', array=objids)
    c2  = pyfitsOLD.Column(name='pointing', format='A30', unit='', array=pointing)
    c3  = pyfitsOLD.Column(name='ra', format='D', unit='DEF', array=ras)
    c4  = pyfitsOLD.Column(name='dec', format='D', unit='DEG', array=decs)
    c5  = pyfitsOLD.Column(name='redshift', format='D', unit='', array=redshifts)
    c6  = pyfitsOLD.Column(name='x_image', format='D', unit='PIXEL', array=x_image)
    c7  = pyfitsOLD.Column(name='y_image', format='D', unit='PIXEL', array=y_image)

    c8  = pyfitsOLD.Column(name='modelname', format='A110', unit='', array=name_model)
    c9  = pyfitsOLD.Column(name='Nmodelcomponents', format='D', unit='DEF', array=N_model_comp)
    c10 = pyfitsOLD.Column(name='ra_model', format='D', unit='DEF', array=ras_model)
    c11 = pyfitsOLD.Column(name='dec_model', format='D', unit='DEG', array=decs_model)
    c12 = pyfitsOLD.Column(name='deltacoord', format='D', unit='DEG', array=delta_coords)
    c13 = pyfitsOLD.Column(name='x_image_model', format='D', unit='PIXEL', array=x_image_model)
    c14 = pyfitsOLD.Column(name='y_image_model', format='D', unit='PIXEL', array=y_image_model)

    c15 = pyfitsOLD.Column(name='z_vac_red', format='D', unit='', array=z_vac_red)
    c16 = pyfitsOLD.Column(name='z_vac_error', format='D', unit='', array=z_vac_error)
    c17 = pyfitsOLD.Column(name='z_vac_mean', format='D', unit='', array=z_vac_mean)
    c18 = pyfitsOLD.Column(name='num_peaks', format='D', unit='', array=num_peaks)
    c19 = pyfitsOLD.Column(name='fwhm_A', format='D', unit='A', array=fwhm_A)
    c20 = pyfitsOLD.Column(name='fwhm_A_std', format='D', unit='A', array=fwhm_A_std)
    c21 = pyfitsOLD.Column(name='fwhm_kms', format='D', unit='KM/S', array=fwhm_kms)
    c22 = pyfitsOLD.Column(name='fwhm_kms_std', format='D', unit='KM/S', array=fwhm_kms_std)
    c23 = pyfitsOLD.Column(name='peak_sep_A', format='D', unit='A', array=peak_sep_A)
    c24 = pyfitsOLD.Column(name='peak_sep_A_std', format='D', unit='A', array=peak_sep_A_std)
    c25 = pyfitsOLD.Column(name='peak_sep_kms', format='D', unit='KM/S', array=peak_sep_kms)
    c26 = pyfitsOLD.Column(name='peak_sep_kms_std', format='D', unit='KM/S', array=peak_sep_kms_std)
    c27 = pyfitsOLD.Column(name='sum_fit', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit)
    c28 = pyfitsOLD.Column(name='sum_fit_std', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_std)
    c29 = pyfitsOLD.Column(name='sum_fit_blue', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_blue)
    c30 = pyfitsOLD.Column(name='sum_fit_blue_std', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_blue_std)
    c31 = pyfitsOLD.Column(name='sum_fit_red', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_red)
    c32 = pyfitsOLD.Column(name='sum_fit_red_std', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_red_std)
    c33 = pyfitsOLD.Column(name='sum_lsdcat', format='D', unit='1e-20*ERG/S/CM**2', array=sum_lsdcat)
    c34 = pyfitsOLD.Column(name='sum_lsdcat_std', format='D', unit='1e-20*ERG/S/CM**2', array=sum_lsdcat_std)

    c35 = pyfitsOLD.Column(name='red_peak_shift_V18_kms', format='D', unit='KM/S', array=red_peak_shift_V18_kms)
    c36 = pyfitsOLD.Column(name='red_peak_shift_V18_kms_err', format='D', unit='KM/S', array=red_peak_shift_V18_kms_err)
    c37 = pyfitsOLD.Column(name='z_sys_V18', format='D', unit='', array=z_sys_V18)
    c38 = pyfitsOLD.Column(name='z_sys_V18_err', format='D', unit='', array=z_sys_V18_err)

    c39 = pyfitsOLD.Column(name='EW_0', format='D', unit='A', array=EW_0)
    c40 = pyfitsOLD.Column(name='EW_0_err', format='D', unit='A', array=EW_0_err)
    c41 = pyfitsOLD.Column(name='beta', format='D', unit='', array=beta)
    c42 = pyfitsOLD.Column(name='beta_err', format='D', unit='', array=beta_err)
    c43 = pyfitsOLD.Column(name='flux_acs_606w', format='D', unit='ERG/S/CM**2', array=flux_acs_606w)
    c44 = pyfitsOLD.Column(name='flux_err_acs_606w', format='D', unit='ERG/S/CM**2', array=flux_err_acs_606w)
    c45 = pyfitsOLD.Column(name='flux_acs_775w', format='D', unit='ERG/S/CM**2', array=flux_acs_775w)
    c46 = pyfitsOLD.Column(name='flux_err_acs_775w', format='D', unit='ERG/S/CM**2', array=flux_err_acs_775w)
    c47 = pyfitsOLD.Column(name='flux_acs_814w', format='D', unit='ERG/S/CM**2', array=flux_acs_814w)
    c48 = pyfitsOLD.Column(name='flux_err_acs_814w', format='D', unit='ERG/S/CM**2', array=flux_err_acs_814w)
    c49 = pyfitsOLD.Column(name='flux_wfc3_125w', format='D', unit='ERG/S/CM**2', array=flux_wfc3_125w)
    c50 = pyfitsOLD.Column(name='flux_err_wfc3_125w', format='D', unit='ERG/S/CM**2', array=flux_err_wfc3_125w)
    c51 = pyfitsOLD.Column(name='flux_wfc3_160w', format='D', unit='ERG/S/CM**2', array=flux_wfc3_160w)
    c52 = pyfitsOLD.Column(name='flux_err_wfc3_160w', format='D', unit='ERG/S/CM**2', array=flux_err_wfc3_160w)

    c53 = pyfitsOLD.Column(name='id_guo'     , format='D', unit='', array=idsGuo)
    c54 = pyfitsOLD.Column(name='sep_guo'    , format='D', unit='ARCSEC', array=sepsGuo)
    c55 = pyfitsOLD.Column(name='ra_guo'     , format='D', unit='DEG', array=rasGuo)
    c56 = pyfitsOLD.Column(name='dec_guo'    , format='D', unit='DEG', array=decsGuo)

    c57 = pyfitsOLD.Column(name='id_skelton' , format='D', unit='', array=idsSkelton)
    c58 = pyfitsOLD.Column(name='sep_skelton', format='D', unit='ARCSEC', array=sepsSkelton)
    c59 = pyfitsOLD.Column(name='ra_skelton' , format='D', unit='DEG', array=rasSkelton)
    c60 = pyfitsOLD.Column(name='dec_skelton', format='D', unit='DEG', array=decsSkelton)

    c61 = pyfitsOLD.Column(name='id_rafelski' , format='D', unit='', array=idsRafelski)
    c62 = pyfitsOLD.Column(name='sep_rafelski', format='D', unit='ARCSEC', array=sepsRafelski)
    c63 = pyfitsOLD.Column(name='ra_rafelski' , format='D', unit='DEG', array=rasRafelski)
    c64 = pyfitsOLD.Column(name='dec_rafelski', format='D', unit='DEG', array=decsRafelski)

    c65 = pyfitsOLD.Column(name='id_Laigle' , format='D', unit='', array=idsLaigle)
    c66 = pyfitsOLD.Column(name='sep_Laigle', format='D', unit='ARCSEC', array=sepsLaigle)
    c67 = pyfitsOLD.Column(name='ra_Laigle' , format='D', unit='DEG', array=rasLaigle)
    c68 = pyfitsOLD.Column(name='dec_Laigle', format='D', unit='DEG', array=decsLaigle)

    c69 = pyfitsOLD.Column(name='leadline', format='10A', unit='', array=leadline)
    c70 = pyfitsOLD.Column(name='leadlineS2N', format='D', unit='', array=leadlineSN)

    coldefs = pyfitsOLD.ColDefs([c1,c2,c3,c4,c5,c6,c7,c8,
                                 c9,c10,c11,c12,c13,c14,
                                 c15,c16,c17,c18,c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30,c31,c32,c33,c34,
                                 c35,c36,c37,c38,
                                 c39,c40,c41,c42,c43,c44,c45,c46,c47,c48,c49,c50,c51,c52,
                                 c53,c54,c55,c56,c57,c58,c59,c60,
                                 c61,c62,c63,c64,c65,c66,c67,c68,
                                 c69,c70])
    th      = pyfitsOLD.new_table(coldefs) # creating default header

    # writing hdrkeys:'---KEY--',                             '----------------MAX LENGTH COMMENT-------------'
    #th.header.append(('MAG     ' , spec2D[0].header['MAG']   ,'MAG_AUTO from interlaced catalog'),end=True)

    head    = th.header
    tbHDU   = pyfitsOLD.new_table(coldefs, header=head)
    tbHDU.writeto(fitsname, clobber=clobber)
    if verbose: print('   Fits table stored in \n   '+fitsname)

    if genDS9region:
        if verbose: print(' - Generating DS9 region file')
        regionname = fitsname.replace('.fits','.reg')
        kbs.create_DS9region(regionname,ras,decs,color='magenta',circlesize=0.5,textlist=objids.astype(str),clobber=clobber)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_LAEidLists(sourcecatalog,skipids=True,includecomponentinfo=True,verbose=True):
    """
    Generate TDOSE setupfiles for the LAE extractions

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    sourcecatalog = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    idlists = uves.get_LAEidLists(sourcecatalog)

    """
    sourcetab = afits.open(sourcecatalog)[1].data
    pointings = np.unique(np.sort(sourcetab['pointing']))

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    counterNB = 0
    counterNC = 0
    ids2skip = []
    if skipids:
        ids2skip.append(121033078)  # Object with CIV being main line (conf=1) with potential Lya; no model available
        ids2skip.append(211049280)  # Potential CIII emitter (conf=1) at 2.76, i.e., no Lya in MUSE

        if includecomponentinfo:
            # IDs with no component corresponding to LAE in model, according to:
            compinfo  = open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/171012_LAEs_component_info.txt','r')
            for ll, line in enumerate(compinfo.readlines()):
                if not line.startswith('#'):
                    cols = line.split()
                    # - - - - - - - - - - - - Check for no assigned components - - - - - - - - - - - -
                    assignedcomponent = False
                    for col in cols:
                        if (len(col) == 3) & (':' in col):
                            if col.split(':')[1] == '1':
                                assignedcomponent = True

                    if not assignedcomponent:
                        counterNC = counterNC+1
                        ids2skip.append(int(cols[1]))
                        if verbose: print('   '+str(ll)+', '+str(counterNC)+
                                          '   No assigned component for '+cols[1]+' as '+
                                          ' '.join(cols[2:8])+'[...]')
                    # - - - - - - Check for neighbors, i.e., dublicate IDs in source catalogs - - - - - -
                    if ' NB ' in line:
                        counterNB = counterNB+1
                        ids2skip.append(int(cols[1]))
                        if verbose: print('   '+str(ll)+', '+str(counterNB)+
                                          "   Close neighbor causing duplicate ID'ing for "+cols[1])
                    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ids2skip  = np.unique(np.sort(np.asarray(ids2skip)))
    Nobj_skip = len(ids2skip)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Nobj      = len(sourcetab['id'])
    if verbose: print(' - Will put id lists together for the '+str(Nobj-Nobj_skip)+
                      '; (Nobj, Nobj_NB, Nobj_Ncomp, Nobj_skip) = ('+str(Nobj)+', '+str(counterNB)+', '+str(counterNC)+', 2)')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    idlists = {}

    for pp, pointing in enumerate(pointings):
        objents     = np.where(sourcetab['pointing'] == pointing)[0]
        idlist      = []
        for laeid in sourcetab['id'][objents]:
            if not laeid in ids2skip:
                idlist.append(laeid)

        if verbose: print(pointing+'    '+str(idlist).replace(', ',','))
        idlists[pointing] = idlist

    return idlists
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_LAEsourceCats(outputdir,sourcecatalog,modelcoord=False,verbose=True):
    """
    Generating MUSE-Wide pointing source catalogs for TDOSE extraction of LAEs

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.gen_LAEsourceCats('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats/','/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits',modelcoord=True)

    """
    sourcetab = afits.open(sourcecatalog)[1].data
    pointings = np.unique(np.sort(sourcetab['pointing']))

    for pp, pointing in enumerate(pointings):
        objents     = np.where(sourcetab['pointing'] == pointing)[0]
        pointingcat = outputdir+'tdose_sourcecat_LAEs_'+pointing+'.txt'
        fout = open(pointingcat,'w')
        fout.write('# TDOSE Source catalog generated with uvEmissionlineSearch.gen_LAEsourceCats() \n')
        fout.write('# \n')
        fout.write('# parent_id id ra dec x_image y_image fluxscale \n')

        # if '02' in pointing:        pdb.set_trace()
        ids2skip = []
        ids2skip.append(121033078)  # Object with CIV being main line (conf=1) with potential Lya; no model available
        ids2skip.append(211049280)  # Potential CIII emitter (conf=1) at 2.76, i.e., no Lya in MUSE

        for objent in objents:
            objstr = ' -99  '

            if sourcetab['ID'][objent] in ids2skip:
                continue
            else:
                objstr = objstr + str(sourcetab['ID'][objent]) + ' '
                if modelcoord == True:
                    objstr = objstr + str(sourcetab['ra_model'][objent]) + ' '
                    objstr = objstr + str(sourcetab['dec_model'][objent]) + ' '
                    objstr = objstr + str(sourcetab['x_image_model'][objent]) + ' '
                    objstr = objstr + str(sourcetab['y_image_model'][objent]) + ' '
                else:
                    objstr = objstr + str(sourcetab['RA'][objent]) + ' '
                    objstr = objstr + str(sourcetab['DEC'][objent]) + ' '
                    objstr = objstr + str(sourcetab['x_image_F814W'][objent]) + ' '
                    objstr = objstr + str(sourcetab['y_image_F814W'][objent]) + ' '
                objstr = objstr + ' 1.0000 ' + ' \n'

                fout.write(objstr)
        fout.close()

        pointingcat_fits = f2a.ascii2fits(pointingcat,asciinames=True,skip_header=2,fitsformat='D',verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_LAEsourceCats_fromGALFITmodelCubeSourceCats(outputdir,sourcecatalog,modelsourcecatdir,ignore99s=False,verbose=True):
    """
    Generating MUSE-Wide pointing source catalogs for TDOSE extraction of LAEs where all objects from
    the source catalogs generated when converting GALFIT models into cubes are combined

    --- INPUT ---
    outputdir            Output directory to contain pointing source catalogs
    sourcecatalog        Source catalog of LAEs to get pointing names from
    modelsourcecatdir    Directory containing the source catalogs generated when converting
                         LAE galfit models into cubes that TDOSE can understand for the spectral extractions.
    ignore99s            Ignore objects with (parent)IDs of -99? These are the central coordinates of the models.

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    outputdir         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats/'
    sourcecat         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    modelsourcecatdir = '/Volumes/DATABCKUP1/TDOSEextractions/MW_LAEs_JKgalfitmodels/'

    uves.gen_LAEsourceCats_fromGALFITmodelCubeSourceCats(outputdir,sourcecat,modelsourcecatdir,ignore99s=False)

    """
    sourcetab = afits.open(sourcecatalog)[1].data
    pointings = np.unique(np.sort(sourcetab['pointing']))

    for pp, pointing in enumerate(pointings):
        modelsourcecats = glob.glob(modelsourcecatdir+'/*'+pointing+'*_sourcecatalog.txt')

        pointingcat     = outputdir+'tdose_sourcecat_LAEs_'+pointing+'.txt'
        fout = open(pointingcat,'w')
        fout.write('# TDOSE Source catalog generated with uvEmissionlineSearch.gen_LAEsourceCats_fromGALFITmodelCubeSourceCats() on '+tu.get_now_string()+'  \n')
        fout.write('# \n')
        fout.write('# parent_id id ra dec x_image y_image fluxscale \n')

        for modcat in modelsourcecats:
            catinfo = open(modcat,'r')
            for line in catinfo.readlines():
                if line.startswith('#'):
                    pass
                else:
                    if ignore99s:
                        if line.split()[0] == '-99':
                            pass
                        else:
                            fout.write(line)
                    else:
                        fout.write(line)
        fout.close()

        pointingcat_fits = f2a.ascii2fits(pointingcat,asciinames=True,skip_header=2,fitsformat='D',verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_LAEsourceCats_FromPhotCat(outputdir,MUSEIDlist,LAEinfo,sourcecatradius=15.0,photcat='skelton',
                                  refimgdir='/Volumes/DATABCKUP1/MUSE-Wide/hst_cutouts/',returnSeparations=False,
                                  clobber=False,verbose=True):
    """
    Generate source catalogs based on photometric catalogs for individual MUSE Wide objects
    but adding the LSDCat coordinates as seperate soource


    --- INPUT ---
    outputdir            Output directory to contain object source catalogs
    MUSEIDlist           List of objects to generate source catalogs for
    LAEinfo              LAE info file
    sourcecatradius      Radius to search and return in the source catalogs
    photcat              The photmetric cataog to match to
    refimgdir            The reference image directory used to get WCS info
    returnSeparations    Return the separations in the fluxscale column of the source catalog

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    outputdir         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats_noModelComponent/'
    LAEinfo           = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    MUSEIDlist        = [121033078,211015198]
    #MUSEIDlist        = [101005016,117027076,123016117,125049122,141003075,144008046,146069355,201073224,202013030,202044085,203007099,204053120,206014089,207022169,209006108,211015198,212029067,213022109,215016042]
    uves.gen_LAEsourceCats_FromPhotCat(outputdir,MUSEIDlist,LAEinfo,photcat='skelton',returnSeparations=False)

    """
    LAEinfo = afits.open(LAEinfo)[1].data

    for Mid in MUSEIDlist:
        idstr = str(Mid)
        if idstr.startswith('1') or idstr.startswith('6'):
            if photcat == 'skelton': # GOODS-S (incl. UDF)
                fitscat = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
            elif photcat == 'guo':
                fitscat = '/Users/kschmidt/work/catalogs/guo/CANDELS.GOODSS.F160W.v1.fits'
            else:
                print(' WARNING photcat = '+photcat+' has no setup for GOODS-S source; using Skelton catalog ')
                fitscat = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
        elif idstr.startswith('2'): # COSMOS
            if photcat == 'skelton':
                fitscat = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
            else:
                print(' WARNING photcat = '+photcat+' has no setup for COSMOS source; using Skelton catalog ')
                fitscat = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
        # elif idstr.startswith('6'): # UDF
        #     if photcat == 'skelton':
        #         print(' WARNING photcat = '+photcat+' will be ignored, as object in UDF where Rafelski will be used')
        #         fitscat = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
        #     else:
        #         print(' WARNING photcat = '+photcat+' has no setup for COSMOS source; using Skelton catalog ')
        #         fitscat = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
        else:
            sys.exit(' MUSE-Wide id = '+idstr+' is neither in GOODS-S (starts with "1") nor in COSMOS (starts with "2")')

        objent  = np.where(LAEinfo['id'] == Mid)[0]
        objra   = LAEinfo['ra'][objent][0]
        objdec  = LAEinfo['dec'][objent][0]
        if len(objent) == 0:
            print(' WARNING No match in LAE info file for MUSE-Wide_ID = '+idstr)

        refimg       = refimgdir+'acs_814w_'+LAEinfo['pointing'][objent][0]+'_cut_v1.0.fits'
        if idstr.startswith('6'):
            refimg   = refimgdir+'hlsp_hlf_hst_acs-30mas_goodss_f775w_udf-mosaic_v1.5_sci.fits'
        imgheader    = afits.open(refimg)[0].header
        sourcelist   = [ [Mid, Mid, objra, objdec, 1]]
        outname      = outputdir+'tdose_sourcecat_from_fitscat_id'+idstr+'.txt'

        if returnSeparations:
            fluxfactor = 'separation'
        else:
            fluxfactor = 1.0

        sourcecat    = tu.gen_sourcecat_from_FitsCat(fitscat,'id','ra','dec',[objra,objdec],sourcecatradius,imgheader,
                                                     fluxfactor=fluxfactor,outname=outname,newsources=sourcelist,
                                                     clobber=clobber,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_GALFITmodelcubes(GALFITmodels,outputdir,PSFmodels=None,PSFmodelext=2,sourcecat_compinfo=None,
                         refnamebase='model_acs_814w_PPPP_cut_v1.0_idIIII_cutout2p0x2p0arcsec.fits',
                         pointsourcefile=None,pointsourcescale=1.0,ignore_radius=0.5,clobber=False,verbose=True):
    """

    Function loading galfit models from modelinputdir (assumed to be names as imgblock_ID.fits), renaming them,
    converting them to cubes and generating the corresponding source catalogs needed by TDOSE. It also generates
    a template component info file which can be edited (after copying to a new file) and be provided back to the
    script for a second run updating the the cubes and source catalogs accordingly.

    --- INPUT ---


    --- EXMAMPLE OF USE ---
    import glob
    import uvEmissionlineSearch as uves

    GALFITmodels    = glob.glob('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/imgblocks_josieGALFITmodels/imgblock_*.fits')
    outputdir       = '/Volumes/DATABCKUP2/TDOSEextractions/MW_LAEs_JKgalfitmodels/'
    PSFmodels       = ['/Users/kschmidt/work/MUSE/uvEmissionlineSearch/F814Wpsfmodel_imgblock_6475.fits']*len(GALFITmodels)
    pointsourcefile = None #'/Users/kschmidt/work/MUSE/uvEmissionlineSearch/pointsourceobjects.txt'
    uves.gen_GALFITmodelcubes(GALFITmodels,outputdir,PSFmodels=PSFmodels,sourcecat_compinfo=None,pointsourcefile=pointsourcefile)

    """
    Nmodels = len(GALFITmodels)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print ' - Renaming files of '+str(Nmodels)+' models profived to GALFITmodels keyword'
    models_renamed = []
    model_ids      = []
    for modelname in GALFITmodels:
        objid    = modelname.split('block_')[-1].split('.fit')[0]
        pointing = mu.gen_pointingname(objid)
        newname  = outputdir+'/'+refnamebase.replace('IIII',str(objid)).replace('PPPP',pointing)
        cpcmd    = ' cp '+modelname+' '+newname
        if os.path.isfile(newname) & (clobber == False):
            if verbose: print ' clobber = False and '+newname+' already exists, so moving on to next file.'
        else:
            cpout = commands.getoutput(cpcmd)
        models_renamed.append(newname)
        model_ids.append(objid)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if pointsourcefile is not None:
        if verbose: print ' - Assembling list of models for objects to use point source extractions for '
        pointsources      = np.genfromtxt(pointsourcefile,dtype=None,comments='#')
        try:
            pointsourcescales = [pointsourcescale]*len(pointsources)
            ignore_radii      = [ignore_radius]*2 # same radius in x and y dimension
        except:
            pointsourcescales = pointsourcescale
            ignore_radii      = ignore_radius
    else:
        pointsources      = None
        pointsourcescales = 'dummy'
        ignore_radii      = 'dummy'

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if PSFmodels is None:
        PSFlist = None
    else:
        if verbose: print ' - Loading PSF models '
        if type(PSFmodels) is list:
            PSFlist = []
            if type(PSFmodelext) is not list:
                PSFmodelext = [PSFmodelext] * len(PSFmodels)
            for mm, PSFmodel in enumerate(PSFmodels):
                PSFlist.append(afits.open(PSFmodel)[PSFmodelext[mm]].data)
        else:
            PSFlist = [afits.open(PSFmodels)[PSFmodelext].data]*len(GALFITmodels)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    gen_compinfofile = True
    if sourcecat_compinfo is None:
        compinfofile = None
    else:
        if os.path.isfile(sourcecat_compinfo):
            if verbose: print ' - Will use existing point source component file provided:\n   '+sourcecat_compinfo
            compinfofile     = sourcecat_compinfo
            gen_compinfofile = False
            if verbose: print '   (no new file/template will be generated)'
        else:
            compinfofile = None

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print ' - Building cubes from renamed GALFIT models'
    # newlist = []
    # for mod in models_renamed:
    #     if 'id12400' in mod: newlist.append(mod)
    # models_renamed = newlist

    tu.galfit_convertmodel2cube(models_renamed,includewcs=True,savecubesumimg=True,convkernels=PSFlist,
                                sourcecat_compinfo=compinfofile,normalizecomponents=True,pointsources=pointsources,
                                ignore_radius=ignore_radii,pointsourcescales=pointsourcescales,includesky=False,
                                clobber=clobber,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if gen_compinfofile:
        if verbose: print ' - Generating component info file template for source catalog updates'
        skip = False
        if sourcecat_compinfo is None:
            compinfofile = './component_info_template_RENAME_.txt'
            if os.path.isfile(compinfofile) & (clobber == False):
                if verbose: print '   ... but '+compinfofile+' exists and clobber=False, so skipping.'
                skip = True
        else:
            if os.path.isfile(compinfofile) & (clobber == False):
                if verbose: print '   ... but '+compinfofile+' exists and clobber=False, so skipping.'
                skip = True
            else:
                compinfofile = sourcecat_compinfo

        if not skip:
            fout = open(compinfofile,'w')
            fout.write("""# TDOSE source catalog components keys for J. Kerutt's 2x2 arcsec GALFIT models of the MUSE-Wide LAEs from
# the first 60 MUSE-Wide pointings.
#
# --- TEMPLATE --- generated with uvEmissionlineSearch.gen_GALFITmodelcubes() on %s
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# modelfilename        Path and name of model file
# id                   MUSE-Wide object ID
# componentinfo        Information on the model components given as ComponentNumber:InfoKey
#                      where the info keys are:  1 = object, 2 = contaminant and 3 = sky
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The following default notes are used for commenting after ">>>Notes>>>:" (appended by notes from JK's inspection)
#
# NoteKey      ShortRef           NoteExplanation
#
# ND           Non Detection      A (visual) non detection in all the optical bands (606, 775W, 814W, 850LP)
# PS           Point Source       Add a point source at central location to represent the soource
# BD           Blue detection     Detection in filters blue-wards of the Lyalpha line (filters not including the Lyalpha wavelength)
# WD           Weak drop          There is a week drop in the filters blue wards of the Lyalpha line
# MO           Model offset       The model appears offset compared to LSDCat (Lyalpha) location
# NBid         Neighbor           A neioghboring LAE (with id "id") which can potentially cause confusion/overlap of LAE spectra exists
# DFfilter     Detection Filter   Object only detected in (a few) filters. Indicate those with multiple DFfilter comments
# OCtext       Other Comment      Anything else to comment on? Follow comment by text
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# modefilename  id  componentinfo
""" % tu.get_now_string())

            for mm, GFmodel in enumerate(GALFITmodels):
                modelheader = afits.open(models_renamed[mm])[2].header
                compstring  = ' '
                for key in modelheader.keys():
                    if 'COMP_' in key:
                        compNo = key.split('OMP_')[-1]
                        if modelheader[key] == 'sky':
                            compstring = compstring + compNo + ':3  '
                        else:
                            compstring = compstring + compNo + ':?  '

                outstring = models_renamed[mm]+'  '+model_ids[mm]+'  '+compstring.ljust(50)+\
                            '     # >>>Notes>>>:  ND  PS  BD  WD  MO  NBid  DFfilter  OCtext    >>>JK notes>>>: '
                jknotes   = open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/imgblocks_josieGALFITmodels_all_ids.txt','r')
                for line in jknotes.readlines():
                    if str(model_ids[mm]) in line:
                        outstring = outstring+'  '+line.replace('\n','').replace('	','   ')+'  '
                jknotes.close()
                fout.write(outstring+' \n')
            fout.close()
            if verbose: print ' - Wrote component info to: '+compinfofile
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def inspect_GALFITmodels(modeldir='/Volumes/DATABCKUP2/TDOSEextractions/MW_LAEs_JKgalfitmodels/',
                         imgdir='/Volumes/DATABCKUP2/MUSE-Wide/hst_cutouts/',modelstart=1,showPhotRegions=True,
                         objids=None,verbose=True):
    """
    Script to put open DS9 windows showing galfit models so they can be inspected

    --- INPUT ---
    modeldir     Directory containing models to display
    modelstart   Where to start the inspection in list of models/objects. Useful to skip ahead in long object lists.
                 E.g. when all models in a directory are to be inspected. First model has modelstart=1
    objids       List of objects ids to display. If None, all objects found in modeldir will be displayed

    --- EXAMPLE OF USE ---

    models = glob.glob('/Volumes/DATABCKUP2/TDOSEextractions/MW_LAEs_JKgalfitmodels/model*arcsec.fits')
    tu.galfit_model_ds9region(models,clobber=True)

    uves.inspect_GALFITmodels(modelstart=3)

    """
    LAEinfo = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data

    if objids is None:
        GALFITmodels = glob.glob(modeldir+'model*arcsec.fits')
    else:
        GALFITmodels = []
        for objid in objids:
            GALFITmodels = GALFITmodels + [mod for mod in glob.glob(modeldir+'model*'+str(objid)+'*arcsec.fits')]
    GALFITmodels      = np.asarray(GALFITmodels)
    if verbose: print ' - Found '+str(len(GALFITmodels))+' GALFIT models'

    loopmodels        = GALFITmodels[modelstart-1:]

    MWregion_cosmos   = '/Users/kschmidt/work/catalogs/MUSE_GTO/MUSE-Wide_objects_cosmos.reg' #candels_cosmos_pointings-all.reg'
    MWregion_cdfs     = '/Users/kschmidt/work/catalogs/MUSE_GTO/MUSE-Wide_objects_cdfs.reg' #candels_cdfs_pointings-all.reg'

    if verbose: print ' - Will look through '+str(len(loopmodels))+' of the models starting with model number '+str(modelstart)

    ds9cmd       = "ds9 -view layout vertical -lock frame wcs -height 650 -width 650 -tile grid layout 4 4 "
    pds9         = subprocess.Popen(ds9cmd,shell=True,executable=os.environ["SHELL"])
    #cmdout       = commands.getoutput(ds9cmd)
    time.sleep(1.1)# sleep to make sure ds9 appear in PIDlist
    for ii in np.arange(1,13):
        out = commands.getoutput('xpaset -p ds9 frame new')
    out = commands.getoutput('xpaset -p ds9 tile yes ')

    Guo_goodss_reg     = '/Users/kschmidt/work/catalogs/guo/CANDELS.GOODSS.F160W.v1_ds9.reg'
    Skelton_goodss_reg = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat_ds9.reg'
    Skelton_cosmos_reg = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat_ds9.reg'

    for mm, GFmodel in enumerate(loopmodels):
        if verbose:
            infostr = '   Displaying files for model '+str("%.5d" % (mm+1))+' / '+str("%.5d" % len(loopmodels))+' in DS9.'
            print infostr,

        modelid      = GFmodel.split('_id')[-1][:9]
        compregion   = GFmodel.replace('.fits','_ds9region.reg')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        out = commands.getoutput('xpaset -p ds9 frame 1 ')
        out = commands.getoutput('xpaset -p ds9 file '+GFmodel+'[1]')
        out = commands.getoutput('xpaset -p ds9 regions '+compregion)
        out = commands.getoutput('xpaset -p ds9 zoom to fit ')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        out = commands.getoutput('xpaset -p ds9 frame 2 ')
        out = commands.getoutput('xpaset -p ds9 file '+GFmodel+'[2]')
        out = commands.getoutput('xpaset -p ds9 regions '+compregion)
        out = commands.getoutput('xpaset -p ds9 zoom to fit ')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        modelcubesum = GFmodel.replace('.fits','_cubesum.fits')
        if os.path.isfile(modelcubesum):
            out = commands.getoutput('xpaset -p ds9 frame 4 ')
            out = commands.getoutput('xpaset -p ds9 file '+modelcubesum)
            out = commands.getoutput('xpaset -p ds9 regions '+compregion)

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        HSTcutouts   = glob.glob(imgdir+'*'+GFmodel.split('/')[-1][15:-37]+'*fits')
        for cc, HSTcutout in enumerate(HSTcutouts):
            out = commands.getoutput('xpaset -p ds9 frame '+str(5+cc))
            out = commands.getoutput('xpaset -p ds9 file '+HSTcutout)
            if 'cosmos' in HSTcutout:
                out = commands.getoutput('xpaset -p ds9 regions '+MWregion_cosmos)
                if showPhotRegions & ('814' in HSTcutout):
                    out = commands.getoutput('xpaset -p ds9 regions '+Skelton_cosmos_reg)
            else:
                out = commands.getoutput('xpaset -p ds9 regions '+MWregion_cdfs)
                if showPhotRegions & ('814' in HSTcutout):
                    out = commands.getoutput('xpaset -p ds9 regions '+Skelton_goodss_reg)
                    out = commands.getoutput('xpaset -p ds9 regions '+Guo_goodss_reg)

            out = commands.getoutput('xpaset -p ds9 scale log 1 10')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        modelcube = GFmodel.replace('.fits','_cube.fits')
        if os.path.isfile(modelcube):
            out = commands.getoutput('xpaset -p ds9 frame 3 ')
            out = commands.getoutput('xpaset -p ds9 file '+modelcube)
            out = commands.getoutput('xpaset -p ds9 regions '+compregion)
            out = commands.getoutput('xpaset -p ds9 zoom to fit ')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        narrowbandimages = glob.glob(modeldir+'*'+modelid+'*narrowbandimage*.fits')
        if len(narrowbandimages) > 0:
            for nn, nbimg in enumerate(narrowbandimages):
                out = commands.getoutput('xpaset -p ds9 frame '+str(13+nn))
                out = commands.getoutput('xpaset -p ds9 file '+nbimg)
                if 'cosmos' in GFmodel:
                    out = commands.getoutput('xpaset -p ds9 regions '+MWregion_cosmos)
                else:
                    out = commands.getoutput('xpaset -p ds9 regions '+MWregion_cdfs)
            out = commands.getoutput('xpaset -p ds9 zoom to fit ')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        # Printing info of object
        if verbose:
            objent =  np.where(LAEinfo['ID'] == int(modelid))
            print '   ID        =  '+modelid
            print '   [ra,dec]  = ['+str(LAEinfo['RA'][objent][0])+','+str(LAEinfo['DEC'][objent][0])+']'
            print '   zMUSE     = '+str(LAEinfo['redshift'][objent][0])
            lamLya    = (LAEinfo['redshift'][objent][0]+1.0) * 1216.0
            print '   lamdaLya  = '+str("%.2f" % lamLya)
            bandsLya  = uves.wavelength_in_bands(lamLya)
            print '   bandsLya  = ',bandsLya
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print '\n Move on to the next model (y/n)? ',
        input = raw_input()
        if (input.lower() == 'y') or (input.lower() == 'yes'):
            continue
        else:
            if verbose: print '\n - Okay; then shutting down '
            return
    if verbose: print '\n - Done; no more objects in loop'
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def wavelength_in_bands(wavelength):
    """
    Returning band names containing a given wavelength
    Can be used to return bands where a certain emission line is included

    Band widths are taken from
    http://svo2.cab.inta-csic.es/svo/theory/fps3/index.php?mode=browse&gname=HST&gname2=ACS_WFC

    Curves are at
    http://www.stsci.edu/hst/wfc3/ins_performance/UVIS_sensitivity/UVIS_Longx.jpg
    http://www.stsci.edu/hst/wfc3/ins_performance/UVIS_sensitivity/UVIS_Wide1.jpg
    http://www.stsci.edu/hst/wfc3/ins_performance/UVIS_sensitivity/UVIS_Wide2.jpg
    http://www.stsci.edu/hst/wfc3/ins_performance/IR_sensitivity/IR4_Wide1_single.jpg
    Linked from
    http://www.stsci.edu/hst/wfc3/ins_performance/ground/components/filters

    """
    infodic           = {}
    infodic['F435W']  = [3599,4861]
    infodic['F606W']  = [4634,7180]
    infodic['F775W']  = [6804,8632]
    infodic['F814W']  = [6885,9648]
    infodic['F850LP'] = [8007,10865]
    infodic['F105W']  = [8947,12129]
    infodic['F125W']  = [10845,14139]
    infodic['F160W']  = [13854,16999]

    bands = []
    for key in infodic.keys():
        if (wavelength >= infodic[key][0]) & (wavelength <= infodic[key][1]):
            bands.append(key)

    return bands
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_TDOSEsetupfiles(infofile,namebase='MUSEWide_tdose_setup_LAEs',clobber=False,
                        outputdir='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_setupfiles/',verbose=True):
    """
    Generate TDOSE setupfiles for the LAE extractions

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    infofile = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_setupfiles/MUSEWide_infofile_arche_PSFupdate_LAEs.txt'
    uves.gen_TDOSEsetupfiles(infofile)

    """
    tu.duplicate_setup_template(outputdir,infofile,namebase=namebase,clobber=clobber,loopcols='all',infofmt="S250",infohdr=2)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def rename_models(outputdir,sourcecatalog,cutoutsize=[2.0,2.0],clobber=False,
                  modeldir='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/imgblocks_josieGALFITmodels/',verbose=True):
    """
    Renmae GALFIT models to comply with TDOSE naming convention (i.e. so TDOSE can find the models when
    looking for them using model_*refimage+cutoutstring*)

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    outputdir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/ref_image_galfit_models/'
    sourcecatalog = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    uves.rename_models(outputdir,sourcecatalog,cutoutsize=[2.0,2.0],clobber=False)
    """
    modelfiles = glob.glob(modeldir+'/imgblock*.fits')
    sourcetab  = afits.open(sourcecatalog)[1].data
    if verbose: print ' - Found '+str(len(modelfiles))+' in modeldir to rename '

    for oldname in modelfiles:
        id     = oldname.split('/')[-1].split('_')[-1].split('.fit')[0]
        objent = np.where(sourcetab['id'] == int(id))[0]

        if len(objent) != 1:
            print ' - No match in sourcecatalog to object '+id
        else:
            pointing = sourcetab['pointing'][objent][0]

            if cutoutsize is None:
                cutoutstr = ''
            else:
                cutoutstr = ('_id'+str("%.9d" % float(id))+'_cutout'+str(cutoutsize[0])+
                             'x'+str(cutoutsize[1])+'arcsec').replace('.','p')

            if 'cdfs' in pointing:
                newname = outputdir+'model_acs_814w_'+pointing+'_cut_v1.0'+cutoutstr+'.fits'
            elif 'cosmos' in pointing:
                newname = outputdir+'model_acs_814w_'+pointing+'_cut_v1.0'+cutoutstr+'.fits'

            if os.path.isfile(newname) & (clobber == False):
                print ' - Clobber = False and '+newname+' already exists so no new copy made. Moving on'
            else:
                if verbose: print ' - Copying '+oldname+' to '+newname
                shutil.copy(oldname,newname)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_ModelReferencePixelCoordinates(modeldir,pixpos='center',printcoords=True,verbose=True):
    """
    Extract the reference coordinates of the GALFIT models from the fits headers

    PROBLEM! GALFIT apparantly doesn't propogate the coordinates of the cutouts. It quotes the reference
             pixel coordinate from the image the cutout was generated from. In the case of the MUSE cutouts
             this means that the coordiantes are the reference position for the fullf-FoV muse pointing
             cutouts and not the individual object cutouts GALFIT is modeling.

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    modeldir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/ref_image_galfit_models/'
    coordarray   = uves.get_ModelReferencePixelCoordinates(modeldir,printcoords=True,verbose=True)

    """
    modelfiles = glob.glob(modeldir+'*.fits')
    Nfiles     = len(modelfiles)
    if verbose: print ' - Found '+str(Nfiles)+' models to extract coordinates from '

    if verbose: print ' - Looping over models and extracting coordinates from: '
    coordarray = np.zeros(Nfiles, dtype={'names':['modelfile','xpix','ypix','ra','dec'],
                                         'formats':['a250', 'f8', 'f8', 'f8', 'f8']})
    for mm, modelfile in enumerate(modelfiles[0:5]):
        model_refimghdr = afits.open(modelfile)[1].header
        imgwcs    = wcs.WCS(tu.strip_header(model_refimghdr.copy()))

        if pixpos == 'center':
            model_shape     = afits.open(modelfile)[1].data.shape
            xpix      = int(model_shape[1]/2.)
            ypix      = int(model_shape[0]/2.)
        else:
            xpix      = pixpos[1]
            ypix      = pixpos[0]

        print imgwcs
        skycoord  = wcs.utils.pixel_to_skycoord(xpix,ypix,imgwcs, origin=0)
        ra        = skycoord.ra.value
        dec       = skycoord.dec.value

        if printcoords & verbose:
            print '   '+modelfile.split('/')[-1]+':  (ra,dec) = ('+str(ra)+','+str(dec)+')'

        coordarray['modelfile'][mm] = modelfile
        coordarray['xpix'][mm]      = xpix
        coordarray['ypix'][mm]      = ypix
        coordarray['ra'][mm]        = ra
        coordarray['dec'][mm]       = dec

    return coordarray
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_narrowbandimages(LAEinfofile,datacubestring,outputdir,linewaves=[1216,1549,1909],fwhmkey='FWHM',
                         clobber=False,verbose=True):
    """
    Generate narrow band images around the location for a set of emission lines.

    If FWHM value is found in LAEinfo file, the relation from Verhamme+17 is used to predict systemic redshift

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    LAEinfofile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    datacubestring = '/Volumes/DATABCKUP2/MUSE-Wide/datacubes_dcbgc_effnoised/DATACUBE_PPPP_v1.0_dcbgc_effnoised.fits'
    outputdir      = '/Volumes/DATABCKUP2/TDOSEextractions/MW_LAEs_JKgalfitmodels/'

    uves.gen_narrowbandimages(LAEinfofile,datacubestring,outputdir,linewaves=[1216,1549,1909],fwhmkey='FWHM',verbose=True)

    """
    LAEinfo = afits.open(LAEinfofile)[1].data

    pointings = LAEinfo['pointing']

    for pointing in np.unique(np.sort(pointings)):
        pointing_objs = np.where(pointings == pointing)[0]

        datacube = glob.glob(datacubestring.replace('PPPP',pointing))

        if len(datacube) == 0:
            if verbose: print ' -----> WARNING No data cube found globbing for '
            if verbose: print '        '+datacubestring.replace('PPPP',pointing)
        elif len(datacube) > 1:
            if verbose: print ' -----> WARNING More than 1 data cube found globbing for '
            if verbose: print '        '+datacubestring.replace('PPPP',pointing)
            if verbose: print '        Using the first found in the list, i.e., '
            datacube = datacube[0]
            if verbose: print '        Extracting from: '+datacube
        else:
            datacube = datacube[0]
            if verbose: print '\n - Extracting from: '+datacube

        ras       = LAEinfo['ra'][pointing_objs]
        decs      = LAEinfo['dec'][pointing_objs]
        names     = LAEinfo['id'][pointing_objs].astype(str)
        redshifts = LAEinfo['redshift'][pointing_objs]

        if fwhmkey in  LAEinfo.columns.names:
            fwhms = LAEinfo[fwhmkey][pointing_objs]
        else:
            fwhms = []

        wcenters = []
        dwaves   = []
        for redshift in redshifts:
            wcen = []
            dwav = []
            if len(fwhms) != 0:
                if verbose: print ' - Estimating systemic redshift using Verhamme+17 z_sys vs Lya_FWHM relation '
                zsys = None
            else:
                zsys = redshift

            for lw in linewaves:
                if lw == 1216:
                    wcen.append(lw*(redshift+1.0))
                    dwav.append(10)
                else:
                    wcen.append(lw*(zsys+1.0))
                    dwav.append(10)

            wcenters.append(wcen)
            dwaves.append(dwav)

        mu.create_narrowband_subcube(datacube,ras,decs,5.0,5.0,wcenters,dwaves,outputdir,names=names,clobber=clobber)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def estimate_limits(spectra,sourcecatalog,lines=['lya','civ','ciii'],deltalam=10,plot=True,verbose=True,printresults=False):
    """
    Get limits at line locations from 1D spectra

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves, glob
    spectra       = glob.glob('/Volumes/DATABCKUP1/TDOSEextractions/tdose_spectra/tdose_spectrum_candels*.fits')
    sourcecatalog = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    limit_output  = uves.estimate_limits(spectra,sourcecatalog,lines=['lya','civ','ciii'],deltalam=3)

    plotbasename = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/estimatelimits'
    uves.plot_limits(sourcecatalog,plotbasename,limit_output)

    """
    if verbose: print(' - Loading source catalog ')
    sourcecat = afits.open(sourcecatalog)[1].data

    Nspec = len(spectra)
    if verbose: print(' - Will estimate limits for lines '+str(lines)+' for '+str(Nspec)+' spectra found')
    outputdic = {}
    outputdic['deltalam'] = deltalam


    for ll, line in enumerate(lines):
        if line.lower() == 'lya':
            line_lams  = [1215.6737]
            use_sys    = False
            keys       = ['lya']
        elif line.lower() == 'civ':
            line_lams  = [1548.195,1550.770]
            use_sys    = True
            keys       = ['civ1548','civ1551']
        elif line.lower() == 'ciii':
            line_lams  = [1907.00,1909.00]
            use_sys    = True
            keys       = ['ciii1907','ciii1909']
        elif line.lower() == 'heii':
            line_lams  = [1640.420]
            use_sys    = True
            keys       = ['heii1640']
        elif line.lower() == 'nv':
            line_lams  = [1238.821,1242.804]
            use_sys    = True
            keys       = ['nv1239','nv1243']

        else:
            sys.exit(' Did not find any setups for the line designated '+line)

        for ll, line_lam in enumerate(line_lams):
            ids                 = []
            # v v v   From uves.lineinfofromspec()   v v v
            fluxval             = []
            fluxerr             = []
            SNval               = []
            fluxval_Dlam        = []
            fluxstd_Dlam        = []
            fluxerr_Dlam        = []
            SNval_Dlam          = []
            fluxval_Dlam_max    = []
            SNval_Dlam_max      = []
            fluxval_Dlam_sum    = []
            SNval_Dlam_sum      = []
            # ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
            EW                  = []
            EW_Dlam             = []
            EW_Dlam_sum         = []

            if verbose: print(' - Looping over spectra for line = '+keys[ll])
            for ss, spec in enumerate(spectra):
                id       = spec.split('/')[-1].split('.fit')[0][-9:]
                specdat  = afits.open(spec)[1].data
                spec_lam = specdat['wave']
                spec_f   = specdat['flux']
                spec_err = specdat['fluxerror']
                spec_s2n = specdat['s2n']

                objid    = int(spec.split('_')[-1].split('-')[-1].split('.fit')[0])
                objent   = np.where(sourcecat['id'] == objid)[0]

                if use_sys:
                    try:
                        z_lam    = sourcecat['z_sys_AV17'][objent] # using systemic redshift
                    except:
                        z_lam    = sourcecat['z_sys_V18'][objent] # using systemic redshift
                else:
                    z_lam    = sourcecat['z_vac_red'][objent]  # using Lya redshiftfrom red peak

                line_wave  = (z_lam+1)*line_lam
                lineinfo   = uves.lineinfofromspec(line_wave,spec_lam,spec_f,spec_err,spec_s2n,
                                                   deltalam=deltalam,verbose=verbose)

                ids.append(id)

                fluxval.append(lineinfo[0])
                fluxerr.append(lineinfo[1])
                SNval.append(lineinfo[2])
                fluxval_Dlam.append(lineinfo[3])
                fluxstd_Dlam.append(lineinfo[4])
                fluxerr_Dlam.append(lineinfo[5])
                SNval_Dlam.append(lineinfo[6])
                fluxval_Dlam_max.append(lineinfo[7])
                SNval_Dlam_max.append(lineinfo[8])
                fluxval_Dlam_sum.append(lineinfo[9])
                SNval_Dlam_sum.append(lineinfo[10])

                # - - - - -  Estimate EW  - - - - -
                objent        = np.where(sourcecat['id'] == int(id))[0]
                beta          = sourcecat['beta'][objent][0]
                try:
                    bandswithLya  = uves.wavelength_in_bands( 1216 * (sourcecat['z_sys_AV17'][objent][0] + 1))
                except:
                    bandswithLya  = uves.wavelength_in_bands( 1216 * (sourcecat['z_sys_V18'][objent][0] + 1))
                bandswithline = uves.wavelength_in_bands( line_wave )

                f_cont        = []
                bands         = ['F606W','F775W','F814W','F125W']
                wave_refs     = [6034.0,7730.0,8140.2,12516.2]
                for bb, band in enumerate(bands):
                    if (band not in bandswithLya) & (band not in bandswithline):
                        if band == 'F125W':
                            f_ref  = sourcecat[ 'flux_wfc3_'+band.lower()[1:] ][objent][0] * 1e20
                        else:
                            f_ref  = sourcecat[ 'flux_acs_'+band.lower()[1:] ][objent][0] * 1e20
                        f_wave = uves.estimate_continuumlevel_viaBeta(line_wave, wave_refs[bb], f_ref, beta, verbose=False)
                        f_cont.append(f_wave)

                if (len(f_cont) > 0):
                    EW.append( fluxval[ss] / np.mean(np.asarray(f_cont)) )
                else:
                    EW.append( np.NaN )

                if (len(f_cont) > 0):
                    EW_Dlam.append( fluxval_Dlam[ss] / deltalam / np.mean(np.asarray(f_cont)) )
                else:
                    EW_Dlam.append( np.NaN )

                if (len(f_cont) > 0):
                    EW_Dlam_sum.append( fluxval_Dlam_sum[ss] / deltalam / np.mean(np.asarray(f_cont)) )
                else:
                    EW_Dlam_sum.append( np.NaN )

                # - - - - - - - - - - - - - - - - - -

            outputdic[keys[ll]] = ids, \
                                  fluxval, fluxerr, SNval, \
                                  fluxval_Dlam, fluxstd_Dlam, fluxerr_Dlam, SNval_Dlam, \
                                  fluxval_Dlam_max, SNval_Dlam_max, \
                                  fluxval_Dlam_sum, SNval_Dlam_sum, \
                                  EW, EW_Dlam, EW_Dlam_sum

    if printresults:
        for ss, spec in enumerate(spectra):
            id = spec.split('/')[-1].split('.fit')[0][-9:]
            print ' - - - - - - Object '+id+' (Dlam = lambda +/-'+str(outputdic['deltalam'])+'A)- - - - - -  '
            for key in outputdic.keys():
                if key is not 'deltalam':
                    print ' - '+key+' flux           = '+str('%.4f' % outputdic[key][1][ss])+' +/- '+\
                          str('%.4f' % outputdic[key][2][ss])
                    print ' - '+key+' S/N            = '+str('%.4f' % outputdic[key][3][ss])
                    print ' - '+key+' flux_Dlam      = '+str('%.4f' % outputdic[key][4][ss])+' +/- '+\
                          str('%.4f' % outputdic[key][5][ss])
                    print ' - '+key+' S/N_Dlam       = '+str('%.4f' % outputdic[key][7][ss])
                    print ' - '+key+' flux_Dlam_max  = '+str('%.4f' % outputdic[key][8][ss])
                    print ' - '+key+' S/N_Dlam_max   = '+str('%.4f' % outputdic[key][9][ss])
                    print ' - '+key+' flux_Dlam_sum  = '+str('%.4f' % outputdic[key][10][ss])
                    print ' - '+key+' S/N_Dlam_sum   = '+str('%.4f' % outputdic[key][11][ss])
                    print ' - '+key+' EW             = '+str('%.4f' % outputdic[key][12][ss])
                    print ' - '+key+' EW_Dlam        = '+str('%.4f' % outputdic[key][13][ss])
                    print ' - '+key+' EW_Dlam_sum    = '+str('%.4f' % outputdic[key][14][ss])

    return outputdic
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def estimate_continuumlevel_viaBeta(wave, wave_ref, f_ref, beta, verbose=True):
    """
    Estiamting the continuum level assuming a spectrum with a fixed beta extrapolating ot the provided wavelength

    --- INPUT ---
    wave          The wavelength at whihc the continuum is estimated
    wave_ref      Referece wavelength at whihc the flux is known
    f_ref         Flux at wave_ref
    beta          The conitnuum slope to use for estrapolation to wave. Will assum f ~ wave**beta

    --- EXAMPLE OF USE ---

    sourcecatdat = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data
    objent       = np.where(sourcecatdat['id'] == 102013086)[0]
    wave         = 1551 * (sourcecatdat['redshift'][objent][0] + 1)
    beta         = sourcecatdat['beta'][objent][0]
    bandswithLya = uves.wavelength_in_bands( 1216 * (sourcecatdat['redshift'][objent][0] + 1))

    wave_ref     = 8140.2
    f_ref        = sourcecatdat['flux_acs_814w'][objent][0]
    f_wave = uves.estimate_continuumlevel_viaBeta(wave, wave_ref, f_ref, beta)

    wave_ref     = 7730.0
    f_ref        = sourcecatdat['flux_acs_775w'][objent][0]
    f_wave = uves.estimate_continuumlevel_viaBeta(wave, wave_ref, f_ref, beta)

    wave_ref     = 6034.0
    f_ref        = sourcecatdat['flux_acs_606w'][objent][0]
    f_wave = uves.estimate_continuumlevel_viaBeta(wave, wave_ref, f_ref, beta)


    """
    if verbose: print(' - Estimating flux at wavelength '+str(wave)+' using:')
    if verbose: print('   reference wave = '+str(wave_ref))
    if verbose: print('   reference flux = '+str(f_ref))
    if verbose: print('   beta           = '+str(beta))
    if verbose: print('   ')

    f_wave = f_ref * (wave / wave_ref)**beta
    if verbose: print('   f_'+str(int(np.round(wave)))+'         = '+str(f_wave)+'\n')

    return f_wave
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_limits(sourcecatalog, namebase, limits_dictionary, colorcode=True, colortype='redshift', zoom = False,
                ignoreSNlt3=False, showids=False, verbose=True):
    """
    Plotting the output from uves.estimate_limits()

    """
    sourcedat = afits.open(sourcecatalog)[1].data

    for key in limits_dictionary.keys():
    #for key in ['lya']:
        if key == 'deltalam':
            continue

        ids, \
        fluxval, fluxerr, SNval, \
        fluxval_Dlam, fluxstd_Dlam, fluxerr_Dlam, SNval_Dlam, \
        fluxval_Dlam_max, SNval_Dlam_max, \
        fluxval_Dlam_sum, SNval_Dlam_sum, \
        EW, EW_Dlam, EW_Dlam_sum = limits_dictionary[key]

        # - - - - build vectors from source catalog using IDs - - - -
        z_sys      = []
        z_lya      = []
        EW_lya     = []
        EW_lya_err = []
        beta       = []

        for ii,id in enumerate(ids):
            objent = np.where(sourcedat['id'] == int(id))[0]
            try:
                z_sys.append(sourcedat['z_sys_AV17'][objent][0])
            except:
                z_sys.append(sourcedat['z_sys_V18'][objent][0])
            z_lya.append(sourcedat['z_vac_red'][objent][0])
            EW_lya.append(sourcedat['EW_0'][objent][0])
            EW_lya_err.append(sourcedat['EW_0_err'][objent][0])
            beta.append(sourcedat['beta'][objent][0])

        # - - - - - - - - - - - - - - - - - - - - - - PLOTTING - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print(' - Setting up and generating plot')
        plotname = namebase+'_'+key+'_EWlyaVSEW'+key+'.pdf'
        if zoom: plotname = plotname.replace('.pdf','_zoom.pdf')
        if ignoreSNlt3: plotname = plotname.replace('.pdf','_noSNlt3.pdf')
        fig = plt.figure(figsize=(7, 5))
        fig.subplots_adjust(wspace=0.1, hspace=0.1,left=0.2, right=0.97, bottom=0.10, top=0.9)
        Fsize    = 10
        lthick   = 2
        marksize = 4
        plt.rc('text', usetex=True)
        plt.rc('font', family='serif',size=Fsize)
        plt.rc('xtick', labelsize=Fsize)
        plt.rc('ytick', labelsize=Fsize)
        plt.clf()
        plt.ioff()
        #plt.title(inforstr[:-2],fontsize=Fsize)

        xvalues = np.asarray(EW_lya)
        #yvalues = np.asarray(EW)
        #yvalues = np.asarray(EW_Dlam)
        yvalues = np.asarray(EW_Dlam_sum)
        xerr    = [None]*len(xvalues)
        yerr    = [None]*len(xvalues)

        if colorcode:
            cmap    = plt.cm.get_cmap('rainbow')

            if colortype == 'redshift':
                cmin    = 2.8
                cmax    = 6.2
            else:
                sys.exit(' Color type '+colortype+' not enabled ')

            colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
            cmaparr = np.linspace(cmin, cmax, cmax-cmin)
            m       = plt.cm.ScalarMappable(cmap=cmap)
            m.set_array(cmaparr)
            cb      = plt.colorbar(m)

            if colortype == 'redshift':
                cb.set_label('redshift')

            for ii,id in enumerate(ids):

                if colortype == 'redshift':
                    objcol = cmap(colnorm(z_sys[ii]))

                if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
                    marker = 'o'
                    ms     = marksize
                    mec    = objcol
                    mfc    = objcol

                    if SNval_Dlam_sum[ii] < 3.0:
                        mfc    = 'None'
                        if ignoreSNlt3: continue

                    if (beta[ii] == -2.0) & (SNval_Dlam_sum[ii] > 3.0):
                        #marker = r'$\downarrow$'
                        marker = r'$\nearrow$'
                        ms     = ms*2

                        plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr[ii],yerr=yerr[ii],
                                     marker=marker,lw=0, markersize=ms,alpha=1.0,
                                     markerfacecolor=mfc,ecolor=objcol,
                                     markeredgecolor=mec,zorder=10)
                    else:
                        if SNval_Dlam_sum[ii] > 0.0:
                            plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr[ii],yerr=yerr[ii],
                                         marker=marker,lw=0, markersize=ms,alpha=1.0,
                                         markerfacecolor=mfc,ecolor=objcol,
                                         markeredgecolor=mec,zorder=10)
                        else:
                            pass # not plotting S/N < 0 points

        else:
            plt.errorbar(xvalues,yvalues,xerr=xerr,yerr=yerr,
                         marker='o',lw=0, markersize=marksize,alpha=0.5,
                         markerfacecolor='gray',ecolor='k',
                         markeredgecolor='k',zorder=10)

        #marking AGN:
        AGN     = ['104014050','115003085','214002011']
        AGNcand = ['123048186','123501191','121033078']
        for ii,id in enumerate(ids):
            if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGN):
                plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
                                 marker='*',lw=0, markersize=marksize*2,alpha=1.0,
                                 markerfacecolor='None',ecolor=objcol,
                                 markeredgecolor='black',zorder=20)

            if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGNcand):
                plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
                                 marker='D',lw=0, markersize=marksize,alpha=1.0,
                                 markerfacecolor='None',ecolor=objcol,
                                 markeredgecolor='black',zorder=20)

        if showids:
            for ii,id in enumerate(ids):
                if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
                    plt.text(xvalues[ii],yvalues[ii],id,color='black',fontsize=Fsize/2.)

        if key.lower() == 'lya':
            plt.plot([-5000,5000],[-5000,5000],'--',color='gray',lw=lthick,zorder=5)
            plt.xscale('log')
            plt.yscale('log')

        plt.xlabel(' EW( Ly$\\alpha$ ) ')
        plt.ylabel(' EW( '+key+' )')

        #--------- RANGES ---------
        goodent = np.where(np.isfinite(xvalues) & np.isfinite(yvalues))
        xmin = np.min(xvalues[goodent])
        xmax = np.max(xvalues[goodent])
        dx   = xmax-xmin

        ymin = np.min(yvalues[goodent])
        ymax = np.max(yvalues[goodent])
        dy   = ymax-ymin

        plt.xlim([xmin-dx*0.05,xmax+dx*0.05])
        plt.ylim([ymin-dy*0.05,ymax+dy*0.05])
        if zoom:
            plt.xlim([0,400])
            plt.ylim([0,30])

        # if logx:
        #     plt.xscale('log')
        # if logy:
        #     plt.yscale('log')

        #--------- LEGEND ---------
        plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='k',ecolor='k',markeredgecolor='black',zorder=1,label='MW LAE (S/N\_'+key+' $>$ 3)')
        plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='None',ecolor='k',markeredgecolor='black',zorder=1,label='MW LAE (S/N\_'+key+' $<$ 3)')
        plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker=r'$\nearrow$',lw=0, markersize=marksize*2,alpha=1.0,
                     markerfacecolor='None',ecolor='k',markeredgecolor='black',zorder=1,
                     label='MW LAE (HST non-det. lower limit)')


        plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='*',lw=0, markersize=marksize*2,alpha=1.0,
                     markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN')
        plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='D',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN candidate')

        leg = plt.legend(fancybox=True, loc='upper center',prop={'size':Fsize/1.7},ncol=3,numpoints=1,
                         bbox_to_anchor=(0.5, 1.1),)  # add the legend
        leg.get_frame().set_alpha(0.7)
        #--------------------------

        if verbose: print('   Saving plot to',plotname)
        plt.savefig(plotname)
        plt.clf()
        plt.close('all')


        # - - - - - - - - - - - - - - - - - - - - - - PLOTTING - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print(' - Setting up and generating plot')
        plotname = namebase+'_'+key+'_fluxVSs2n.pdf'
        if zoom: plotname = plotname.replace('.pdf','_zoom.pdf')
        fig = plt.figure(figsize=(7, 5))
        fig.subplots_adjust(wspace=0.1, hspace=0.1,left=0.2, right=0.97, bottom=0.10, top=0.9)
        Fsize    = 10
        lthick   = 2
        marksize = 4
        plt.rc('text', usetex=True)
        plt.rc('font', family='serif',size=Fsize)
        plt.rc('xtick', labelsize=Fsize)
        plt.rc('ytick', labelsize=Fsize)
        plt.clf()
        plt.ioff()
        #plt.title(inforstr[:-2],fontsize=Fsize)

        xvalues = np.asarray(SNval_Dlam_sum)
        yvalues = np.asarray(fluxval)
        xerr    = None
        yerr    = np.asarray(fluxerr)

        if colorcode:
            cmap    = plt.cm.get_cmap('rainbow')

            if colortype == 'redshift':
                cmin    = 2.8
                cmax    = 6.2
            else:
                sys.exit(' Color type '+colortype+' not enabled ')

            colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
            cmaparr = np.linspace(cmin, cmax, cmax-cmin)
            m       = plt.cm.ScalarMappable(cmap=cmap)
            m.set_array(cmaparr)
            cb      = plt.colorbar(m)

            if colortype == 'redshift':
                cb.set_label('redshift')

            for ii,id in enumerate(ids):

                if colortype == 'redshift':
                    objcol = cmap(colnorm(z_sys[ii]))

                if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
                    plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr,yerr=yerr[ii],
                                 marker='o',lw=0, markersize=marksize,alpha=1.0,
                                 markerfacecolor=objcol,ecolor=objcol,
                                 markeredgecolor='None',zorder=10)
        else:
            plt.errorbar(xvalues,yvalues,xerr=xerr,yerr=yerr,
                         marker='o',lw=0, markersize=marksize,alpha=0.5,
                         markerfacecolor='gray',ecolor='k',
                         markeredgecolor='k',zorder=10)

        #marking AGN:
        AGN     = ['104014050','115003085','214002011']
        AGNcand = ['123048186','123501191','121033078']
        for ii,id in enumerate(ids):
            if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGN):
                plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
                                 marker='*',lw=0, markersize=marksize*2,alpha=1.0,
                                 markerfacecolor='None',ecolor=objcol,
                                 markeredgecolor='black',zorder=20)

            if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGNcand):
                plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
                                 marker='D',lw=0, markersize=marksize,alpha=1.0,
                                 markerfacecolor='None',ecolor=objcol,
                                 markeredgecolor='black',zorder=20)


        if showids:
            for ii,id in enumerate(ids):
                if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
                    plt.text(xvalues[ii],yvalues[ii],id,color='black',fontsize=Fsize/2.)

        plt.plot([3,3],[-5000,5000],'--',color='gray',lw=lthick,zorder=5)

        plt.xlabel('S/N of MUSE-Wide LAE 1D spectra at location of '+key)
        plt.ylabel('Flux [1e-20cgs] of MUSE-Wide LAE 1D spectra at location of '+key)


        #--------- RANGES ---------
        xmin = np.min(xvalues[np.isfinite(xvalues)])
        xmax = np.max(xvalues[np.isfinite(xvalues)])
        dx   = xmax-xmin

        ymin = np.min(yvalues[np.isfinite(yvalues)])
        ymax = np.max(yvalues[np.isfinite(yvalues)])
        dy   = ymax-ymin

        plt.xlim([xmin-dx*0.05,xmax+dx*0.05])
        plt.ylim([ymin-dy*0.05,ymax+dy*0.05])

        if zoom:
            plt.xlim([-10,10])
            plt.ylim([-100,100])
            if key.lower() == 'lya':
                plt.xlim([0,10])
                plt.ylim([0,300])

        # if logx:
        #     plt.xscale('log')
        # if logy:
        #     plt.yscale('log')

        #--------- LEGEND ---------
        plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='k',ecolor='k',markeredgecolor='black',zorder=1,label='MUSE-Wide LAE')
        plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='*',lw=0, markersize=marksize*2,alpha=1.0,
                     markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN')
        plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='D',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN candidate')

        leg = plt.legend(fancybox=True, loc='upper center',prop={'size':Fsize/1.0},ncol=5,numpoints=1,
                         bbox_to_anchor=(0.5, 1.1),)  # add the legend
        leg.get_frame().set_alpha(0.7)
        #--------------------------

        if verbose: print('   Saving plot to '+plotname)
        plt.savefig(plotname)
        plt.clf()
        plt.close('all')

        # # - - - - - - - - - - - - - - - - - - - - - - PLOTTING - - - - - - - - - - - - - - - - - - - - - -
        # if verbose: print ' - Setting up and generating plot'
        # plotname = namebase+'_'+key+'_LyaEWVSflux.pdf'
        # fig = plt.figure(figsize=(7, 5))
        # fig.subplots_adjust(wspace=0.1, hspace=0.1,left=0.2, right=0.97, bottom=0.10, top=0.9)
        # Fsize    = 10
        # lthick   = 2
        # marksize = 4
        # plt.rc('text', usetex=True)
        # plt.rc('font', family='serif',size=Fsize)
        # plt.rc('xtick', labelsize=Fsize)
        # plt.rc('ytick', labelsize=Fsize)
        # plt.clf()
        # plt.ioff()
        # #plt.title(inforstr[:-2],fontsize=Fsize)
        #
        # xvalues = np.asarray(LyaEW)
        # yvalues = np.asarray(fluxval)
        # xerr    = None
        # yerr    = np.asarray(fluxerr)
        #
        # if colorcode:
        #     cmap    = plt.cm.get_cmap('rainbow')
        #
        #     if colortype == 'redshift':
        #         cmin    = 2.8
        #         cmax    = 6.2
        #     else:
        #         sys.exit(' Color type '+colortype+' not enabled ')
        #
        #     colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
        #     cmaparr = np.linspace(cmin, cmax, cmax-cmin)
        #     m       = plt.cm.ScalarMappable(cmap=cmap)
        #     m.set_array(cmaparr)
        #     cb      = plt.colorbar(m)
        #
        #     if colortype == 'redshift':
        #         cb.set_label('redshift')
        #
        #     for ii,id in enumerate(ids):
        #
        #         if colortype == 'redshift':
        #             objcol = cmap(colnorm(z_sys[ii]))
        #
        #         if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
        #             plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr,yerr=yerr[ii],
        #                          marker='o',lw=0, markersize=marksize,alpha=1.0,
        #                          markerfacecolor=objcol,ecolor=objcol,
        #                          markeredgecolor='None',zorder=10)
        # else:
        #     plt.errorbar(xvalues,yvalues,xerr=xerr,yerr=yerr,
        #                  marker='o',lw=0, markersize=marksize,alpha=0.5,
        #                  markerfacecolor='gray',ecolor='k',
        #                  markeredgecolor='k',zorder=10)
        #
        # #marking AGN:
        # AGN     = ['104014050','115003085','214002011']
        # AGNcand = ['123048186','123501191','121033078']
        # for ii,id in enumerate(ids):
        #     if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGN):
        #         plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
        #                          marker='*',lw=0, markersize=marksize*2,alpha=1.0,
        #                          markerfacecolor='None',ecolor=objcol,
        #                          markeredgecolor='black',zorder=20)
        #
        #     if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGNcand):
        #         plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
        #                          marker='D',lw=0, markersize=marksize,alpha=1.0,
        #                          markerfacecolor='None',ecolor=objcol,
        #                          markeredgecolor='black',zorder=20)
        #
        #
        # if showids:
        #     for ii,id in enumerate(ids):
        #         if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
        #             plt.text(xvalues[ii],yvalues[ii],id,color='black',fontsize=Fsize/2.,zorder=30)
        #
        # plt.plot([3,3],[-5000,5000],'--',color='gray',lw=lthick,zorder=5)
        #
        # plt.xlabel('S/N of MUSE-Wide LAE 1D spectra at location of '+key)
        # plt.ylabel('Flux [1e-20cgs] of MUSE-Wide LAE 1D spectra at location of '+key)
        #
        #
        # #--------- RANGES ---------
        # xmin = np.min(xvalues[np.isfinite(xvalues)])
        # xmax = np.max(xvalues[np.isfinite(xvalues)])
        # dx   = xmax-xmin
        #
        # ymin = np.min(yvalues[np.isfinite(yvalues)])
        # ymax = np.max(yvalues[np.isfinite(yvalues)])
        # dy   = ymax-ymin
        #
        # plt.xlim([xmin-dx*0.05,xmax+dx*0.05])
        # plt.ylim([ymin-dy*0.05,ymax+dy*0.05])
        #
        # # if logx:
        # #     plt.xscale('log')
        # # if logy:
        # #     plt.yscale('log')
        #
        # #--------- LEGEND ---------
        # plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
        #              markerfacecolor='k',ecolor='k',markeredgecolor='black',zorder=1,label='MUSE-Wide LAE')
        # plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='*',lw=0, markersize=marksize*2,alpha=1.0,
        #              markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN')
        # plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='D',lw=0, markersize=marksize,alpha=1.0,
        #              markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN candidate')
        #
        # leg = plt.legend(fancybox=True, loc='upper center',prop={'size':Fsize/1.0},ncol=5,numpoints=1,
        #                  bbox_to_anchor=(0.5, 1.1),)  # add the legend
        # leg.get_frame().set_alpha(0.7)
        # #--------------------------
        #
        # if verbose: print '   Saving plot to',plotname
        # plt.savefig(plotname)
        # plt.clf()
        # plt.close('all')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def lineinfofromspec(wavelength,spec_lam,spec_flux,spec_fluxerr,spec_s2n,deltalam=10,verbose=True):
    """
    return info at given wavelength based on spectrum

    """
    if (wavelength > np.min(spec_lam)) & (wavelength < np.max(spec_lam)):

        wavediff     = np.abs(spec_lam-wavelength)
        waveent      = np.where(wavediff == np.min(wavediff))

        if len(waveent) > 1:
            if verbose: print(' - multiple matches for '+str(wavelength)+'; returning info for the first match: '+
                              str(spec_lam[waveent[0]]))
        ent      = waveent[0]
        ent_dlam = np.where( (spec_lam > (spec_lam[ent]-deltalam)) & (spec_lam < (spec_lam[ent]+deltalam)) )

        fluxval       = spec_flux[ent]
        fluxerr       = spec_fluxerr[ent]
        SNval         = spec_s2n[ent]

        fluxval_Dlam  = np.mean(spec_flux[ent_dlam])
        fluxstd_Dlam  = np.std(spec_fluxerr[ent_dlam])
        fluxerr_Dlam  = np.mean(spec_fluxerr[ent_dlam])
        SNval_Dlam    = np.mean(spec_s2n[ent_dlam])

        fluxval_Dlam_max  = np.max(spec_flux[ent_dlam])
        SNval_Dlam_max    = np.max(spec_s2n[ent_dlam])

        fluxval_Dlam_sum  = np.sum(spec_flux[ent_dlam])
        SNval_Dlam_sum    = fluxval_Dlam_sum/fluxerr_Dlam

    else:
        if verbose: print(' - '+str(wavelength)+' not within spectral range; returning NaNs')
        fluxval       = [np.NaN]
        fluxerr       = [np.NaN]
        SNval         = [np.NaN]

        fluxval_Dlam  = np.NaN
        fluxstd_Dlam  = np.NaN
        fluxerr_Dlam  = np.NaN
        SNval_Dlam    = np.NaN

        fluxval_Dlam_max  = np.NaN
        SNval_Dlam_max    = np.NaN

        fluxval_Dlam_sum  = np.NaN
        SNval_Dlam_sum    = np.NaN

    return fluxval[0], fluxerr[0], SNval[0], \
           fluxval_Dlam, fluxstd_Dlam, fluxerr_Dlam, SNval_Dlam, \
           fluxval_Dlam_max, SNval_Dlam_max, \
           fluxval_Dlam_sum, SNval_Dlam_sum

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_1DspecOverview_forsample(MUSEidlist,outputdir='./',yrangefullflux=[-400,1200],yrangefullSN=[-3,30],
                                  specdir  = '/Volumes/DATABCKUP1/TDOSEextractions/TDOSEext_171019/tdose_spectra/',
                                  tol3DHSTmatch=0.5,showPSFspec=True,clobber=False,verbose=True):
    """
    Wrapper to run mwp.plot_1DspecOverview() for a sample of objects collecting the relevant spectra

    --- INPUT ---
    MUSEidlist      List of MUSE ids of objects to plot
    outputdir       Directory to save figure to
    yrangefullflux  Yrange of full-spectra overview in flux figure
    yrangefullSN    Yrange of full-spectra overview in S/N figure
    specdir         Directory containing TDOSE spectra to plot
    tol3DHSTmatch   Tolerance of match to 3D-HST catalog (and spectra)
    showPSFspec     Plot the spectra extracted via PSF weighting (TU's extraction)
    clobber         Overwrite existing files?
    verbose         Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    MUSEidlist  = [103006046,119031070,208006149]
    MUSEidlist  = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data['id']

    outputdir   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/171108_1DspecOverview/'
    plottedspec = uves.plot_1DspecOverview_forsample(MUSEidlist,outputdir=outputdir)

    """
    Nobj     = len(MUSEidlist)
    if verbose: print ' - Plotting spectra of '+str(Nobj)+' objects in "MUSEidlist"'
    LAEinfo        = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data
    spectraplottet = collections.OrderedDict()

    if type(specdir) == str:
        specdir = [specdir]

    for oo, objID in enumerate(MUSEidlist):
        idstr        = str(objID)
        idstr_short  = str(objID)[:3]+str(objID)[-5:]

        outputfigure = outputdir+'id'+idstr+'_1DspecOverview.pdf'

        objent = np.where(LAEinfo['id'] == objID)[0]
        if len(objent) == 0:
            sys.exit(' object ID '+str(objID)+' not found in LAEinfo file ')

        sep3DHST = LAEinfo['sep_skelton'][objent]

        if (sep3DHST < tol3DHSTmatch) & (sep3DHST != 0.0):
            id3DHST = LAEinfo['id_skelton'][objent]
        else:
            id3DHST  = -99

        # - - - - - - - TDOSE extractions - - - - - - -
        TDOSEspecs = []
        TDOSElabel = []
        for sdir in specdir:
            TDOSEspec    = glob.glob(sdir+'tdose_spectrum_candels*'+idstr+'*.fits')+\
                           glob.glob(sdir+'tdose_spectrum_candels*'+idstr_short+'*.fits')
            if len(TDOSEspec) == 0:
                if verbose: print('----- No TDOSE spectrum found for '+str(objID)+' in \n      '+
                                  sdir+'\n      -> moving on to next object ----- ')
                continue

            labelstrings = ['TDOSE '+specname.split('/')[-1].split('_')[3] for specname in TDOSEspec]
            TDOSElabel   = TDOSElabel + labelstrings
            TDOSEspecs   = TDOSEspecs + TDOSEspec

        TDOSEwave    = ['wave']*len(TDOSEspecs)
        TDOSEflux    = ['flux']*len(TDOSEspecs)
        TDOSEferr    = ['fluxerror']*len(TDOSEspecs)
        TDOSEsky     = [None]*len(TDOSEspecs)
        TDOSEskyW    = [None]*len(TDOSEspecs)
        TDOSEskyF    = [None]*len(TDOSEspecs)
        TDOSEsky[0]  = '/Users/kschmidt/work/MUSE/skyspectra/SKY_SPECTRUM_'+LAEinfo['pointing'][objent][0]+'_av.fits'
        TDOSEskyW[0] = 'lambda'
        TDOSEskyF[0] = 'data'

        # - - - - - - - PSF weighted extraction - - - - - - -
        if showPSFspec:
            PSFextdir = '/Users/kschmidt/work/MUSE/spectra1D/Arche170127/spectra/'
            PSFspec   = glob.glob(PSFextdir+'spectrum_'+idstr+'.fits')+\
                        glob.glob(PSFextdir+'spectrum_'+idstr_short+'.fits')
            if len(PSFspec) > 1:
                sys.exit(' More than one PSF extraction spectrum found for '+idstr+' in '+PSFextdir)
            elif len(PSFspec) == 1:
                PSFlabel = ['PSFext']
                PSFwave  = ['WAVE_AIR']
                PSFflux  = ['FLUX']
                PSFferr  = ['FLUXERR']
                PSFsky   = [None]
                PSFskyW  = [None]
                PSFskyF  = [None]
            else:
                PSFlabel = []
                PSFwave  = []
                PSFflux  = []
                PSFferr  = []
                PSFsky   = []
                PSFskyW  = []
                PSFskyF  = []
        else:
            PSFspec  = []
            PSFlabel = []
            PSFwave  = []
            PSFflux  = []
            PSFferr  = []
            PSFsky   = []
            PSFskyW  = []
            PSFskyF  = []

        # - - - - - - - 3D-HST spectra - - - - - - -
        if id3DHST != -99:
            if idstr.startswith('1'):
                specdic = uves.get_3DHSTspecname([id3DHST[0]],field='goodss',spec1D=True,verbose=verbose)
            elif idstr.startswith('2'):
                specdic = uves.get_3DHSTspecname([id3DHST[0]],field='cosmos',spec1D=True,verbose=verbose)
            else:
                sys.exit(' Invalid MUSE id - does not start with "1" or "2"')

            grismspec  = specdic[str(int(id3DHST[0]))]

            if len(grismspec) > 0:
                grismlabel   = [gs.split('/')[-1].split('.')[0].replace('_','\_') for gs in grismspec]
                grismwave    = ['wave']*len(grismspec)
                grismflux    = ['flux']*len(grismspec)
                grismferr    = ['error']*len(grismspec)
                grismsky     = [None]*len(grismspec)
                grismskyW    = [None]*len(grismspec)
                grismskyF    = [None]*len(grismspec)
                grismsky[0]  = '/Users/kschmidt/work/MUSE/skytable.fits'
                grismskyW[0] = 'lam'
                grismskyF[0] = 'flux'

            else:
                grismlabel = []
                grismwave  = []
                grismflux  = []
                grismferr  = []
                grismsky   = []
                grismskyW  = []
                grismskyF  = []
        else:
            grismspec  = []
            grismlabel = []
            grismwave  = []
            grismflux  = []
            grismferr  = []
            grismsky   = []
            grismskyW  = []
            grismskyF  = []

        # - - - - - - - Assemble input for plot - - - - - - -
        spectra      = TDOSEspecs + PSFspec  + grismspec
        labels       = TDOSElabel + PSFlabel + grismlabel
        wavecols     = TDOSEwave  + PSFwave  + grismwave
        fluxcols     = TDOSEflux  + PSFflux  + grismflux
        fluxerrcols  = TDOSEferr  + PSFferr  + grismferr
        skyspectra   = TDOSEsky   + PSFsky   + grismsky
        wavecols_sky = TDOSEskyW  + PSFskyW  + grismskyW
        fluxcols_sky = TDOSEskyF  + PSFskyF  + grismskyF

        zLya         = LAEinfo['redshift'][objent][0]
        try:
            zsys         = LAEinfo['z_sys_AV17'][objent][0]
            voffset      = LAEinfo['red_peak_shift_AV17_kms'][objent][0]
        except:
            zsys         = LAEinfo['z_sys_V18'][objent][0]
            voffset      = LAEinfo['red_peak_shift_V18_kms'][objent][0]

        spectraplottet[idstr] = spectra
        if verbose:
            idno    = oo+1
            infostr = '----- Plot '+str(objID)+' at z = '+str("%.4f" % zLya)+' indicating voff = '+\
                      str("%.4f" % voffset)+'  ('+str(idno)+'/'+str(Nobj)+') -----                           '

            if (clobber == False) & (len(glob.glob(outputfigure.replace('.pdf','*.pdf'))) != 0):
                infostr = infostr.replace(') -----              ',
                                          ') -----> skip (clobber=False)')

                print(infostr)
            else:
                print(infostr)

                for plotSN in [True,False]:
                    if plotSN:
                        yrangefull = yrangefullSN
                    else:
                        yrangefull = yrangefullflux

                    mwp.plot_1DspecOverview(spectra, labels, wavecols, fluxcols, fluxerrcols, zLya, voffset=voffset,
                                            skyspectra=skyspectra, wavecols_sky=wavecols_sky, fluxcols_sky=fluxcols_sky,
                                            outputfigure=outputfigure, yrangefull=yrangefull, plotSN=plotSN,
                                            verbose=verbose)

    if verbose: print ' - Done...'
    return spectraplottet
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_3DHSTspecname(ids,spec1D=False,field='goodss',verbose=True):
    """

    Return absolute paths for existing 3D-HST 2D fits files. If

    --- INPUT ---
    ids           list of 3D-HST ids to return list of spectr for
    spec1D        if true, paths of the 1D spectra will be returned

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    spectradic = uves.get_3DHSTspecname([22684,21926,9033,7609])

    """
    path3DHST     = '/Volumes/DATABCKUP1/3DHST/'+field.lower()+'_WFC3_V4.1.5/'
    cat_spec      = path3DHST+field.lower()+'_3dhst_v4.1.5_catalogs/'+\
                    field.lower()+'_3dhst.v4.1.5.duplicates_2d.dat'    # list of (duplicate) spectra for each ID

    if field.lower() == 'goodss':
        dat_spec      = np.genfromtxt(cat_spec,comments='#',
                                      names=['id','s1','s2','s3','s4','s5','s6','s7'],
                                      dtype='f,40a,40a,40a,40a,40a,40a,40a')
    elif field.lower() == 'cosmos':
        dat_spec      = np.genfromtxt(cat_spec,comments='#',
                                      names=['id','s1','s2','s3','s4'],
                                      dtype='f,40a,40a,40a,40a')

    else:
        sys.exit(' No 3D-HST directory setup available for the field "'+field+'"')

    infodic = collections.OrderedDict()

    for id in ids:
        objent   = np.where(dat_spec['id'] == float(id))[0][0]
        namelist = [val for val in dat_spec[objent]][1:]
        filelist = []

        for name in namelist:
            if name != '00000':
                if spec1D:
                    namestr  = '/1D/FITS/'+name
                    filename = glob.glob(path3DHST+'/'+name[:-11]+namestr+'.1D.fits')
                    if os.path.isfile(filename[0]):
                        filelist.append(os.path.abspath(filename[0]))
                else:
                    # look for regular spectrum
                    namestr  = '/2D/FITS/'+name
                    filename = glob.glob(path3DHST+'/'+name[:-11]+namestr+'.2D.fits')
                    if os.path.isfile(filename[0]):
                        filelist.append(os.path.abspath(filename[0]))

                    # look for BIG spectrum
                    namestr  = '/BIG/2D/'+name.replace('G141','G141-big')
                    filename = glob.glob(path3DHST+'/'+name[:-11]+namestr+'.2D.fits')
                    if os.path.isfile(filename[0]):
                        filelist.append(os.path.abspath(filename[0]))

        infodic[str(int(id))] = filelist

    return infodic
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def copy_singleobjsourcecats(outputdir='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats_singleobjects/',
                             verbose=True):
    """

    --- EXAMPLE OF USE ---
    uves.copy_singleobjsourcecats()

    """
    modeldir      = '/Volumes/DATABCKUP1/TDOSEextractions/MW_LAEs_JKgalfitmodels/'

    sourcecats = ['model_acs_814w_candels-cdfs-01_cut_v1.0_id101005016_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-01_cut_v1.0_id101023043_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-01_cut_v1.0_id101024044_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-02_cut_v1.0_id102015088_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-03_cut_v1.0_id103006046_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-03_cut_v1.0_id103050126_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-04_cut_v1.0_id104024069_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-06_cut_v1.0_id106014046_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-06_cut_v1.0_id106035088_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-11_cut_v1.0_id111013028_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-22_cut_v1.0_id122002034_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-22_cut_v1.0_id122002035_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-23_cut_v1.0_id123016117_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-25_cut_v1.0_id125049122_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-28_cut_v1.0_id128038236_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-31_cut_v1.0_id131016105_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-31_cut_v1.0_id131016106_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-35_cut_v1.0_id135010177_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-35_cut_v1.0_id135010178_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-41_cut_v1.0_id141003075_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-41_cut_v1.0_id141036146_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-43_cut_v1.0_id143033113_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-44_cut_v1.0_id144008046_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-45_cut_v1.0_id145022065_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-45_cut_v1.0_id145034089_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-45_cut_v1.0_id145065132_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-46_cut_v1.0_id146053338_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-46_cut_v1.0_id146069355_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-01_cut_v1.0_id201073224_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-02_cut_v1.0_id202013030_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-02_cut_v1.0_id202044085_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-03_cut_v1.0_id203007099_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-04_cut_v1.0_id204053120_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-06_cut_v1.0_id206014089_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-07_cut_v1.0_id207022169_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-09_cut_v1.0_id209006108_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-11_cut_v1.0_id211015198_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-12_cut_v1.0_id212029067_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-13_cut_v1.0_id213022109_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-15_cut_v1.0_id215016042_cutout2p0x2p0arcsec_sourcecatalog.*']

    for scat in sourcecats:
        cpout = commands.getoutput('cp '+modeldir+scat+' '+outputdir)
        if cpout != '':
            print cpout

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_overviewdocument(outdir,outfile,clobber=False,
                         specoverview='/Volumes/DATABCKUP1/TDOSEextractions/171201_TDOSEextraction/overviewplots/idIIII*.pdf',
                         FoVoverview='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FoVoverviews/FoVoverview_IIII.png'):
    """
    Generate LaTeX document summarizing objects (using figures and text) to ease inspections

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    outdir  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/overviewdocument/'
    outfile = 'overviewdocument.tex'
    uves.gen_overviewdocument(outdir,outfile)

    """

    objdata   = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data
    ids       = objdata['id']
    ras       = objdata['ra']
    decs      = objdata['dec']
    redshifts = objdata['redshift']
    pointings = objdata['pointing']

    # - - - - - Generate main document - - - - -
    if os.path.isfile(outdir+outfile) & (clobber==False):
        sys.exit('Document '+outdir+outfile+' exists and clobber = False')

    fmain = open(outdir+outfile,'w')
    fmain.write("""
\documentclass[a4paper,10pt]{article}
\usepackage[latin1]{inputenc}
\usepackage{float}
\usepackage[pdftex]{graphicx}
\usepackage[left=1cm,right=1cm,top=1cm,bottom=2cm]{geometry}
%===========================================================================
\\begin{document}
%===========================================================================
""")

    for ii, id in enumerate(ids[:]):
        pagename = 'page'+str(id)+'.tex'

        FoVfig   = FoVoverview.replace('IIII',str(id))
        specfigs = glob.glob(specoverview.replace('IIII',str(id)))
        fluxfig  = specfigs[0]
        snfig    = specfigs[1]

        fpage = open(outdir+pagename,'w')
        fpage.write("""
\section*{%s (%s)}
\small
\\begin{verbatim}
ID(MUSE-Wide) = %s     z  = %s     (ra,dec) = (%s,%s)
ID(Guo)       = %s     dr = %s     (ra,dec) = (%s,%s)
ID(Skelton)   = %s     dr = %s     (ra,dec) = (%s,%s)
\end{verbatim}
\\normalsize

\\begin{figure}[h]
\\begin{center}
\includegraphics[width=0.45\\textwidth]{%s}
\caption{Candels F814W 5$\\times$5 arcsec field of view. Circles have r=0.5arcsec. Red circles mark MUSE-Wide LAEs. White circles mark MUSE-Wide non-Ly$\\alpha$ EL sources (low-$z$).}
\label{fig:FoV%s}
\end{center}
\end{figure}

\\begin{figure*}
\\begin{center}
\includegraphics[width=0.9\\textwidth]{%s}
\includegraphics[width=0.9\\textwidth]{%s}
\caption{Spectral overview (incl. crossmatch to 3D-HST) with zoom-ins on rest-frame UV line regions. V-offset (gray region) estimated based on Verhamme+18 relations with peak seperation or FWHM.}
\label{fig:spec%s}
\end{center}
\end{figure*}

        """ % (id,pointings[ii],
               str("%11s" % int(id)),str("%.4f" % redshifts[ii]),ras[ii],decs[ii],
               str("%11s" % int(objdata['id_guo'][ii])),str("%.4f" % objdata['sep_guo'][ii]),objdata['ra_guo'][ii],objdata['dec_guo'][ii],
               str("%11s" % int(objdata['id_skelton'][ii])),str("%.4f" % objdata['sep_skelton'][ii]),objdata['ra_skelton'][ii],objdata['dec_skelton'][ii],
               FoVfig,id,fluxfig,snfig,id))
        fpage.close()

        fmain.write('\input{./'+pagename+'}\\newpage\n')

    fmain.write("""
%===========================================================================
\end{document}""")
    fmain.close()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_NEOGALmodels(limits_dictionary,plotnumbers=[99],cutSFmodels=False,smallsyms=False,verbose=True):
    """
    Commands to generate plots of the NEOGAL photo-ionization models with MUSE-Wide included

    --- EXAMPLE OF USE ---
    import rxj2248_BooneBalestraSource as bbs
    bbs.plot_feltregutkinmodels_cmds(plotnumbers=[1,2],cutSFmodels=False,smallsyms=True)

    """

    modeldata  = nm.load_model('combined',filepath='/Users/kschmidt/work/catalogs/NEOGALlines/nebular_emission/')
    modeldata2 = nm.load_model('combined',filepath='/Users/kschmidt/work/catalogs/NEOGALlines/AGN_NLR_nebular_feltre16/')

    if cutSFmodels:
        if verbose: print(' - Performing cut on model SF model grid')
        xid     = 'dummy'
        nh      = 'dummy'
        COratio = 1.00
        Mcutoff = 100
    else:
        if verbose: print(' - Showing all SF model grids, i.e., setting xid, nh, COratio and Mcutoff to dummy values')
        xid     = 'dummy'
        nh      = 'dummy'
        COratio = 'dummy'
        Mcutoff = 'dummy'

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (1 in plotnumbers) or (99 in plotnumbers):
        namebase  = './photomodels_CIVdCIIIvsCIVdHeII'
        line1     = 'CIV1550'
        line2     = 'CIII1908'
        line3     = 'CIV1550'
        line4     = 'HeII1640'
        xrange    = [2e-2,1e3]
        yrange    = [2e-4,1.5e2]
        boxranges = [0.7,1e99,0.5,1e99]

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,
                                    varyparam='Zgas',logx=True,logy=True,logp1=True,
                                    fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,
                                    plotname=namebase+'_Zgas.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,
                                    modeldata2=modeldata2,colormap='winter',boxranges=boxranges,legpos='lower right',
                                    smallsyms=smallsyms)

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,
                                    varyparam='logUs',logx=True,logy=True,logp1=False,
                                    fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,
                                    plotname=namebase+'_logUs.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,
                                    modeldata2=modeldata2,colormap='spring',boxranges=boxranges,legpos='lower right',
                                    smallsyms=smallsyms)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (2 in plotnumbers) or (99 in plotnumbers):
        line1='CIII1908'
        line2='HeII1640'
        line3='CIV1550'
        line4='HeII1640'
        xrange    = [1e-3,1e3]
        yrange    = [2e-4,1.5e2]
        boxranges = [1e-99,1e99,0.5,1e99]

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='Zgas',logx=True,logy=True,logp1=True,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_CIIIHeIIvsCIVdHeII_Zgas.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='winter',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='logUs',logx=True,logy=True,logp1=False,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_CIIIHeIIvsCIVdHeII_logUs.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='spring',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (3 in plotnumbers) or (99 in plotnumbers):
        pass

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (4 in plotnumbers) or (99 in plotnumbers):
        line1='NV1240'
        line2='CIV1550'
        line3='CIV1550'
        line4='HeII1640'
        xrange    = [5e-5,1e1]
        yrange    = [2e-4,3e2]
        boxranges = [2.05,1e99,0.5,1e99]

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='Zgas',logx=True,logy=True,logp1=True,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,
plotname='./photomodels_NVCIVdvsCIVdHeII_Zgas.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='winter',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='logUs',logx=True,logy=True,logp1=False,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_NVCIVdvsCIVdHeII_logUs.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='spring',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (5 in plotnumbers) or (99 in plotnumbers):
        line1='NV1240'
        line2='HeII1640'
        line3='CIV1550'
        line4='HeII1640'
        xrange    = [1e-6,1e3]
        yrange    = [1e-4,3e2]
        boxranges = [1.02,1e99,0.5,1e99]

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='Zgas',logx=True,logy=True,logp1=True,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_NVHeIIvsCIVdHeII_Zgas.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='winter',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='logUs',logx=True,logy=True,logp1=False,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_NVHeIIvsCIVHeII_logUs.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='spring',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_singlelinetemplate(outfits='./felis_testing/uves_felis_template_singleline.fits',verbose=True):
    """
    Wrapper to generate spectral template with a single line

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.gen_singlelinetemplate()
    """
    doubletlam  = [1907.0,1909.0]
    rangeDlam   = [np.min(doubletlam)-5.0,np.max(doubletlam)+15.0,0.1]
    tcdic = {}
    tcdic['LINE1'] = ['GAUSS', 1907.0, 0.5/4.5, 0.0, 10.0/4.5, 'CIII]1907A mimicking line']
    #tcdic['CONT']  = ['CONT', 1.0, 0.0, 1908.0,       'Continuum with flux 1.0 at 1908 + slope 0.0']
    valstring = '_Singleline_sig_0p5_flux_10p0'
    tempname = outfits.replace('.fits',valstring+'.fits')
    fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=True)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_felistemplates(outfits='./uves_felis_template.fits',overwrite=False,addLSF=False,verbose=True):
    """
    Wrapper to generate spectral templates for cross-correlation with spectra.

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    outdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/felis_testing/'
    uves.gen_felistemplates(outfits=outdir+'uves_felis_template.fits')

    """
    # - - - - - - - - - - - - - - - - - - LSF setup  - - - - - - - - - - - - - - - - - - -
    MUSELSFfwhm  = 1.0 #[A]
    MUSELSFsigma = MUSELSFfwhm/2.354
    LSFparam     = ['LSF', MUSELSFsigma,  'MUSE GAUSS LSF']

    # - - - - - - - - - - - - - - - - - - Width and raange setup - - - - - - - - - - - - - - - - - -
    dlam          = 0.05                                      # wavelength grid spacing in angstrom/pix
    tempwidth     = 10.0                                      # the wavelength range of template (half the width)
    sigmas        = np.array([ 0.2,  0.4,  0.6,  0.8,  1. ,  1.2]) # line width of emission lines in agnstrom
    sigmas_pix    = sigmas / dlam

    # - - - - - - - - - - - - - - - - - - CIII doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1906.68,1908.73]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxCIII1   = 1.0
    fluxratios  = [0.1,0.4,0.7,1.0,1.3,1.6,1.9] # Osterbrock predicts CIII1/CIII2 < 1.6

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the CIII doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxCIII2 = fluxCIII1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['CIII1']                 = ['GAUSS', doubletlam[0], sig, 0.0, fluxCIII1, 'CIII]1907A']
            tcdic['CIII2']                 = ['GAUSS', doubletlam[1], sig, 0.0, fluxCIII2,  'CIII]1909A']

            valstring = '_CIIIdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - CIV doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1548.195,1550.770]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxCIV1    = 1.0
    fluxratios  = [0.5,1.0,1.5,2.0,2.5,3.0] # Feibelman 1983 predicts CIV1/CIV2=2 from theory (Mainali+17 used CIV1/CIV2=1)

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the CIV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxCIV2 = fluxCIV1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['CIV1']                  = ['GAUSS', doubletlam[0], sig, 0.0, fluxCIV1, 'CIV1548A']
            tcdic['CIV2']                  = ['GAUSS', doubletlam[1], sig, 0.0, fluxCIV2,  'CIV1551A']

            valstring = '_CIVdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - NV doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1238.821,1242.804]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxNV1     = 1.0
    fluxratios  = [0.5,1.0,1.5,2.0,2.5,3.0] # Torres-Peimbert, S. & Pena, M. 1984; emissivity ratio of NV1/NV2~2 like CIV

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the NV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxNV2 = fluxNV1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['NV1']                   = ['GAUSS', doubletlam[0], sig, 0.0, fluxNV1, 'NV1239A']
            tcdic['NV2']                   = ['GAUSS', doubletlam[1], sig, 0.0, fluxNV2, 'NV1243A']

            valstring = '_NVdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - OIII doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1660.809,1666.150]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxOIII1   = 1.0
    fluxratios  = [0.1,0.3,0.5,0.7,0.9,1.1] # Morton1991tab2 OIII1/OIII2~0.5 (can be lower and higher but 1666 strongest, see eg. Mainali+17, Vanzella+16, )

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the NV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxOIII2 = fluxOIII1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['OIII1']  = ['GAUSS', doubletlam[0], sig, 0.0, fluxOIII1, 'OIII1661A']
            tcdic['OIII2']  = ['GAUSS', doubletlam[1], sig, 0.0, fluxOIII2, 'OIII1666A']

            valstring = '_OIIIdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - HeII gauss - - - - - - - - - - - - - - - - - -
    linelam     = 1640.420
    rangeDlam   = [linelam-tempwidth,linelam+tempwidth,dlam]

    Ntemps      = len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the HeII line (varying sigma)')

    for sig in sigmas:
        tcdic = {}
        tcdic['HeII']                  = ['GAUSS', linelam, sig, 0.0, 1.0, 'HeII1640A']

        valstring = '_HeII'+\
                    '_sig_'+str(sig).replace('.','p')

        if addLSF:
            tcdic['LSF']        = LSFparam
            valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

        tempname = outfits.replace('.fits',valstring+'.fits')
        fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - SiIII doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1882.71,1892.03] # See detection from Berg+19
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxSiIII1  = 1.0
    fluxratios  = [0.1,0.4,0.7,1.0,1.3,1.6,1.9] # Osterbrock predicts SIII1/SIII2 < 1.7 similar to CIII doublet

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the NV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxSiIII2 = fluxSiIII1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['Si3_1']  = ['GAUSS', doubletlam[0], sig, 0.0, fluxSiIII1, 'SiIII1883A']
            tcdic['Si3_2']  = ['GAUSS', doubletlam[1], sig, 0.0, fluxSiIII2, 'SiIII1892A']

            valstring = '_SiIIIdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)


    # - - - - - - - - - - - - - - - - - - CII gauss - - - - - - - - - - - - - - - - - -
    linelam     = 1335.6627
    rangeDlam   = [linelam-tempwidth,linelam+tempwidth,dlam]

    Ntemps      = len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the CII line (varying sigma)')

    for sig in sigmas:
        tcdic = {}
        tcdic['CII']                  = ['GAUSS', linelam, sig, 0.0, 1.0, 'CII1336A']

        valstring = '_CII'+\
                    '_sig_'+str(sig).replace('.','p')

        if addLSF:
            tcdic['LSF']        = LSFparam
            valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

        tempname = outfits.replace('.fits',valstring+'.fits')
        fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - CII] gauss - - - - - - - - - - - - - - - - - -
    linelam     = 2326.113
    rangeDlam   = [linelam-tempwidth,linelam+tempwidth,dlam]

    Ntemps      = len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the CII] line (varying sigma)')

    for sig in sigmas:
        tcdic = {}
        tcdic['CIIb']                  = ['GAUSS', linelam, sig, 0.0, 1.0, 'CII]2326A']

        valstring = '_CIIb'+\
                    '_sig_'+str(sig).replace('.','p')

        if addLSF:
            tcdic['LSF']        = LSFparam
            valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

        tempname = outfits.replace('.fits',valstring+'.fits')
        fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - MgII doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [2795.528,2802.705]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxMgII1   = 1.0
    fluxratios  = [0.1,0.4,0.7,1.0,1.3,1.6,1.9] # ???

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the NV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxMgII2 = fluxMgII1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['MgII1']  = ['GAUSS', doubletlam[0], sig, 0.0, fluxMgII1, 'MgII2796A']
            tcdic['MgII2']  = ['GAUSS', doubletlam[1], sig, 0.0, fluxMgII2, 'MgII2803A']

            valstring = '_MgIIdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)


    # - - - - - - - - - - - - - - - - - - Width and raange setup - - - - - - - - - - - - - - - - - -
    #FWHM observed for MW LAEs <~10 which corresponds to 10/2.35 / (1+3) <~ 1.06 Angstrom rest-frame
    dlam          = 0.05                                       # wavelength grid spacing in angstrom/pix
    tempwidth     = 20.0                                       # the wavelength range of template (half the width)
    sigmas        = np.array([0.32,0.64,1.28,2.56,5.12,10.24]) # line width of emission lines in agnstrom (rest-frame)
    sigmas_pix    = sigmas/dlam
    # - - - - - - - - - - - - - - - - - - Lya skew gauss - - - - - - - - - - - - - - - - - -
    linelam     = 1215.6737
    rangeDlam   = [linelam-tempwidth,linelam+tempwidth,dlam]
    Lyaskew     = [0.0,3.0,6.0,9.0,12.0]

    Ntemps      = len(sigmas)*len(Lyaskew)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the Lya line (varying sigma and skew)')

    for sig in sigmas:
        for skew in Lyaskew:
            tcdic = {}
            tcdic['Lya']                  = ['GAUSS', linelam, sig, skew, 1.0, 'Lya1216A']

            valstring = '_Lya'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_skew_'+str(skew).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_felismockspec(outfits='./uves_felis_mock_MUSEspectrum.fits',redshift=3.5,
                      zoomxplot=None,verbose=True):
    """
    Wrapper to generate a set of mock MUSE spectra to test FELIS on

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    outdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/felis_testing/'
    uves.gen_felismockspec(outfits=outdir+'uves_felis_mock_MUSEspectrum.fits',redshift=3.5,zoomxplot=np.array([1880,1940])*(1+3.5))

    """
    if verbose: print(' - Building mockspectra at redshift '+str(redshift)+' using FELIS tools')
    tcdic = {}
    #tcdic['CONT']                   = ['CONT',  1.0, 0.0, 0.0,          'Flat continuum at 1.0']

    voffsetCIV = -200 #km/s
    lam_obsCIV1, lam_offsetCIV1, dlamCIV1 = kbs.velocityoffset2dwave(redshift,voffsetCIV,1548.195,verbose=verbose)
    tcdic['CIV1']  = ['GAUSS', lam_offsetCIV1, 0.5, 0.0, 10.0, 'CIV1548A']

    lam_obsCIV2, lam_offsetCIV2, dlamCIV2 = kbs.velocityoffset2dwave(redshift,voffsetCIV,1550.770,verbose=verbose)
    tcdic['CIV2']  = ['GAUSS', lam_offsetCIV2, 0.5, 0.0, 5.0,  'CIV1551A']

    tcdic['CIII1'] = ['GAUSS', 1907.0 * (1+redshift), 0.5, 0.0, 10.0, 'CIII]1907A']

    tcdic['CIII2'] = ['GAUSS', 1909.0 * (1+redshift), 0.5, 0.0, 5.0,  'CIII]1909A']

    voffsetLYA = -500 #km/s
    lam_obsLYA, lam_offsetLYA, dlamLYA = kbs.velocityoffset2dwave(redshift,voffsetLYA,1216.0,verbose=verbose)
    tcdic['LYA']   = ['GAUSS', lam_offsetLYA, 20.0, 10.0, 100.0, 'Lya1216']

    noisesigmas = [0.05,0.5,1.0,3.0]
    for sigma in noisesigmas:
        mockspec = outfits.replace('.fits','_noisesigma'+str(sigma).replace('.','p')+'.fits')
        noise    = ['GAUSS', 0.0, sigma]
        fbt.build_template([4800,9300,0.25],tcdic,tempfile=mockspec,noise=noise,overwrite=True,zoomxplot=zoomxplot)
        if verbose: print(' - Wrote output spectrum to '+mockspec)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_felismockspec_fromsetupfile(specsetup,basename='./uves_felis_mock_spectrum_fromsetup.fits',
                                    plotspectra=False,overwrite=False,noisesetup='errspec',
                                    verbose=True,verbose_buildtemp=False):
    """
    Wrapper to generate a set of mock spectra to test FELIS on.
    The setup of each of the mock spectra are defined in the spec setup file

    Note; by setting noisesetup=None templates can be generated for the FELIS fitting using a similar setup file.

    --- INPUT ---
    specsetup           Setup file containing the components and spectra to generate
    basename            Main name (and dir) of mock fits spectra to generate
    plotspectra         To plot the generated spectra set this to true
    overwrite           Overwrite existing files?
    verbose             Toggle verbosity
    verbose_buildtemp   Toggle verbosity of the FELIS function building the template

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    basename   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra/uves_mock_spectrum_fromsetup.fits'
    specsetup  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_setup.txt'
    uves.gen_felismockspec_fromsetupfile(specsetup,basename=basename,verbose_buildtemp=True,overwrite=True,plotspectra=True)

    """
    if verbose: print(' - Building mockspectra using FELIS tools')
    templatedat = np.genfromtxt(specsetup,names=True,skip_header=7,comments='#',
                                dtype='80a,80a,80a,80a,80a,80a,80a,80a,80a,f,f,80a,80a')
    # ----- load error spectrum to use for noise simulations -----
    if noisesetup.lower() == 'errspec':
        skyspec     = None # should be noise spectrum '/Users/kschmidt/work/MUSE/skyspectra/SKY_SPECTRUM_candels-cdfs-36_av.fits'
        errspec     = '/Users/kschmidt/work/MUSE/spectra_noise/median_eff_noise_spectrum_70fields190819.fits'
        noisewave   = afits.open(errspec)[1].data['wave']
        noiseflux   = afits.open(errspec)[1].data['flux'] * 5.5 # 5.5 corresponds to r=0.6'' (30 pixel) aperture
                                                                # spectrum as total noise on such spectrum would
                                                                # be pix_noise x 30/sqrt(30)
        noise       = ['SPECTRUM', noisewave, noiseflux]
    elif noisesetup.lower() == 'fixedvalue':
        noisesigma  = 0.2
        noisemean   = 0.5
        noise       = ['GAUSS', noisemean, noisesigma]
    elif noisesetup.lower() == 'none':
        noise       = None
        noisesigma  = None

    for tt, tempname in enumerate(templatedat['namekey']):
        tempdic = {}
        linewaves  = np.asarray(templatedat['linewaves'][tt][1:-1].split(',')).astype(float)
        linesigmas = np.asarray(templatedat['sigmas'][tt][1:-1].split(',')).astype(float)
        lineskews  = np.asarray(templatedat['skew'][tt][1:-1].split(',')).astype(float)
        linefluxes = np.asarray(templatedat['scaling'][tt][1:-1].split(',')).astype(float)
        redshifts  = np.asarray(templatedat['redshift'][tt][1:-1].split(',')).astype(float)
        fratios    = np.asarray(templatedat['fratios'][tt][1:-1].split(',')).astype(float)

        for linesigma in linesigmas:
            for lineskew in lineskews:
                for lineflux in linefluxes:
                    for zval in redshifts:
                        for fratio in fratios:
                            tempdic['line1'] = [templatedat['type'][tt], linewaves[0] * (1+zval),
                                                linesigma, lineskew,
                                                lineflux, templatedat['headerinfo'][tt]+'_1']
                            if len(linewaves) == 2:
                                tempdic['line2'] = [templatedat['type'][tt], linewaves[1] * (1+zval),
                                                    linesigma, lineskew,
                                                    lineflux / fratio, templatedat['headerinfo'][tt]+'_2']
                                Ftotspec         = lineflux + lineflux / fratio
                            else:
                                Ftotspec         = lineflux

                            wavecen  = np.mean(linewaves)* (1+zval)
                            wavemin  = wavecen-templatedat['waverange'][tt]/2.* (1+zval)
                            wavemax  = wavecen+templatedat['waverange'][tt]/2.* (1+zval)

                            outstr   = '_'+tempname+\
                                       '_noisestd'+str(noisesigma).replace('.','p')+\
                                       '_sigma'+str("%.2f" % linesigma).replace('.','p')+\
                                       '_skew'+str("%.2f" % lineskew).replace('.','p')+\
                                       '_Ftot'+str("%.2f" % Ftotspec).replace('.','p')+\
                                       '_Fratio'+str("%.2f" % fratio).replace('.','p')+\
                                       '_z'+str("%.2f" % zval).replace('.','p')+\
                                       '.fits'
                            if noisesetup.lower() == 'errspec':
                                outstr = outstr.replace('_noisestd'+str(noisesigma).replace('.','p'),'_noisespec')
                            mockspec = basename.replace('.fits',outstr)
                            try:
                                fbt.build_template([wavemin,wavemax,templatedat['dwave'][tt]],
                                                   tempdic,tempfile=mockspec,
                                                   noise=noise,overwrite=overwrite,
                                                   plottemplate=plotspectra,zoomxplot=[wavemin,wavemax],
                                                   verbose=verbose_buildtemp,
                                                   waveunits=templatedat['waveunits'][tt],
                                                   fluxunits=templatedat['fluxunits'][tt])
                            except:
                                print('\n\n ERROR: fbt.build_template failed... stopping to enable invesitgations')
                                pdb.set_trace()

                            if verbose: print(' - Genreated spectrum:   '+mockspec)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def build_mockspeck_setup_parametertable(setupfile,skip_header=7,noisestr='_noisespec',basename='',verbose=True):
    """
    Function to write (and load) table with parameter sets of the individual spectra generated from setupfile with
    uves.gen_felismockspec_fromsetupfile(). Essentially just expanding the parameter lists.

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    basename   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra/uves_mock_spectrum_fromsetup.fits'
    specsetup  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_setup.txt'
    paramtable = uves.build_mockspeck_setup_parametertable(specsetup,basename=basename)

    """
    templatedat = np.genfromtxt(setupfile,names=True,skip_header=skip_header,
                                comments='#',dtype='80a,80a,80a,80a,80a,80a,80a,80a,80a,f,f,80a,80a')
    outputfile  = setupfile.replace('.txt','_parametertable.txt')

    fout = open(outputfile,'w')
    fout.write('# Parameter table of spectra generated with uves.gen_felismockspec_fromsetupfile() based on the setup\n')
    fout.write('# '+setupfile+'\n')
    fout.write('# \n')
    fout.write('#  linesigma     lineskew     lineflux     Ftotspec     redshift       Fratio       dwave              waveunits    fluxunits            specname \n')
    for tt, tempname in enumerate(templatedat['namekey']):
        linewaves  = np.asarray(templatedat['linewaves'][tt][1:-1].split(',')).astype(float)
        linesigmas = np.asarray(templatedat['sigmas'][tt][1:-1].split(',')).astype(float)
        lineskews  = np.asarray(templatedat['skew'][tt][1:-1].split(',')).astype(float)
        linefluxes = np.asarray(templatedat['scaling'][tt][1:-1].split(',')).astype(float)
        redshifts  = np.asarray(templatedat['redshift'][tt][1:-1].split(',')).astype(float)
        fratios    = np.asarray(templatedat['fratios'][tt][1:-1].split(',')).astype(float)
        dwave      = templatedat['dwave'][tt]
        fluxunits  = templatedat['fluxunits'][tt]
        waveunits  = templatedat['waveunits'][tt]

        for linesigma in linesigmas:
            for lineskew in lineskews:
                for lineflux in linefluxes:
                    for zval in redshifts:
                        for fratio in fratios:
                            if len(linewaves) == 2:
                                Ftotspec         = lineflux + lineflux/fratio
                            else:
                                Ftotspec         = lineflux

                            specext    = '_'+tempname+\
                                         noisestr+\
                                         '_sigma'+str("%.2f" % linesigma).replace('.','p')+\
                                         '_skew'+str("%.2f" % lineskew).replace('.','p')+\
                                         '_Ftot'+str("%.2f" % Ftotspec).replace('.','p')+\
                                         '_Fratio'+str("%.2f" % fratio).replace('.','p')+\
                                         '_z'+str("%.2f" % zval).replace('.','p')+\
                                         '.fits'
                            specname  = basename.replace('.fits',specext)

                            paramlist = str("%12.4f" % linesigma)+' '+\
                                        str("%12.4f" % lineskew)+' '+\
                                        str("%12.4f" % lineflux)+' '+\
                                        str("%12.4f" % Ftotspec)+' '+\
                                        str("%12.4f" % zval)+' '+\
                                        str("%12.4f" % fratio)+' '+\
                                        str("%12.4f" % dwave)+' '+\
                                        str("%20s" % waveunits)+' '+\
                                        str("%20s" % fluxunits)
                            fout.write(paramlist+'     '+specname+'\n')
    fout.close()

    paramtable = np.genfromtxt(outputfile,names=True,comments='#',skip_header=3,dtype='f,f,f,f,f,f,f,20a,20a,200a')
    return paramtable

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def pre190911_gen_mocspecFELISresults_summary(summaryfile,picklefiles,overwrite=False,verbose=True):
    """
    Generate a summary of the template characteristics FELIS determined to match the mock spectra
    the best, i.e. with the highest S/N.

    - - - - - - - - - - - - - - - - - - - - - -  NB - - - - - - - - - - - - - - - - - - - - - - -
    - - -  After correcting the FELIS normalization this function was depreciated on 190911 - - -
    - - -  Instead the summarizing can now be done with the new version of the function     - - -

    --- INPUT ---
    summaryfile        Path and name to summary file to generate.
    picklefiles        List of FELIS pickle files to summarize.
    overwrite          Overwrite the summary file if it already exists?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    FELISoutputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults/'
    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_all.txt'
    picklefiles    = glob.glob(FELISoutputdir+'*.pkl')
    summarydat     = uves.gen_mocspecFELISresults_summary(summaryfile,picklefiles)

    """
    if verbose: print(' - Generating a summary of the best-fit template in:\n   '+summaryfile)
    if os.path.isfile(summaryfile) & (not overwrite):
        sys.exit(' Summary file '+summaryfile+' already exists and overwrite=False ')

    fout = open(summaryfile,'w')
    fout.write('# Summary of '+str(len(picklefiles))+' FELIS pickle files provided \n')
    fout.write('# File contains the characteristics of the templates with max S/N from the FELIS template fits \n')
    fout.write('# The summary was generated with uves.compate_mockspec_to_FELISresults() on '+kbs.DandTstr2()+' \n')
    fout.write('# \n')
    fout.write('# Columns are:\n')
    fout.write('# z_spec                     Instrinspic redshift of matched mock spectrum \n')
    fout.write('# z_temp_S2Nmax              Estimated redshift from template match\n')
    fout.write('# sigma_spec_pix             Input sigma in pixels for mock spectrum (mean for multiple lines)\n')
    fout.write('# sigma_spec_ang_rf          Input sigma in rest-frame angstroms for mock spectrum (mean for multiple lines)\n')
    fout.write('# sigma_temp_pix             Input sigma in pixels for maxS/N template (mean for multiple lines)\n')
    fout.write('# sigma_temp_ang_rf          Input sigma in rest-frame angstroms for maxS/N template (mean for multiple lines)\n')
    fout.write('# Fratio_spec                Flux ratio of doublets in mock spectrum (line_lowwave/line_highwave) \n')
    fout.write('# Fratio_temp                Flux ratio of doublets in template      (line_lowwave/line_highwave) \n')
    fout.write('# Ftot_spec_intr             Intrinsic total flux of mock spectrum \n')
    fout.write('# Ftot_spec_trapz            Integreated total flux of mock spectrum after noise addition \n')
    fout.write('# Ftot_spec_trapz_err        Uncertainty on Ftot_spec_trapz (mock spectrum flux errors propogated) \n')
    fout.write('# Ftot_temp_trapz            Integreated total flux of normalized template scaled by fluxscale_S2Nmax\n')
    fout.write('# Ftot_temp_trapz_err        Uncertainty on Ftot_temp_trapz (mock spectrum flux errors propogated) \n')
    fout.write('# Ftot_temp_trapz_fsclaeerr  Uncertainty on Ftot_temp_trapz (using fluxscaleerr_S2Nmax for all pixels) \n')
    fout.write('# Ftot_temp_sum              Summed total flux of normalized template scaled by fluxscale_S2Nmax\n')
    fout.write('# Ftot_temp_sum_err          Uncertainty on Ftot_sum_trapz (mock spectrum flux errors propogated) \n')
    fout.write('# Ftot_temp_sum_fsclaeerr    Uncertainty on Ftot_sum_trapz (using fluxscaleerr_S2Nmax for all pixels) \n')
    fout.write('# vshift_spec                Known intrinsic velocity shift of mock spectrum \n')
    fout.write('# vshift_CCmatch             Estimated velocity shift from template match [ c*(z_spec-z_temp_S2Nmax)/(1+z_temp_S2Nmax) ]\n')
    fout.write('# fluxscale_S2Nmax           Flux scale applied to normalized template to obtain maxS/N match \n')
    fout.write('# fluxscaleerr_S2Nmax        Uncertainty on fluxscale_S2Nmax [sqrt(fluxscale_variance)]\n')
    fout.write('# S2Nmax                     The S/N value of the (scaled) template match to the mock spectrum \n')
    fout.write('# Ngoodent                   The number of good pixels used in the cross correlation \n')
    fout.write('# chi2                       Chi^2 value between the mock spectrum and the template match \n')
    fout.write('# lineS2N                    Estimated S/N of spectral feature within [lineS2Nwavemin,lineS2Nwavemin] \n')
    fout.write('# lineS2Nwavemin             Lower integration limit for S/N estimate \n')
    fout.write('# lineS2Nwavemax             Upper integration limit for S/N estimate \n')
    fout.write('# lineS2N_rf                 Estimated S/N (rest-frame) of spectral feature within [lineS2Nwavemin_rf,lineS2Nwavemin_rf] \n')
    fout.write('# lineS2Nwavemin_rf          Lower integration limit for rest-frame S/N estimate \n')
    fout.write('# lineS2Nwavemax_rf          Upper integration limit for rest-frame S/N estimate \n')
    fout.write('# Ftot                       Total flux of spectral feature (sum(f)*dwave) used to estimate line S/N \n')
    fout.write('# Ftot_sigma                 Squaroot of the variance/sqrt(Npix) of Ftot \n')
    fout.write('# spectrum                   The mock spectrum the templates were matched to \n')
    fout.write('# template                   The maxS/N template \n')
    fout.write('# \n')
    fout.write('# z_spec z_temp_S2Nmax    sigma_spec_pix sigma_spec_ang_rf sigma_temp_pix sigma_temp_ang_rf   '
               ' Fratio_spec Fratio_temp     '
               'Ftot_spec_intr Ftot_spec_trapz Ftot_spec_trapz_err '
               'Ftot_temp_trapz Ftot_temp_trapz_err Ftot_temp_trapz_fsclaeerr     '
               'Ftot_temp_sum Ftot_temp_sum_err Ftot_temp_sum_fsclaeerr '
               'vshift_spec vshift_CCmatch     fluxscale_S2Nmax fluxscaleerr_S2Nmax    '
               'S2Nmax Ngoodent chi2    '
               'lineS2N lineS2Nwavemin lineS2Nwavemax lineS2N_rf lineS2Nwavemin_rf lineS2Nwavemax_rf     '
               'Ftot Ftot_sigma     spectrum template \n')

    for pp, picklefile in enumerate(picklefiles):
        if verbose:
            infostr = ' - Summarizing picklefile  '+str("%.5d" % (pp+1))+' / '+str("%.5d" % len(picklefiles))+'     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        loaddic       = felis.load_picklefile(picklefile)

        Nsigma_integration = 3.0

        for specname in loaddic.keys():
            keydic = loaddic[specname]

            # load info about max S/N template
            template, vshift_intr, vshift_match, fluxscale_S2Nmax, fluxscaleerr_S2Nmax, \
            S2Nmax, Ngoodent, chi2, z_spec, zS2Nmax =  \
                felis.getresult4maxS2N(loaddic,specname)

            # load matched spec and move to restframe
            s_wave   , s_flux   , s_df   , s_s2n    = felis.load_spectrum(specname,verbose=False)
            s_wave_rf, s_flux_rf, s_df_rf, s_s2n_rf = s_wave / (1+z_spec), s_flux * (1+z_spec), s_df * (1+z_spec), s_s2n

            # interpolate max S/N template to spec grid
            min_template_level = 1e-4
            t_wave_init, t_flux_init, t_df_init, t_s2n_init = felis.load_spectrum(template,verbose=False)
            func       = scipy.interpolate.interp1d(t_wave_init,t_flux_init,kind='linear',fill_value="extrapolate")
            t_flux     = func(s_wave_rf)
            t_flux[t_flux < min_template_level] = 0.0

            # Normalize template flux to 1
            if len(t_flux[t_flux != 0]) == 0:
                if verbose: print(' WARNING All interpolated template pixels are 0.0')
            else:
                temp_sum = np.sum(t_flux)
                t_flux   = t_flux / temp_sum

            # extract info on template and mockspec from fits headers
            spec_hdr        = afits.open(specname)[1].header
            spec_sigma_ang  = np.array([])
            spec_flux       = np.array([])
            spec_line_wave  = np.array([])
            for hdrkey in spec_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: spec_line_wave = np.append(spec_line_wave,spec_hdr[hdrkey])
                    if '_2' in hdrkey: spec_sigma_ang = np.append(spec_sigma_ang,spec_hdr[hdrkey])
                    if '_4' in hdrkey: spec_flux      = np.append(spec_flux,spec_hdr[hdrkey])

            spec_sigma_ang_rf  = np.mean(spec_sigma_ang) / (1.0+z_spec)
            spec_sigma_pix     = spec_sigma_ang_rf       / np.median(np.diff(s_wave_rf))
            Ftot_spec_intr     = np.sum(spec_flux)
            if len(spec_flux) == 2:
                Fratio_spec = spec_flux[np.where(spec_line_wave == np.min(spec_line_wave))] / \
                              spec_flux[np.where(spec_line_wave == np.max(spec_line_wave))]
            else:
                Fratio_spec = 0.0


            lineS2Nwavemin = np.min(spec_line_wave)-Nsigma_integration*np.median(spec_sigma_ang)
            lineS2Nwavemax = np.max(spec_line_wave)+Nsigma_integration*np.median(spec_sigma_ang)
            waverange      = [lineS2Nwavemin,lineS2Nwavemax]
            goodent        = np.where((s_wave >= waverange[0]) & (s_wave <= waverange[1]))

            lineS2Nwavemin_rf = np.min(spec_line_wave/(1.0+z_spec))-Nsigma_integration*spec_sigma_ang_rf
            lineS2Nwavemax_rf = np.max(spec_line_wave/(1.0+z_spec))+Nsigma_integration*spec_sigma_ang_rf
            waverange_rf      = [lineS2Nwavemin_rf,lineS2Nwavemax_rf]
            goodent_rf        = np.where((s_wave_rf >= waverange_rf[0]) & (s_wave_rf <= waverange_rf[1]))

            # Ftot_trapz = np.trapz(fluxscale_S2Nmax * t_flux,s_wave_rf)
            datarr               = unumpy.uarray(fluxscale_S2Nmax * t_flux[goodent_rf], s_df_rf[goodent_rf])
            Ftot_trapz           = np.trapz(datarr,s_wave_rf[goodent_rf])
            Ftot_sum             = np.sum(datarr) * np.median(np.diff(s_wave_rf[goodent_rf]))

            datarr_fscaleerr     = unumpy.uarray(fluxscale_S2Nmax * t_flux[goodent_rf], fluxscaleerr_S2Nmax + t_flux[goodent_rf]*0.0)
            Ftot_trapz_fscaleerr = np.trapz(datarr_fscaleerr,s_wave_rf[goodent_rf])
            Ftot_sum_fscaleerr   = np.sum(datarr) * np.median(np.diff(s_wave_rf[goodent_rf]))

            datarr_spec        = unumpy.uarray(s_flux_rf[goodent_rf], s_df_rf[goodent_rf])
            Ftot_trapz_spec    = np.trapz(datarr_spec,s_wave_rf[goodent_rf])

            temp_hdr        = afits.open(template)[1].header
            temp_sigma_ang  = np.asarray([])
            temp_flux       = np.asarray([])
            temp_line_wave  = np.asarray([])
            for hdrkey in temp_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: temp_line_wave = np.append(temp_line_wave,temp_hdr[hdrkey])
                    if '_2' in hdrkey: temp_sigma_ang = np.append(temp_sigma_ang,temp_hdr[hdrkey])
                    if '_4' in hdrkey: temp_flux      = np.append(temp_flux,temp_hdr[hdrkey])

            temp_sigma_ang_rf = np.mean(temp_sigma_ang) / (1.0+0.0)
            temp_sigma_pix    = np.mean(temp_sigma_ang) / np.median(np.diff(t_wave_init))
            if len(temp_flux) == 2:
                Fratio_temp = temp_flux[np.where(temp_line_wave == np.min(temp_line_wave))] / \
                              temp_flux[np.where(temp_line_wave == np.max(temp_line_wave))]
            else:
                Fratio_temp = 0.0

            #------------ Estimating S/N ------------
            Ftot, vartot, Npixgood, lineS2N = uves.calc_1Dspec_S2N(s_wave,s_flux,s_df**2.0,
                                                                   waverange,verbose=False)
            Ftot_sigma = np.sqrt(vartot)

            Ftot_rf, vartot_rf, Npixgood_rf, lineS2N_rf = uves.calc_1Dspec_S2N(s_wave_rf,s_flux_rf,s_df_rf**2.0,
                                                                               waverange_rf,verbose=False)

            if (Ftot-Ftot_rf) > 1.0:
                print(' - Ftot-Ftot_rf is less than 1e-20cgs; stopping to enable investigation')
                pdb.set_trace()

            #------------ Writing to output file ------------
            outstr = str("%7.4f" % z_spec)+'  '+\
                     str("%7.4f" % zS2Nmax)+'      '+\
                     str("%7.4f" % np.mean(spec_sigma_pix))+'  '+\
                     str("%7.4f" % spec_sigma_ang_rf)+'  '+\
                     str("%7.4f" % np.mean(temp_sigma_pix))+'  '+\
                     str("%7.4f" % temp_sigma_ang_rf)+'      '+\
                     str("%7.2f" % Fratio_spec)+'  '+\
                     str("%7.2f" % Fratio_temp)+'      '+\
                     str("%12.4f" % Ftot_spec_intr)+'  '+\
                     str("%12.4f" % Ftot_trapz_spec.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_trapz_spec.std_dev)+'  '+\
                     str("%12.4f" % Ftot_trapz.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_trapz.std_dev)+'  '+\
                     str("%12.4f" % Ftot_trapz_fscaleerr.std_dev)+'           '+\
                     str("%12.4f" % Ftot_sum.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_sum.std_dev)+'  '+\
                     str("%12.4f" % Ftot_sum_fscaleerr.std_dev)+'           '+\
                     str("%12.4f" % vshift_intr)+'  '+\
                     str("%12.4f" % vshift_match)+'      '+\
                     str("%12.4f" % fluxscale_S2Nmax)+'  '+\
                     str("%12.4f" % fluxscaleerr_S2Nmax)+'  '+\
                     str("%12.4f" % S2Nmax)+'  '+\
                     str("%12.4f" % Ngoodent)+'  '+\
                     str("%12.4f" % chi2)+'  '+\
                     str("%12.4f" % lineS2N)+'  '+\
                     str("%12.4f" % lineS2Nwavemin)+'  '+\
                     str("%12.4f" % lineS2Nwavemax)+'  '+\
                     str("%12.4f" % lineS2N_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemin_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemax_rf)+'  '+\
                     str("%12.4f" % Ftot)+'  '+\
                     str("%12.4f" % Ftot_sigma)+'  '+\
                     specname+'  '+\
                     template+'  '
            fout.write(outstr+'\n')
    if verbose: print('\n   ...done')
    fout.close()

    fmt = 'f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=39,dtype=fmt,comments='#',names=True)
    return summarydat
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def pre190911_plot_mocspecFELISresults_summary(summaryfile,plotbasename,colortype='lineS2N_rf',histaxes=False,Nbins=50,
                                     overwrite=False,verbose=True):
    """
    plotting and evaluating the output from uves.gen_mocspecFELISresults_summary()

    - - - - - - - - - - - - - - - - - - - - - -  NB - - - - - - - - - - - - - - - - - - - - - - -
    - - -  After correcting the FELIS normalization this function was depreciated on 190911 - - -
    - - -  Instead the plotting can now be done with the new version of the function        - - -


    --- INPUT ---
    summaryfile        Path and name to summary file to evaluate
    plotbasename       The based name for the plots to generate (incl. output directory)
    overwrite          Overwrite the plots if they already exist?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary.txt'
    plotbasename   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_plots/190815test_'
    uves.plot_mocspecFELISresults_summary(summaryfile,plotbasename)

    """
    if verbose: print(' - Loading and plotting the content of \n   '+summaryfile)
    fmt = 'f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=39,dtype=fmt,comments='#',names=True)
    specnumber = np.arange(len(summarydat))+1.0

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'S2NvsS2N'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['lineS2N_rf'])
    yvalues  = np.asarray(summarydat['S2Nmax'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Rest-frame emission line S/N'
    ylabel   = 'Template match S/N'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,colortype='Ftot',
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[1,1000],yrange=[1,1000],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'LineSigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['sigma_spec_ang_rf'])
    yvalues  = np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Mock spectrum $\sigma_\\textrm{Gauss, restframe}$ [\AA]'
    ylabel   = 'Best-fit template $\sigma_\\textrm{Gauss, restframe}$ [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ftot_intrinsic'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_intr'])
    yvalues  = np.asarray(summarydat['fluxscale_S2Nmax'])
    xerr     = [None]*len(xvalues)
    yerr     = summarydat['fluxscaleerr_S2Nmax']
    xlabel   = 'Intrinsic (pre-noise) flux in mock spectrum [1e-20 erg/s/cm$^2$]'
    ylabel   = '$\\alpha$ FELIS template flux estimate [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colortype=colortype,colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ftot_observed'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_trapz'])
    yvalues  = np.asarray(summarydat['fluxscale_S2Nmax'])
    xerr     = summarydat['Ftot_spec_trapz_err']
    yerr     = summarydat['fluxscaleerr_S2Nmax']
    xlabel   = 'Observed (post-noise) flux in mock spectrum [1e-20 erg/s/cm$^2$]'
    ylabel   = '$\\alpha$ FELIS template flux estimate [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colortype=colortype,colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ftot_intrinsic_sum'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_intr'])
    yvalues  = np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = [None]*len(xvalues)
    yerr     = summarydat['Ftot_temp_sum_err']
    xlabel   = 'Total flux in mock spectrum (intrinsic)\\\\(no noise) [1e-20 erg/s/cm$^2$]'
    ylabel   = 'Total flux in best-fit template (sum)\\\\(mock spec noise) [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ftot_observed_sum'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot'])
    yvalues  = np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = summarydat['Ftot_sigma']
    yerr     = summarydat['Ftot_temp_sum_fsclaeerr']
    xlabel   = 'Total flux in mock spectrum (sum)\\\\("observed"; with noise) [1e-20 erg/s/cm$^2$]'
    ylabel   = 'Total flux in best-fit template (sum)\\\\(integrated; flux scale "noise") [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Redshift'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['z_spec'])
    yvalues  = np.asarray(summarydat['z_temp_S2Nmax'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Intrinsic redshift mock spectrum'
    ylabel   = 'Redshift of best-fit template'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   colortype='vshift',colorcode=True,cdatvec = summarydat['vshift_CCmatch'],
                                                   overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dFtot_vs_S2N'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['S2Nmax'])
    yvalues  = np.asarray(summarydat['Ftot_spec_intr']) - np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = [None]*len(xvalues)
    yerr     = summarydat['Ftot_temp_sum_err']
    xlabel   = 'S/N of template cross match to mock spectrum'
    ylabel   = '$\Delta$Total flux; intrinsic mock spec - best-fit template [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   # yrange=[-3,3],colortype='redshift',
                                                   yrange=None,colortype='redshift',cdatvec = summarydat['z_spec'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dsigma_vs_S2N'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['S2Nmax'])
    yvalues  = np.asarray(summarydat['sigma_spec_ang_rf']) - np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)
    xlabel   = 'S/N of template cross match to mock spectrum'
    ylabel   = '$\Delta\sigma_\\textrm{Gauss, restframe}$; intrinsic mock spec - best-fit template [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   # yrange=[-0.05,0.05],colortype='redshift',
                                                   yrange=None,colortype='redshift',cdatvec = summarydat['z_spec'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dsigma_vs_sigmaspec'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['sigma_spec_ang_rf'])
    yvalues  = np.asarray(summarydat['sigma_spec_ang_rf']) - np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)
    xlabel   = 'Mock spec intrinsic $\sigma_\\textrm{Gauss, restframe}$ [\AA]'
    ylabel   = '$\Delta\sigma_\\textrm{Gauss, restframe}$; intrinsic mock spec - best-fit template [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   # yrange=[-0.05,0.05],colortype=colortype,
                                                   yrange=None,colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dFtot_vs_specno'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = specnumber
    yvalues  = np.asarray(summarydat['Ftot_spec_intr']) - np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
    ylabel   = '$\Delta$Ftot; mock spec - temp match [1e-20erg/s/cm$^2$]'


    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',colortype='Sigma',cdatvec = summarydat['sigma_spec_ang_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dFtot_vs_Ftot'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_intr'])
    yvalues  = np.asarray(summarydat['Ftot_spec_intr']) - np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Ftot mock spec [1e-20erg/s/cm$^2$]'
    ylabel   = '$\Delta$Ftot; mock spec - temp match [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',colortype='Sigma',cdatvec = summarydat['sigma_spec_ang_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_Ftot_vs_Ftot'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_intr'])
    yvalues  = (np.asarray(summarydat['Ftot_temp_sum'])/np.asarray(summarydat['Ftot_spec_intr'])) -1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Ftot mock spec [1e-20erg/s/cm$^2$]'
    ylabel   = '(Ftot temp match / Ftot mock spec) - 1 '

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',colortype='Sigma',cdatvec = summarydat['sigma_spec_ang_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # nameext  = 'Ratio_Ftot_vs_lineS2N'
    # plotname = plotbasename+nameext+'.pdf'
    # xvalues  = np.asarray(summarydat['lineS2N_rf'])
    # yvalues  = (np.asarray(summarydat['Ftot_temp_trapz'])/np.asarray(summarydat['Ftot_spec_intr'])) -1.0
    # xerr     = [None]*len(xvalues)
    # yerr     = [None]*len(xvalues)
    # xlabel   = 'Line S/N'
    # ylabel   = '(Ftot temp match / Ftot mock spec) - 1 '
    #
    # uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
    #                                                histaxes=histaxes,Nbins=Nbins,
    #                                                linetype='horizontal',colortype='Ftot_spec_intr',
    #                                                colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_Ftot_vs_lineS2N_sum_temp'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['lineS2N_rf'])
    yvalues  = (np.asarray(summarydat['Ftot_temp_sum'])/np.asarray(summarydat['Ftot_spec_intr'])) -1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Line S/N'
    ylabel   = '(Ftot sum tempalte / Ftot intrinsic) - 1 '

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,yrange=[-0.7,0.7],
                                                   linetype='horizontal',colortype='Ftot_spec_intr',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_Ftot_vs_lineS2N_sum_spec'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['lineS2N_rf'])
    yvalues  = (np.asarray(summarydat['Ftot'])/np.asarray(summarydat['Ftot_spec_intr'])) -1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Line S/N'
    ylabel   = '(Ftot sum mock spec w. noise / Ftot mock spec intrinsic) - 1 '

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,yrange=[-0.7,0.7],
                                                   linetype='horizontal',colortype='Ftot_spec_intr',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dsigma_vs_specno'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = specnumber
    yvalues  = np.asarray(summarydat['sigma_spec_ang_rf']) - np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
    ylabel   = '$\Delta\sigma_\\textrm{rest}$; mock spec - temp match [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dsigma_vs_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['sigma_spec_ang_rf'])
    yvalues  = np.asarray(summarydat['sigma_spec_ang_rf']) - np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '$\sigma_\\textrm{rest}$ mock spec'
    ylabel   = '$\Delta\sigma_\\textrm{rest}$; mock spec - temp match [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_sigma_vs_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['sigma_spec_ang_rf'])
    yvalues  = (np.asarray(summarydat['sigma_temp_ang_rf'])/np.asarray(summarydat['sigma_spec_ang_rf'])) -1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '$\sigma_\\textrm{rest}$ mock spec'
    ylabel   = '($\sigma_\\textrm{rest}$ temp match / $\sigma_\\textrm{rest}$ mock spec) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dz_vs_specno'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = specnumber
    yvalues  = np.asarray(summarydat['z_spec'])-np.asarray(summarydat['z_temp_S2Nmax'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
    ylabel   = '$\Delta z$; mock spec - temp match'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',colortype='redshift',cdatvec = summarydat['z_spec'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    #-------------------------------------------------------------------------------------------------------------------
    #-------------------------------------------------------------------------------------------------------------------
    goodFratio = np.where(summarydat['Fratio_spec'] > 0)
    if len(goodFratio[0]) > 0:
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'FluxRatio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])
        yvalues  = np.asarray(summarydat['Fratio_temp'][goodFratio])
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Flux ratio mock spectrum doublet lines'
        ylabel   = 'Flux ratio best-fit template doublet lines'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='onetoone',
                                                       colortype='s2n',cdatvec = summarydat['lineS2N_rf'][goodFratio],
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'dFluxRatio_vs_specno'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = specnumber[goodFratio]
        yvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])-np.asarray(summarydat['Fratio_temp'][goodFratio])
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
        ylabel   = '$\Delta$Flux ratio; mock spec- temp match'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'dFluxRatio_vs_Fluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])
        yvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])-np.asarray(summarydat['Fratio_temp'][goodFratio])
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Flux ratio mock spec'
        ylabel   = '$\Delta$Flux ratio; mock spec - temp match'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_Fluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])
        yvalues  = (np.asarray(summarydat['Fratio_temp'][goodFratio])/np.asarray(summarydat['Fratio_spec'][goodFratio])) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Flux ratio mock spec '
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_specno'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = specnumber[goodFratio]
        yvalues  = (np.asarray(summarydat['Fratio_temp'][goodFratio])/np.asarray(summarydat['Fratio_spec'][goodFratio])) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_specno'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = specnumber[goodFratio]
        yvalues  = (np.asarray(summarydat['Fratio_temp'][goodFratio])/np.asarray(summarydat['Fratio_spec'][goodFratio])) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_lineS2N'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['lineS2N_rf'][goodFratio]
        yvalues  = (summarydat['Fratio_temp'][goodFratio]/summarydat['Fratio_spec'][goodFratio]) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Line S/N'
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]
        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',
                                                       cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_Ratio_sigma'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = (summarydat['sigma_temp_ang_rf'][goodFratio]/summarydat['sigma_spec_ang_rf'][goodFratio]) -1.0
        yvalues  = (summarydat['Fratio_temp'][goodFratio]/summarydat['Fratio_spec'][goodFratio]) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = '($\sigma_\\textrm{rest}$ temp match / $\sigma_\\textrm{rest}$ mock spec) - 1'
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['lineS2N_rf'][goodFratio]
        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='plus',
                                                       colortype='s2n',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)


        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_Ftot_vs_Ratio_FluxRatio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = (summarydat['Fratio_temp'][goodFratio]/summarydat['Fratio_spec'][goodFratio]) - 1.0
        yvalues  = (summarydat['Ftot_temp_sum'][goodFratio]/summarydat['Ftot_spec_intr'][goodFratio]) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        ylabel   = '(Ftot temp match / Ftot mock spec) - 1 '
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]
        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='plus',colortype='Sigma',
                                                       cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_Ftot_vs_Ratio_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = (summarydat['sigma_temp_ang_rf']/summarydat['sigma_spec_ang_rf']) - 1.0
    yvalues  = (summarydat['Ftot_temp_sum']/summarydat['Ftot_spec_intr']) - 1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '($\sigma_\\textrm{rest}$ temp match / $\sigma_\\textrm{rest}$ mock spec) - 1'
    ylabel   = '(Ftot temp match / Ftot mock spec) - 1 '
    cdatvec  = summarydat['lineS2N_rf']
    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='plus',colortype='s2n',
                                                   cdatvec=cdatvec,
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def match_mockspectra_to_templates(outputdir,CCwavewindow=25.0,plot_allCCresults=False,noisefree=False,
                                   spec2match='all',verbose=True):
    """
    Wrapper around match_mockspectrum_to_templates() to match templates to all mockspectra.


    --- INPUT ---
    outputdir          Directory to store picklefiles with cross-correlation results to
    CCwavewindow       Window around line to perform cross-correlations over (rest frame)
    plot_allCCresults  To plot all CC results set this to True. Plots will be stored in outputdir
    noisefree          To matcht the noise-free version of the mock spectra set to True
    spec2match         To only match a a subsample of spectra provide their parameter tabel line index here
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    outputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults/'
    uves.match_mockspectra_to_templates(outputdir)

    """
    if verbose: print(' - Decide which templates to fit to what mock spectra (through a dictionary)')
    mockVStemp_lines = {}
    mockVStemp_lines['Lya']             = ['Lya']
    mockVStemp_lines['CIIIdoublet']     = ['CIII']
    mockVStemp_lines['CIVdoublet']      = ['CIV']
    mockVStemp_lines['NVdoublet']       = ['NV']
    mockVStemp_lines['HeII']            = ['HeII']
    mockVStemp_lines['OIII1663doublet'] = ['OIII']
    mockVStemp_lines['MgIIdoublet']     = ['MgII']

    mockVStemp_lines['testsinglet'] = ['HeII']
    mockVStemp_lines['testdoublet'] = ['CIII']

    waverest     = {'Lya':1215.67, 'CIII':1908.0, 'CIV':1550.0, 'NV':1241.0, 'HeII':1640.0, 'OIII':1663.0, 'MgII':2800.}

    if verbose: print(' - Defining files to perform matches between (hardcoded)')
    parentdir    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/'
    # templatedir  = parentdir+'felis_templates_190816/'
    templatedir  = parentdir+'felis_templates_fromsetup/'
    paramfile    = parentdir+'mockspectra_setup_parametertable.txt'
    paramtable   = np.genfromtxt(paramfile,names=True,comments='#',skip_header=3,dtype='f,f,f,f,f,f,f,20a,20a,200a')

    if verbose: print(' - Crosscorrelating templates to spectra using FELIS')
    for ss, mockspec in enumerate(paramtable['specname']):
        if spec2match != 'all':
            if ss not in spec2match:
                continue
            else:
                print('------ spec2match: following spectrum in list so matching:')
                print('                   '+mockspec)

        if noisefree:
            mockspec = mockspec.replace('noisespec','noisestdNone')
        mockline  = mockspec.split('fromsetup_')[-1].split('_')[0]
        templines = mockVStemp_lines[mockline]

        for templine in templines:
            picklefile = outputdir+mockspec.split('/')[-1].replace('.fits',
                                                                   '_CCresults_template'+templine+
                                                                   '_matchto_spectrum'+mockline+'.pkl')
            templates  = glob.glob(templatedir+'uves_felis_template_*'+templine+'*.fits')

            if not plot_allCCresults:
                plotdir  = None

            windowcen  = CCwavewindow * (1+paramtable['redshift'][ss])
            ccdic      = felis.match_templates2specs(templates,[mockspec],[paramtable['redshift'][ss]],
                                                     picklefile,wavewindow=[windowcen],
                                                     plotdir=outputdir,wavecen_restframe=[waverest[templine]],
                                                     vshift=None,min_template_level=1e-4,
                                                     plot_allCCresults=plot_allCCresults,
                                                     subtract_spec_median=False)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_mocspecFELISresults_summary(summaryfile,picklefiles,overwrite=False,verbose=True):
    """
    Generate a summary of the template characteristics FELIS determined to match the mock spectra
    the best, i.e. with the highest S/N.

    --- INPUT ---
    summaryfile        Path and name to summary file to generate.
    picklefiles        List of FELIS pickle files to summarize.
    overwrite          Overwrite the summary file if it already exists?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    FELISoutputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults/'
    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_all.txt'
    picklefiles    = glob.glob(FELISoutputdir+'*.pkl')
    summarydat     = uves.gen_mocspecFELISresults_summary(summaryfile,picklefiles)

    """
    if verbose: print(' - Generating a summary of the best-fit template in:\n   '+summaryfile)
    if os.path.isfile(summaryfile) & (not overwrite):
        sys.exit(' Summary file '+summaryfile+' already exists and overwrite=False ')

    fout = open(summaryfile,'w')
    fout.write('# Summary of '+str(len(picklefiles))+' FELIS pickle files provided \n')
    fout.write('# File contains the characteristics of the templates with max S/N from the FELIS template fits \n')
    fout.write('# The summary was generated with uves.compate_mockspec_to_FELISresults() on '+kbs.DandTstr2()+' \n')
    fout.write('# \n')
    fout.write('# Columns are:\n')
    fout.write('# z_spec                     Instrinspic redshift of matched mock spectrum \n')
    fout.write('# z_temp_S2Nmax              Estimated redshift from template match\n')
    fout.write('# sigma_spec_ang_obs         Observed line width in angstroms for mock spectrum \n')
    fout.write('# sigma_spec_ang_rf          Rest-frame line width in angstroms for mock spectrum \n')
    fout.write('# sigma_temp_ang_rf          Rest-frame line width in angstroms for maxS/N template \n')
    fout.write('# Fratio_spec                Flux ratio of doublets in mock spectrum (line_lowwave/line_highwave) \n')
    fout.write('# Fratio_temp                Flux ratio of doublets in template      (line_lowwave/line_highwave) \n')
    fout.write('# Ftot_spec_intr             Intrinsic (input) total flux of mock spectrum \n')
    fout.write('# Ftot_spec_trapz            Integreated (trapz) total flux of noisy mock spectrum \n')
    fout.write('# Ftot_spec_trapz_err        Uncertainty on Ftot_spec_trapz (mock spectrum flux errors propogated) \n')
    fout.write('# Ftot_spec_sum              Integreated (sum*dwave) total flux of noisy mock spectrum \n')
    fout.write('# Ftot_spec_sum_err          Integreated (sum*dwave) total flux of noisy mock spectrum \n')
    fout.write('# Ftot_FELIS_S2Nmax          Estimated total flux from FELIS template match for maxS/N match \n')
    fout.write('# Ftot_FELIS_S2Nmax_err      Uncertainty on FELISflux_S2Nmax [sqrt(Ftot_FELIS_S2Nmax_variance)]\n')
    fout.write('# FELIS_S2Nmax               The S/N value of the (scaled) template match to the mock spectrum \n')
    fout.write('# Ngoodent                   The number of good pixels used in the cross correlation \n')
    fout.write('# chi2                       Chi^2 value between the mock spectrum and the template match \n')
    fout.write('# vshift_spec                Known intrinsic velocity shift of mock spectrum \n')
    fout.write('# vshift_CCmatch             Estimated velocity shift from template match '
               ' [ c*(z_spec-z_temp_S2Nmax)/(1+z_temp_S2Nmax) ]\n')
    fout.write('# lineS2N                    Estimated S/N of spectral feature within [lineS2Nwavemin,lineS2Nwavemin] \n')
    fout.write('# lineS2Nwavemin             Lower integration limit for S/N estimate \n')
    fout.write('# lineS2Nwavemax             Upper integration limit for S/N estimate \n')
    fout.write('# lineS2N_rf                 Estimated S/N (rest-frame) of spectral feature within [lineS2Nwavemin_rf,lineS2Nwavemin_rf] \n')
    fout.write('# lineS2Nwavemin_rf          Lower integration limit for rest-frame S/N estimate \n')
    fout.write('# lineS2Nwavemax_rf          Upper integration limit for rest-frame S/N estimate \n')
    fout.write('# Ftot_lineS2N               Total flux of spectral feature (sum(f)*dwave) used to estimate line S/N \n')
    fout.write('# Ftot_lineS2N_sigma         Square root of the variance/sqrt(Npix) of Ftot \n')
    fout.write('# spectrum                   The mock spectrum the templates were matched to \n')
    fout.write('# template                   The maxS/N template \n')
    fout.write('# \n')
    fout.write('# z_spec z_temp_S2Nmax sigma_spec_ang_obs sigma_spec_ang_rf sigma_temp_ang_rf Fratio_spec Fratio_temp Ftot_spec_intr Ftot_spec_trapz Ftot_spec_trapz_err Ftot_spec_sum Ftot_spec_sum_err Ftot_FELIS_S2Nmax Ftot_FELIS_S2Nmax_err FELIS_S2Nmax Ngoodent chi2 vshift_spec vshift_CCmatch lineS2N lineS2Nwavemin lineS2Nwavemax lineS2N_rf lineS2Nwavemin_rf lineS2Nwavemax_rf Ftot_lineS2N Ftot_lineS2N_sigma spectrum template \n')

    for pp, picklefile in enumerate(picklefiles):
        if verbose:
            infostr = ' - Summarizing picklefile  '+str("%.5d" % (pp+1))+' / '+str("%.5d" % len(picklefiles))+'     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        pkldic  = felis.load_picklefile(picklefile)

        Nsigma_integration = 3.0

        for specname in pkldic.keys():
            tempdic = pkldic[specname]

            #------ load info about max S/N template ------
            template, vshift_intr, vshift_match, Ftot_FELIS_S2Nmax, Ftot_FELIS_S2Nmax_err, \
            FELIS_S2Nmax, Ngoodent, chi2, z_spec, zS2Nmax =  \
                felis.getresult4maxS2N(pkldic,specname)

            #------ load matched spec and move to restframe ------
            s_wave   , s_flux   , s_df   , s_s2n    = felis.load_spectrum(specname,verbose=False)
            s_wave_rf, s_flux_rf, s_df_rf, s_s2n_rf = s_wave / (1+z_spec), s_flux * (1+z_spec), s_df * (1+z_spec), s_s2n

            #------ extract info on mock spectrum from fits headers ------
            spec_hdr        = afits.open(specname)[1].header
            spec_sigma_ang  = np.array([])
            spec_flux       = np.array([])
            spec_line_wave  = np.array([])
            for hdrkey in spec_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: spec_line_wave = np.append(spec_line_wave,spec_hdr[hdrkey])
                    if '_2' in hdrkey: spec_sigma_ang = np.append(spec_sigma_ang,spec_hdr[hdrkey])
                    if '_4' in hdrkey: spec_flux      = np.append(spec_flux,spec_hdr[hdrkey])

            spec_sigma_ang_obs = np.mean(spec_sigma_ang)
            spec_sigma_ang_rf  = spec_sigma_ang_obs / (1.0+z_spec)
            Ftot_spec_intr     = np.sum(spec_flux)
            if len(spec_flux) == 2:
                Fratio_spec = spec_flux[np.where(spec_line_wave == np.min(spec_line_wave))] / \
                              spec_flux[np.where(spec_line_wave == np.max(spec_line_wave))]
            else:
                Fratio_spec = 0.0

            #------ extract info on template from fits headers ------
            temp_hdr        = afits.open(template)[1].header
            temp_sigma_ang  = np.array([])
            temp_flux       = np.array([])
            temp_line_wave  = np.array([])
            for hdrkey in temp_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: temp_line_wave = np.append(temp_line_wave,temp_hdr[hdrkey])
                    if '_2' in hdrkey: temp_sigma_ang = np.append(temp_sigma_ang,temp_hdr[hdrkey])
                    if '_4' in hdrkey: temp_flux      = np.append(temp_flux,temp_hdr[hdrkey])

            temp_sigma_ang_rf  = np.mean(temp_sigma_ang)
            if len(temp_flux) == 2:
                Fratio_temp = temp_flux[np.where(temp_line_wave == np.min(temp_line_wave))] / \
                              temp_flux[np.where(temp_line_wave == np.max(temp_line_wave))]
            else:
                Fratio_temp = 0.0

            #------ integrate mock spectrum to obtain observed total fluxes (rest-frame) ------
            lineS2Nwavemin = np.min(spec_line_wave)-Nsigma_integration*spec_sigma_ang_obs
            lineS2Nwavemax = np.max(spec_line_wave)+Nsigma_integration*spec_sigma_ang_obs
            waverange      = [lineS2Nwavemin,lineS2Nwavemax]
            goodent        = np.where((s_wave >= waverange[0]) & (s_wave <= waverange[1]))

            lineS2Nwavemin_rf = np.min(spec_line_wave/(1.0+z_spec))-Nsigma_integration*spec_sigma_ang_rf
            lineS2Nwavemax_rf = np.max(spec_line_wave/(1.0+z_spec))+Nsigma_integration*spec_sigma_ang_rf
            waverange_rf      = [lineS2Nwavemin_rf,lineS2Nwavemax_rf]
            goodent_rf        = np.where((s_wave_rf >= waverange_rf[0]) & (s_wave_rf <= waverange_rf[1]))

            datarr_spec       = unumpy.uarray(s_flux_rf[goodent_rf], s_df_rf[goodent_rf])
            Ftot_trapz_spec   = np.trapz(datarr_spec,s_wave_rf[goodent_rf])
            Ftot_sum_spec     = np.sum(datarr_spec) * np.median(np.diff(s_wave_rf[goodent_rf]))

            #------ estimate signal to noise of emission feature ------
            Ftot_lineS2N, Ftot_lineS2N_var, Npixgood, lineS2N = uves.calc_1Dspec_S2N(s_wave,s_flux,s_df**2.0,
                                                                   waverange,verbose=False)
            Ftot_lineS2N_sigma = np.sqrt(Ftot_lineS2N_var)

            Ftot_rf, vartot_rf, Npixgood_rf, lineS2N_rf = uves.calc_1Dspec_S2N(s_wave_rf,s_flux_rf,s_df_rf**2.0,
                                                                               waverange_rf,verbose=False)

            if np.abs(Ftot_lineS2N-Ftot_rf) > 1.0:
                print(' - Ftot-Ftot_rf is larger than 1e-20cgs; stopping to enable investigation')
                pdb.set_trace()

            if np.abs(lineS2N-lineS2N_rf) > 0.1:
                print(' - linsS2N-lineS2N_ref is larger than 10%; stopping to enable investigation')
                pdb.set_trace()


            #------------ Writing to output file ------------
            outstr = str("%7.4f" % z_spec)+'  '+\
                     str("%7.4f" % zS2Nmax)+'      '+\
                     str("%7.4f" % spec_sigma_ang_obs)+'  '+\
                     str("%7.4f" % spec_sigma_ang_rf)+'  '+\
                     str("%7.4f" % temp_sigma_ang_rf)+'      '+\
                     str("%7.2f" % Fratio_spec)+'  '+\
                     str("%7.2f" % Fratio_temp)+'      '+\
                     str("%12.4f" % Ftot_spec_intr)+'  '+\
                     str("%12.4f" % Ftot_trapz_spec.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_trapz_spec.std_dev)+'  '+\
                     str("%12.4f" % Ftot_sum_spec.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_sum_spec.std_dev)+'  '+\
                     str("%12.4f" % Ftot_FELIS_S2Nmax)+'  '+\
                     str("%12.4f" % Ftot_FELIS_S2Nmax_err)+'  '+\
                     str("%12.4f" % FELIS_S2Nmax)+'  '+\
                     str("%12.4f" % Ngoodent)+'  '+\
                     str("%12.4f" % chi2)+'  '+\
                     str("%12.4f" % vshift_intr)+'  '+\
                     str("%12.4f" % vshift_match)+'      '+\
                     str("%12.4f" % lineS2N)+'  '+\
                     str("%12.4f" % lineS2Nwavemin)+'  '+\
                     str("%12.4f" % lineS2Nwavemax)+'  '+\
                     str("%12.4f" % lineS2N_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemin_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemax_rf)+'  '+\
                     str("%12.4f" % Ftot_lineS2N)+'  '+\
                     str("%12.4f" % Ftot_lineS2N_sigma)+'  '+\
                     specname+'  '+\
                     template+'  '
            fout.write(outstr+'\n')
    if verbose: print('\n   ...done')
    fout.close()

    fmt = 'f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=34,dtype=fmt,comments='#',names=True)
    return summarydat

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_mocspecFELISresults_summary(summaryfile,plotbasename,colortype='lineS2N_rf',histaxes=False,Nbins=50,
                                     overwrite=False,verbose=True):
    """
    plotting and evaluating the output from uves.gen_mocspecFELISresults_summary()

    --- INPUT ---
    summaryfile        Path and name to summary file to evaluate
    plotbasename       The based name for the plots to generate (incl. output directory)
    overwrite          Overwrite the plots if they already exist?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary.txt'
    plotbasename   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_plots/190815test_'
    uves.plot_mocspecFELISresults_summary(summaryfile,plotbasename)

    """
    if verbose: print(' - Loading and plotting the content of \n   '+summaryfile)
    fmt = 'f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=34,dtype=fmt,comments='#',names=True)
    specnumber = np.arange(len(summarydat))+1.0


    line         = summaryfile.split('cgs_')[-1].split('19')[0].lower()

    sigmaerrval  = {'ciii':0.1, 'civ':0.1, 'siiii':0.1, 'nv':0.1, 'mgii':0.1, 'oiii':0.1, 'heii':0.1, 'lya':0.3, 'all':0.1}
    fratioerrval = {'ciii':0.1, 'civ':0.2, 'siiii':0.1, 'nv':0.2, 'mgii':0.2, 'oiii':0.1, 'all':0.2}


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_z_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['z_spec']
    yvalues  = summarydat['z_temp_S2Nmax']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '$z$(mock spectrum)'
    ylabel   = '$z$(FELIS)'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[.1,600],yrange=[.1,600],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_S2N_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['lineS2N_rf']
    yvalues  = summarydat['FELIS_S2Nmax']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Rest-frame emission line S/N'
    ylabel   = 'FELIS template match S/N'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='Ftot_spec_intr',cdatvec=summarydat['Ftot_spec_intr'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[.1,600],yrange=[.1,600],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVStrapz'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_spec_trapz']
    yerr     = summarydat['Ftot_spec_trapz_err']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'Trapz int mock spectrum line flux [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVStrapz_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_spec_trapz']
    yerr     = summarydat['Ftot_spec_trapz_err']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'Trapz int mock spectrum line flux [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=summarydat['sigma_spec_ang_rf'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVSsum'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_spec_sum']
    yerr     = summarydat['Ftot_spec_sum_err']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'Sum*dwave mock spectrum line flux [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVSline'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_lineS2N']
    yerr     = summarydat['Ftot_lineS2N_sigma']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'Trapz int +/- 3 sigma mock spectrum line flux [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_FELIS_S2Nmax']
    yerr     = summarydat['Ftot_FELIS_S2Nmax_err']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'FELIS line flux estimate [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_trapzVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_trapz']
    xerr     = summarydat['Ftot_spec_trapz_err']
    yvalues  = summarydat['Ftot_FELIS_S2Nmax']
    yerr     = summarydat['Ftot_FELIS_S2Nmax_err']

    xlabel   = 'Trapz int mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'FELIS line flux estimate [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_trapzVSfelis_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_trapz']
    xerr     = summarydat['Ftot_spec_trapz_err']
    yvalues  = summarydat['Ftot_FELIS_S2Nmax']
    yerr     = summarydat['Ftot_FELIS_S2Nmax_err']

    xlabel   = 'Trapz int mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'FELIS line flux estimate [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=summarydat['sigma_spec_ang_rf'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_sigma_intrVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['sigma_spec_ang_rf']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['sigma_temp_ang_rf']
    yerr     = [None]*len(yvalues)

    xlabel   = '$\sigma$(mock spectrum) [\AA]'
    ylabel   = '$\sigma$(FELIS) [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=False,ylog=False,xrange=[0.0,2.7],yrange=[0.0,2.7],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_FtotVSFtot'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    yvalues  = summarydat['Ftot_spec_trapz']/summarydat['Ftot_FELIS_S2Nmax']-1.0
    xerr     = [None]*len(xvalues)
    yerr     = np.sqrt( (summarydat['Ftot_spec_trapz_err']   / summarydat['Ftot_spec_trapz'])**2 +
                        (summarydat['Ftot_FELIS_S2Nmax_err'] / summarydat['Ftot_FELIS_S2Nmax'])**2 )
    xlabel   = 'F(Intrinsic) [1e-20erg/s/cm$^2$]'
    ylabel   = 'F(mock spectrum)/F(FELIS) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_FtotVSFtot_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    yvalues  = summarydat['Ftot_spec_trapz']/summarydat['Ftot_FELIS_S2Nmax']-1.0
    xerr     = [None]*len(xvalues)
    yerr     = np.sqrt( (summarydat['Ftot_spec_trapz_err']   / summarydat['Ftot_spec_trapz'])**2 +
                        (summarydat['Ftot_FELIS_S2Nmax_err'] / summarydat['Ftot_FELIS_S2Nmax'])**2 )
    xlabel   = 'F(Intrinsic) [1e-20erg/s/cm$^2$]'
    ylabel   = 'F(mock spectrum)/F(FELIS) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=summarydat['sigma_spec_ang_rf'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_sigmaVSsigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['sigma_spec_ang_rf']
    yvalues  = summarydat['sigma_spec_ang_rf']/summarydat['sigma_temp_ang_rf']-1.0
    xerr     = [None]*len(xvalues)
    yerr     = np.sqrt( (summarydat['sigma_temp_ang_rf']*0.0+sigmaerrval[line] / summarydat['sigma_temp_ang_rf'])**2 +
                        (summarydat['sigma_spec_ang_rf']*0.0+0.0 / summarydat['sigma_spec_ang_rf'])**2 )

    xlabel   = '$\sigma$(mock spectrum) [\AA]'
    ylabel   = '$\sigma$(mock spectrum)/$\sigma$(FELIS) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_zVSz'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['z_spec']
    yvalues  = summarydat['z_spec']/summarydat['z_temp_S2Nmax']-1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)

    xlabel   = '$z$(mock spectrum)'
    ylabel   = '$z$(mock spectrum)/$z$(FELIS) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_zVSvshift'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['z_spec']
    yvalues  = summarydat['vshift_CCmatch']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)

    xlabel   = '$z$(mock spectrum)'
    ylabel   = '$\Delta v$/[km/s] = $c$[$z$(mock spectrum) - $z$(FELIS)] / [1+ $z$(FELIS)]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    #-------------------------------------------------------------------------------------------------------------------
    #-------------------------------------------------------------------------------------------------------------------
    goodFratio = np.where(summarydat['Fratio_spec'] > 0)
    if len(goodFratio[0]) > 0:
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'onetoone_Fratio_intrVSfelis'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['Fratio_spec'][goodFratio]
        xerr     = [None]*len(xvalues)
        yvalues  = summarydat['Fratio_temp'][goodFratio]
        yerr     = [fratioerrval[line]]*len(yvalues)

        xlabel   = 'Doublet flux ratio mock spec'
        ylabel   = 'Doublet flux ratio FELIS match'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='onetoone',
                                                       xlog=False,ylog=False,xrange=[0.0,3.3],yrange=[0.0,3.3],
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'horizontal_fluxratioVSfluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['Fratio_spec'][goodFratio]
        yvalues  = summarydat['Fratio_spec'][goodFratio]/summarydat['Fratio_temp'][goodFratio]-1.0
        xerr     = [None]*len(xvalues)
        yerr     = np.sqrt( (summarydat['Fratio_temp']*0.0+fratioerrval[line] / summarydat['Fratio_temp'])**2 +
                            (summarydat['Fratio_spec']*0.0+0.0 / summarydat['Fratio_spec'])**2 )

        xlabel   = 'Doublet flux ratio (FR) of mock spectrum'
        ylabel   = 'FR(mock spectrum)/FR(FELIS) - 1'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='horizontal',
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'horizontal_sigmaVSfluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['sigma_spec_ang_rf'][goodFratio]
        yvalues  = summarydat['Fratio_spec'][goodFratio]/summarydat['Fratio_temp'][goodFratio]-1.0
        xerr     = [None]*len(xvalues)
        yerr     = np.sqrt( (summarydat['Fratio_temp']*0.0+fratioerrval[line] / summarydat['Fratio_temp'])**2 +
                            (summarydat['Fratio_spec']*0.0+0.0 / summarydat['Fratio_spec'])**2 )

        xlabel   = '$\sigma$(mock spectrum) [\AA]'
        ylabel   = 'FR(mock spectrum)/FR(FELIS) - 1'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='horizontal',
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'horizontal_sigmafelisVSfluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['sigma_temp_ang_rf'][goodFratio]
        yvalues  = summarydat['Fratio_spec'][goodFratio]/summarydat['Fratio_temp'][goodFratio]-1.0
        xerr     = [None]*len(xvalues)
        yerr     = np.sqrt( (summarydat['Fratio_temp']*0.0+fratioerrval[line] / summarydat['Fratio_temp'])**2 +
                            (summarydat['Fratio_spec']*0.0+0.0 / summarydat['Fratio_spec'])**2 )

        xlabel   = '$\sigma$(FELIS) [\AA]'
        ylabel   = 'FR(mock spectrum)/FR(FELIS) - 1'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='horizontal',
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                              yrange=None,xrange=None,linetype='onetoone',ylog=False,xlog=False,
                                              colortype=None,colorcode=True,cdatvec=None,point_text=None,
                                              overwrite=False,verbose=True,
                                              histaxes=False,Nbins=50):
    """

    """
    if verbose: print(' - Setting up and generating plot')
    if os.path.isfile(plotname) & (not overwrite):
        if verbose: print('\n - WARNING: the plot '+plotname+' exists and overwrite=False so moving on \n')
    else:
        if histaxes:
            fig = plt.figure(1, figsize=(6, 6))
            # partially based on https://matplotlib.org/examples/pylab_examples/scatter_hist.html
            # definitions for the axes
            left, width = 0.15, 0.60
            bottom, height = 0.15, 0.60
            bottom_h = left_h = left + width + 0.01

            fig.subplots_adjust(wspace=0.1, hspace=0.1,left=left, right=left+width, bottom=bottom, top=bottom+height)
            rect_histx = [left, bottom_h, width, 0.2]
            rect_histy = [left_h, bottom, 0.2, height]
        else:
            fig = plt.figure(2, figsize=(6, 5))
            fig.subplots_adjust(wspace=0.1, hspace=0.1,left=0.15, right=0.97, bottom=0.15, top=0.97)
        Fsize    = 14
        lthick   = 2
        marksize = 4
        plt.rc('text', usetex=True)
        plt.rc('font', family='serif',size=Fsize)
        plt.rc('xtick', labelsize=Fsize)
        plt.rc('ytick', labelsize=Fsize)
        plt.clf()
        plt.ioff()
        #plt.title(inforstr[:-2],fontsize=Fsize)

        if colorcode:
            cmap    = plt.cm.get_cmap('viridis_r')

            if cdatvec is None:
                cdatvec = summarydat[colortype]

            if colortype.lower() == 'redshift':
                clabel  = '$z$'
                cmin    = 1.4
                cmax    = 6.2
                cextend = 'neither'
            elif colortype.lower() == 's2nfelis':
                clabel  = 'S/N(FELIS)'
                cmin    = 3.0
                cmax    = 10.0
                cextend = 'both'
            elif colortype.lower() == 's2':
                clabel  = 'S/N'
                cmin    = 3.0
                cmax    = 10.0
                cextend = 'both'
            elif colortype.lower() == 'vshift':
                clabel  = 'Velocity shift (spec vs. template match) [km/s]'
                cmin    = 0.0
                cmax    = 200.0
                cextend = 'both'
            elif colortype.lower() == 'sigma':
                clabel  = '$\sigma$ [\AA]'
                cmin    = np.min(cdatvec[np.isfinite(cdatvec)])
                cmax    = np.max(cdatvec[np.isfinite(cdatvec)])
                cextend = 'neither'
            elif colortype in summarydat.dtype.names:
                # if colortype == 'Fratio_spec': pdb.set_trace()
                clabel  = colortype.replace('_','\_')
                cmin    = np.min(cdatvec[np.isfinite(cdatvec)])
                cmax    = np.max(cdatvec[np.isfinite(cdatvec)])
                cextend = 'neither'
            else:
                sys.exit(' Color type '+colortype+' not enabled ')

            colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
            cmaparr = np.linspace(cmin, cmax, num=50)
            m       = plt.cm.ScalarMappable(cmap=cmap)
            m.set_array(cmaparr)

            if histaxes:
                x =1
                # cb      = plt.colorbar(m,extend='neither',orientation='vertical',
                #                        pad=0.01,aspect=40,shrink=0.3,anchor=(1.0,1.0),use_gridspec=False)
            else:
                cb      = plt.colorbar(m,extend=cextend,orientation='vertical',
                                       pad=0.01,aspect=40,shrink=1.0,anchor=(0.0,0.5),use_gridspec=False)
                cb.set_label(clabel)

            colvec   = []
            for ii,xval in enumerate(xvalues):
                colvec.append(cmap(colnorm(cdatvec[ii])))
            facecol  = colvec
            alphaval = 1.0
        else:
            colvec   = ['k']*len(xvalues)
            facecol  = ['gray']*len(xvalues)
            alphaval = 0.5

        for ii,xval in enumerate(xvalues): # loop necessary for coloring
            plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr[ii],yerr=yerr[ii],
                         marker='o',lw=lthick, markersize=marksize,alpha=alphaval,
                         markerfacecolor=facecol[ii],ecolor=colvec[ii],
                         markeredgecolor=colvec[ii],zorder=10)

        if linetype == 'horizontal':
            plt.plot([-1e5,1e5],[0,0],'--',color='gray',lw=lthick,zorder=5)
        elif linetype == 'onetoone':
            plt.plot([-1,1e5],[-1,1e5],'--',color='gray',lw=lthick,zorder=5)
        elif linetype == 'plus':
            plt.plot([-1e5,1e5],[0,0],'--',color='gray',lw=lthick,zorder=5)
            plt.plot([0,0],[-1e5,1e5],'--',color='gray',lw=lthick,zorder=5)
        else:
            sys.exit(' Unknown value of linetype = "'+linetype+'"')


        #--------- RANGES ---------
        if not xrange:
            xmin   = np.min(xvalues[np.isfinite(xvalues)])
            xmax   = np.max(xvalues[np.isfinite(xvalues)])
            dx     = xmax-xmin
            xrange = [xmin-dx*0.05,xmax+dx*0.05]
        plt.xlim(xrange)
        xminsys, xmaxsys = plt.xlim() # use to get automatically expanded axes if xmin = xmax

        if not yrange:
            ymin   = np.min(yvalues[np.isfinite(yvalues)])
            ymax   = np.max(yvalues[np.isfinite(yvalues)])
            dy     = ymax-ymin
            yrange = [ymin-dy*0.05,ymax+dy*0.05]
        plt.ylim(yrange)
        yminsys, ymaxsys = plt.ylim() # use to get automatically expanded axes if xmin = xmax

        for ii,xval in enumerate(xvalues): # loop necessary for coloring
            if point_text is not None:
                plt.text(xvalues[ii]*1.03,yvalues[ii]*1.03,
                         point_text[ii],color='white',fontsize=Fsize*0.2,zorder=20,
                         bbox=dict(boxstyle="round",edgecolor='k',facecolor=colvec[ii],linewidth=lthick*0.2))

        plt.xlabel(xlabel)
        plt.ylabel(ylabel)

        if ylog:
            plt.yscale('log')
        if xlog:
            plt.xscale('log')

        if histaxes:
            axHistx = plt.axes(rect_histx)
            axHisty = plt.axes(rect_histy)

            axHistx.xaxis.set_major_formatter(NullFormatter())
            axHisty.yaxis.set_major_formatter(NullFormatter())

            binwidth_x = np.diff([xminsys,xmaxsys])/Nbins
            bindefs    = np.arange(xminsys, xmaxsys+binwidth_x, binwidth_x)
            if xlog:
                bindefs = np.logspace(np.log10(bindefs[0]),np.log10(bindefs[-1]),len(bindefs))
                axHistx.set_xscale('log')

            axHistx.hist(xvalues, bins=bindefs,histtype='step',color='k')
            axHistx.set_xticks([])
            axHistx.set_xlim([xminsys,xmaxsys])

            binwidth_y = np.diff([yminsys,ymaxsys])/Nbins
            bindefs    = np.arange(yminsys, ymaxsys+binwidth_y, binwidth_y)
            if ylog:
                bindefs = np.logspace(np.log10(bindefs[0]),np.log10(bindefs[-1]),len(bindefs))
                axHisty.set_yscale('log')

            axHisty.hist(yvalues, bins=bindefs,histtype='step',color='k', orientation='horizontal')
            axHisty.set_yticks([])
            axHisty.set_ylim([yminsys,ymaxsys])

            cb      = plt.colorbar(m,extend=cextend,orientation='vertical',
                                   pad=0.01,aspect=10,shrink=0.35,anchor=(-15.0,1.58),use_gridspec=False)
            cb.set_label(clabel)
        else:
            pass

        #--------- LEGEND ---------
        # plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
        #              markerfacecolor='k',ecolor='k',markeredgecolor='black',zorder=1,label='MUSE-Wide LAE')
        # plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='*',lw=0, markersize=marksize*2,alpha=1.0,
        #              markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN')
        # plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='D',lw=0, markersize=marksize,alpha=1.0,
        #              markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN candidate')
        #
        # leg = plt.legend(fancybox=True, loc='upper center',prop={'size':Fsize/1.0},ncol=5,numpoints=1,
        #                  bbox_to_anchor=(0.5, 1.1),)  # add the legend
        # leg.get_frame().set_alpha(0.7)
        #--------------------------

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def match_tdosespectra_to_templates(spectra,outputdir,outkeystr='FELISmatch_RENAME',
                                    subtract_spec_median=True,
                                    lines2find=['CIII','CIV','HeII','NV','OIII','SiIII','MgII'],
                                    CCwavewindow=10.0,plot_allCCresults=False,
                                    verbose_FELIS=False,verbose=True):
    """
    Wrapper around felis.match_templates2specs() to match FELIS templates to a sample of TDOSE spectra.

    --- INPUT ---
    spectra                List of spectra to search for emission features via the FELIS template matches.
    outputdir              Directory to contiain the output (plots and *pkl files).
    outkeystr              String used in naming output.
    subtract_spec_median   Subtract the median during the template match to approximate the continuum in the
                           matched region of the spectrum.
    lines2find             List of lines to look for; determines what templates to match to each spectrum.
    CCwavewindow           Rest-frame width (central wavelengths +/- CCwavewindow) to match templates in.
    plot_allCCresults      Plot all template matches; timeconsuming so default is False. Can always be done afterwards.
    verbose_FELIS          Set to true to get vebosity of FELIS matching
    verbose                Set to true to get vebpsity of progress of the matching by the wrapper.

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    specdir   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/spectra_aperture/'
    spectra   = glob.glob(specdir+'tdose_spectrum*aperture_07209*.fits')
    outputdir = ' /Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/'
    uves.match_tdosespectra_to_templates(spectra,outputdir,outkeystr='FELISmatch2udf10_07209starUVESobj190913')

    """
    templatedir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/felis_templates_fromsetup/'
    uvesobjinfo = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits')[1].data
    MUSEwaves   = np.array([4790,9310])
    waverest    = {'lya':1215.67, 'ciii':1907.7, 'civ':1549.5, 'nv':1240.8,
                   'heii':1640.4, 'oiii':1663.5, 'mgii':2799.1, 'siiii':1887.4}
    matchno     = 0
    if verbose: print('\n - Will match the '+str(len(spectra))+' spectra to templates of the lines '+str(lines2find))
    for ss, spectrum in enumerate(spectra):
        obj_id       = int(spectrum.split('_')[-1].split('.fit')[0])
        obj_ent      = np.where(uvesobjinfo['id'] == obj_id)[0]
        if len(obj_ent) != 1:
            sys.exit('ERROR - There are '+str(len(obj_ent))+' matches in the UVES info file to object '+str(obj_id))

        obj_zLya      = uvesobjinfo['redshift'][obj_ent]
        MUSEwaves_rf  = MUSEwaves / (1.0 + obj_zLya)

        for templine in lines2find:
            Nmatch      = len(spectra)*len(lines2find)
            matchno     = matchno+1
            if verbose:
                infostr = '   FELIS match '+str("%.5d" % (matchno))+' / '+str("%.5d" % Nmatch)+'     '
                sys.stdout.write("%s\r" % infostr)
                sys.stdout.flush()

            linewave_rf  = waverest[templine.lower()]
            if (MUSEwaves_rf[0]+CCwavewindow < linewave_rf) & (linewave_rf < MUSEwaves_rf[1]-CCwavewindow):
                templates  = glob.glob(templatedir+'uves_felis_template_fromsetup_'+templine+'*.fits')
                if len(templates) == 0:
                    print('\n WARNING: No templates found for "lines2find"='+str(templine))
                else:
                    picklefile = outputdir+spectrum.split('/')[-1].replace('.fits','_CCresults_template'+
                                                                           templine+'_'+outkeystr+'.pkl')

                    wavewindow = CCwavewindow * (1+obj_zLya) # turn CCwavewindow into observed frame
                    ccdic      = felis.match_templates2specs(templates,[spectrum],[obj_zLya],
                                                             picklefile,wavewindow=[wavewindow],
                                                             plotdir=outputdir,
                                                             wavecen_restframe=[linewave_rf],
                                                             vshift=None,min_template_level=1e-4,
                                                             plot_allCCresults=plot_allCCresults,
                                                             subtract_spec_median=subtract_spec_median,
                                                             verbose=verbose_FELIS)
            else:
                pass
    if verbose: print('\n   done...\n')


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_tdosespecFELISresults_summary(summaryfile,picklefiles,overwrite=False,verbose=True):
    """
    Generate a summary of the template characteristics FELIS determined to match the tdose spectra
    the best, i.e. with the highest S/N.

    --- INPUT ---
    summaryfile        Path and name of summary file to generate.
    picklefiles        List of FELIS pickle files to summarize.
    overwrite          Overwrite the summary file if it already exists?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    FELISoutputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults/'
    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_all.txt'
    picklefiles    = glob.glob(FELISoutputdir+'*.pkl')
    summarydat     = uves.gen_mocspecFELISresults_summary(summaryfile,picklefiles)

    """
    if verbose: print(' - Generating a summary of the best-fit template in:\n   '+summaryfile)
    if os.path.isfile(summaryfile) & (not overwrite):
        sys.exit(' Summary file '+summaryfile+' already exists and overwrite=False ')

    fout = open(summaryfile,'w')
    fout.write('# Summary of '+str(len(picklefiles))+' FELIS pickle files provided \n')
    fout.write('# File contains the characteristics of the templates with max S/N from the FELIS template fits \n')
    fout.write('# The summary was generated with uves.gen_tdosespecFELISresults_summary() on '+kbs.DandTstr2()+' \n')
    fout.write('# \n')
    fout.write('# Columns are:\n')
    fout.write('# id                         ID of object matched \n')
    fout.write('# z_spec                     Instrinspic redshift of matched mock spectrum \n')
    fout.write('# z_temp_S2Nmax              Estimated redshift from template match\n')
    fout.write('# sigma_temp_ang_rf          Rest-frame line width in angstroms for maxS/N template \n')
    fout.write('# Fratio_temp                Flux ratio of doublets in template      (line_lowwave/line_highwave) \n')
    fout.write('# Ftot_FELIS_S2Nmax          Estimated total flux from FELIS template match for maxS/N match \n')
    fout.write('# Ftot_FELIS_S2Nmax_err      Uncertainty on FELISflux_S2Nmax [sqrt(Ftot_FELIS_S2Nmax_variance)]\n')
    fout.write('# FELIS_S2Nmax               The S/N value of the (scaled) template match to the mock spectrum \n')
    fout.write('# Ngoodent                   The number of good pixels used in the cross correlation \n')
    fout.write('# chi2                       Chi^2 value between the mock spectrum and the template match \n')
    fout.write('# vshift_spec                Known intrinsic velocity shift of mock spectrum \n')
    fout.write('# vshift_CCmatch             Estimated velocity shift from template match '
               ' [ c*(z_spec-z_temp_S2Nmax)/(1+z_temp_S2Nmax) ]\n')
    fout.write('# lineS2N_rf                 Estimated S/N (rest-frame) of spectral feature within [lineS2Nwavemin_rf,lineS2Nwavemin_rf] \n')
    fout.write('# lineS2Nwavemin_rf          Lower integration limit for rest-frame S/N estimate \n')
    fout.write('# lineS2Nwavemax_rf          Upper integration limit for rest-frame S/N estimate \n')
    fout.write('# Ftot_lineS2N_rf            Total flux of spectral feature (sum(f)*dwave) used to estimate line S/N \n')
    fout.write('# Ftot_lineS2N_sigma_rf      Square root of the variance/sqrt(Npix) of Ftot \n')
    fout.write('# spectrum                   The mock spectrum the templates were matched to \n')
    fout.write('# template                   The maxS/N template \n')
    fout.write('# \n')
    fout.write('# id z_spec z_temp_S2Nmax sigma_temp_ang_rf Fratio_temp Ftot_FELIS_S2Nmax Ftot_FELIS_S2Nmax_err FELIS_S2Nmax Ngoodent chi2 vshift_spec vshift_CCmatch lineS2N_rf lineS2Nwavemin_rf lineS2Nwavemax_rf Ftot_lineS2N_rf Ftot_lineS2N_sigma_rf spectrum template \n')

    for pp, picklefile in enumerate(picklefiles):
        if verbose:
            infostr = ' - Summarizing picklefile  '+str("%.5d" % (pp+1))+' / '+str("%.5d" % len(picklefiles))+'     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        pkldic  = felis.load_picklefile(picklefile)

        Nsigma_integration = 3.0

        for specname in pkldic.keys():
            tempdic = pkldic[specname]

            #------ load info about max S/N template ------
            template, vshift_intr, vshift_match, Ftot_FELIS_S2Nmax, Ftot_FELIS_S2Nmax_err, \
            FELIS_S2Nmax, Ngoodent, chi2, z_spec, zS2Nmax =  \
                felis.getresult4maxS2N(pkldic,specname)

            #------ load matched spec and move to restframe ------
            s_wave   , s_flux   , s_df   , s_s2n    = felis.load_spectrum(specname,verbose=False)
            s_wave_rf, s_flux_rf, s_df_rf, s_s2n_rf = s_wave / (1+z_spec), s_flux * (1+z_spec), s_df * (1+z_spec), s_s2n

            #------ extract info on mock spectrum from fits headers ------
            spec_hdr        = afits.open(specname)[1].header
            spec_sigma_ang  = np.array([])
            spec_flux       = np.array([])
            spec_line_wave  = np.array([])
            for hdrkey in spec_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: spec_line_wave = np.append(spec_line_wave,spec_hdr[hdrkey])
                    if '_2' in hdrkey: spec_sigma_ang = np.append(spec_sigma_ang,spec_hdr[hdrkey])
                    if '_4' in hdrkey: spec_flux      = np.append(spec_flux,spec_hdr[hdrkey])

            spec_sigma_ang_obs = np.mean(spec_sigma_ang)
            spec_sigma_ang_rf  = spec_sigma_ang_obs / (1.0+z_spec)
            Ftot_spec_intr     = np.sum(spec_flux)
            if len(spec_flux) == 2:
                Fratio_spec = spec_flux[np.where(spec_line_wave == np.min(spec_line_wave))] / \
                              spec_flux[np.where(spec_line_wave == np.max(spec_line_wave))]
            else:
                Fratio_spec = 0.0

            #------ extract info on template from fits headers ------
            temp_hdr        = afits.open(template)[1].header
            temp_sigma_ang  = np.array([])
            temp_flux       = np.array([])
            temp_line_wave  = np.array([])
            for hdrkey in temp_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: temp_line_wave = np.append(temp_line_wave,temp_hdr[hdrkey])
                    if '_2' in hdrkey: temp_sigma_ang = np.append(temp_sigma_ang,temp_hdr[hdrkey])
                    if '_4' in hdrkey: temp_flux      = np.append(temp_flux,temp_hdr[hdrkey])

            temp_sigma_ang_rf  = np.mean(temp_sigma_ang)
            if len(temp_flux) == 2:
                Fratio_temp = temp_flux[np.where(temp_line_wave == np.min(temp_line_wave))] / \
                              temp_flux[np.where(temp_line_wave == np.max(temp_line_wave))]
            else:
                Fratio_temp = 0.0

            #------ estimate signal to noise by integrating observed spectrum in restfram ------
            lineS2Nwavemin_rf = np.min(temp_line_wave)-Nsigma_integration*temp_sigma_ang_rf
            lineS2Nwavemax_rf = np.max(temp_line_wave)+Nsigma_integration*temp_sigma_ang_rf
            waverange_rf      = [lineS2Nwavemin_rf,lineS2Nwavemax_rf]
            Ftot_lineS2N_rf, Ftot_lineS2N_var_rf, Npixgood_rf, lineS2N_rf = \
                uves.calc_1Dspec_S2N(s_wave_rf,s_flux_rf,s_df_rf**2.0,waverange_rf,verbose=False)
            Ftot_lineS2N_sigma_rf = np.sqrt(Ftot_lineS2N_var_rf)

            #------------ Writing to output file ------------
            outstr = specname.split('_')[-1].split('.fit')[0]+'  '+\
                     str("%7.8f" % z_spec)+'  '+\
                     str("%7.8f" % zS2Nmax)+'      '+\
                     str("%7.4f" % temp_sigma_ang_rf)+'      '+\
                     str("%7.2f" % Fratio_temp)+'      '+\
                     str("%12.4f" % Ftot_FELIS_S2Nmax)+'  '+\
                     str("%12.4f" % Ftot_FELIS_S2Nmax_err)+'  '+\
                     str("%12.4f" % FELIS_S2Nmax)+'  '+\
                     str("%12.4f" % Ngoodent)+'  '+\
                     str("%12.4f" % chi2)+'  '+\
                     str("%12.4f" % vshift_intr)+'  '+\
                     str("%12.4f" % vshift_match)+'      '+\
                     str("%12.4f" % lineS2N_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemin_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemax_rf)+'  '+\
                     str("%12.4f" % Ftot_lineS2N_rf)+'  '+\
                     str("%12.4f" % Ftot_lineS2N_sigma_rf)+'  '+\
                     specname+'  '+\
                     template+'  '
            fout.write(outstr+'\n')
    if verbose: print('\n   ...done')
    fout.close()

    fmt = '12a,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=25,dtype=fmt,comments='#',names=True)
    return summarydat


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_tdosespecFELISresults_summary(summaryfile,plotbasename,colortype='lineS2N_rf',
                                       histaxes=True,Nbins=50,S2Ncut=[0.0,1000.0],
                                       overwrite=False,verbose=True):
    """
    plotting and evaluating the output from uves.gen_tdosespecFELISresults_summary()

    --- INPUT ---
    summaryfile        Path and name to summary file to evaluate
    plotbasename       The based name for the plots to generate (incl. output directory)
    overwrite          Overwrite the plots if they already exist?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    outdir         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/CCresults_summary/'
    summaryfile    = outdir+'CCresults_summary_templateCIII_FELISmatch2udf10_07209starUVESobj190913.txt'
    plotbasename   = outdir+'plottest_'
    uves.plot_mocspecFELISresults_summary(summaryfile,plotbasename)

    """
    if verbose: print(' - Loading and plotting the content of \n   '+summaryfile)
    fmt = '12a,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,200a,200a'
    summarydat  = np.genfromtxt(summaryfile,skip_header=25,dtype=fmt,comments='#',names=True)
    Nspecin     = len(summarydat['spectrum'])

    if verbose: print(' - Plotting FELIS matches in summary file\n   '+summaryfile+'\n   where the following holds:')
    if verbose: print('    S/N(FELIS)          = ['+str(S2Ncut[0])+','+str(S2Ncut[1])+']    (both ends included)')
    selection   = np.where( (summarydat['FELIS_S2Nmax'] >= S2Ncut[0]) & (summarydat['FELIS_S2Nmax'] <= S2Ncut[1]) )[0]
    Nselspec    = len(selection)
    if Nselspec > 0:
        selecteddat = summarydat[selection]
        if verbose: print(' - '+str(Nselspec)+'/'+str(Nspecin)+' matched spectra in summary satisfies the cuts\n')
    else:
        if verbose: print(' WARNING No FELIS matches found in summary file satisfying cuts; returning...')
        return

    specnumber   = np.arange(len(selecteddat))+1.0
    line         = summaryfile.split('template')[-1].split('_')[0].lower()
    sigmaerrval  = {'ciii':0.1, 'civ':0.1, 'siiii':0.1, 'nv':0.1, 'mgii':0.1, 'oiii':0.1, 'heii':0.1, 'lya':0.3, 'all':0.1}
    fratioerrval = {'ciii':0.1, 'civ':0.2, 'siiii':0.1, 'nv':0.2, 'mgii':0.2, 'oiii':0.1, 'all':0.2}

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_z_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['z_spec']
    yvalues  = selecteddat['z_temp_S2Nmax']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '$z$(spectrum)'
    ylabel   = '$z$(FELIS)'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=selecteddat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=False,ylog=False,xrange=[1,6.5],yrange=[1,6.5],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_S2N_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['lineS2N_rf']
    yvalues  = selecteddat['FELIS_S2Nmax']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Integrated spectrum flux S/N (+/-3$\sigma$)'
    ylabel   = 'S/N(FELIS)'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=selecteddat['sigma_temp_ang_rf'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[1.,200],yrange=[1.,200],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['Ftot_lineS2N_rf']
    xerr     = selecteddat['Ftot_lineS2N_sigma_rf']
    yvalues  = selecteddat['Ftot_FELIS_S2Nmax']
    yerr     = selecteddat['Ftot_FELIS_S2Nmax_err']

    xlabel   = 'Integrated spectrum flux (+/-3$\sigma$) [1e-20erg/s/cm$^2$]'
    ylabel   = 'F(FELIS) [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=selecteddat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_lineVSfelis_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['Ftot_lineS2N_rf']
    xerr     = selecteddat['Ftot_lineS2N_sigma_rf']
    yvalues  = selecteddat['Ftot_FELIS_S2Nmax']
    yerr     = selecteddat['Ftot_FELIS_S2Nmax_err']

    xlabel   = 'Integrated spectrum flux (+/-3$\sigma$) [1e-20erg/s/cm$^2$]'
    ylabel   = 'F(FELIS) [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=selecteddat['sigma_temp_ang_rf'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)




    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_sigmaVSfelisflux'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['sigma_temp_ang_rf']
    xerr     = [None]*len(xvalues)
    yvalues  = selecteddat['Ftot_FELIS_S2Nmax']
    yerr     = selecteddat['Ftot_FELIS_S2Nmax_err']

    xlabel   = '$\sigma$(FELIS) [\AA]'
    ylabel   = 'F(FELIS) [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=selecteddat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=False,ylog=True,xrange=[0.0,2.7],yrange=[10.0,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_zVSvshift'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['z_spec']
    yvalues  = summarydat['vshift_CCmatch']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)

    xlabel   = '$z$(spectrum)'
    ylabel   = '$\Delta v$/[km/s] = $c$[$z$(spectrum)-$z$(FELIS)] / [1+$z$(FELIS)]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_vshift_literatureVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['vshift_spec']
    yvalues  = summarydat['vshift_CCmatch']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)

    xlabel   = '$\Delta v$(Literature)/[km/s]'
    ylabel   = '$\Delta v$/[km/s] = $c$[$z$(spectrum)-$z$(FELIS)] / [1+$z$(FELIS)]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    #-------------------------------------------------------------------------------------------------------------------
    #-------------------------------------------------------------------------------------------------------------------
    goodFratio = np.where(selecteddat['Fratio_temp'] > 0)
    if len(goodFratio[0]) > 0:
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'onetoone_FratioVSs2n'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = selecteddat['Fratio_temp'][goodFratio]
        xerr     = [None]*len(xvalues)
        yvalues  = selecteddat['Ftot_FELIS_S2Nmax']
        yerr     = selecteddat['Ftot_FELIS_S2Nmax_err']

        xlabel   = 'FR(FELIS)'
        ylabel   = 'F(FELIS) [1e-20erg/s/cm$^2$]'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=selecteddat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='onetoone',
                                                       xlog=False,ylog=True,xrange=[0.0,3.3],yrange=[10.0,2e4],
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def calc_1Dspec_S2N(wavelengths,fluxes,variances,waverange,verbose=True):
    """
    Estimating the signal to noise ratio of a defined region in a 1D spectrum.
    Signal and noise is obtained by trapexoidal integration of the flux propogating errors.

    --- INPUT ---
    wavelengths      Wavelength vector of 1D spec
    fluxes           Flux values of pixels in 1D spec
    variance         Variances for fluxes in 1D spec
    waverange        Wavelenght range to estimate S/N over
    verbose          Toggle verbosity

    --- EXAMPLE OF USE ---
    import astropy.io.fits as afits
    import uvEmissionlineSearch as uves
    import glob

    specs = glob.glob('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra/uves_mock_spectrum_fromsetup_CIIIdoublet_noisespec_sigma0p50_skew0p00_Ftot85p71_Fratio1p40_z*fits')

    for spec in specs:
        redshift    = float(spec.split('io1p40_z')[-1].split('.fit')[0].replace('p','.'))
        wavelengths = afits.open(spec)[1].data['wave']
        fluxes      = afits.open(spec)[1].data['flux']
        variances   = afits.open(spec)[1].data['fluxerror']**2.0
        dwave_rest  = 5.0
        waverange   = [(1908.0-dwave_rest/2.)*(1.0+redshift),(1908.0+dwave_rest/2.)*(1.0+redshift)]

        print(' --- Calc for '+spec.split('/')[-1]+';\n --- waverange='+str(waverange))
        Ftot, vartot, Npix, S2N = uves.calc_1Dspec_S2N(wavelengths,fluxes,variances,waverange)

    """
    if verbose: print(' - Estimating S/N of 1D spectral range '+str(waverange))
    goodent = np.where((wavelengths >= waverange[0]) & (wavelengths <= waverange[1]))
    if len(goodent) == 0.0:
        if verbose: print(' - No pixels in wavelength range '+str(waverange)+'; returning 0s')
        Ftot, vartot, Npix, S2N = 0.0, 0.0, 0.0, 0.0
    else:
        Npix   = len(goodent[0])
        datarr = unumpy.uarray(fluxes[goodent], np.sqrt(variances[goodent]))
        Ftot   = np.trapz(datarr,wavelengths[goodent])
        S2N    = Ftot.nominal_value/Ftot.std_dev
        if verbose: print(' - Returning values  Ftot(trapz), vartot, Npix, S/N = '+
                          str(Ftot.nominal_value)+', '+str(Ftot.std_dev**2)+', '+str(Npix)+', '+str(S2N)+'')

    return Ftot.nominal_value, Ftot.std_dev**2, Npix, S2N

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def match_MUSEWideLAEs(templatedir,zrange=[1.516,3.874],datestr='dateofrun',line='CIII',
                       wave_restframe=1908.0,generateplots=False,specificobj=None,
                       lamwidth_restframe='dvoffset',runonallspecs=False,subtract_spec_median=True,verbose=True):
    """
    Wrapper around felis.match_templates2specs()

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    #list of IDs of test objects
    specificobj = [214002011,123048186,115003085]

    tempdir  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/felis_testing/'

    picklefileCIII = uves.match_MUSEWideLAEs(tempdir,zrange=[1.516,3.874],line='CIII',wave_restframe=1908.0,generateplots=False)
    picklefileCIV  = uves.match_MUSEWideLAEs(tempdir,zrange=[2.100,4.996],line='CIV',wave_restframe=1549.0,generateplots=False)

    ccdicCIII      = uves.load_picklefile(picklefileCIII)
    ccdicCIV       = uves.load_picklefile(picklefileCIV)


    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Grabbing TDOSE spectra and loading object info ')
    #specdir    = '/Volumes/DATABCKUP1/TDOSEextractions/171201_TDOSEextraction/Modelimg/tdose_spectra/'
    specdir    = '/Volumes/DATABCKUP1/TDOSEextractions/180824_TDOSEextraction_LAEs60fields/modelimg/tdose_spectra/'
    if runonallspecs:
        specs_all  = glob.glob(specdir+'tdose_spectrum_candels-*.fits')
    else:
        specs_all  = [specdir+'tdose_spectrum_candels-cdfs-04_modelimg_0104014050-0104014050.fits',
                      specdir+'tdose_spectrum_candels-cdfs-15_modelimg_0115003085-0115003085.fits',
                      specdir+'tdose_spectrum_candels-cdfs-06_modelimg_0106004019-0106004019.fits',
                      specdir+'tdose_spectrum_candels-cdfs-25_modelimg_0125042115-0125042115.fits']

    uvlinesdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/'
    z_all      = afits.open(uvlinesdir+'LAEinfo.fits')[1].data['redshift']
    id_all     = afits.open(uvlinesdir+'LAEinfo.fits')[1].data['id']
    try:
        vshift_all = afits.open(uvlinesdir+'LAEinfo.fits')[1].data['red_peak_shift_AV17_kms']
    except:
        vshift_all = afits.open(uvlinesdir+'LAEinfo.fits')[1].data['red_peak_shift_V18_kms']

    specs     = []
    objzs     = []
    vshift    = []

    for spec in specs_all:
        specid  = int(spec.split('_')[-1].split('-')[0])
        goodent = np.where(id_all == specid)
        if len(goodent) != 1:
            sys.exit(' ERROR: found '+str(len(goodent))+' matches to id = '+str(specid))

        zobj = z_all[goodent][0]
        if (zobj > zrange[0]) & (zobj < zrange[1]):

            if specificobj is not None:
                if specid not in specificobj: # skipping objects not in "specificobj" list
                    continue

            specs.append(spec)
            objzs.append(zobj)
            vshift.append(vshift_all[goodent][0])
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Grabbing templates ')
    #temps    = glob.glob(templatedir+'uves_felis_template_'+line+'doublet_sig_*_flux'+line+'1_1p0_flux*.fits')
    temps    = glob.glob(templatedir+'uves_felis_template_'+line+'*_sig_*.fits')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if lamwidth_restframe == 'dvoffset':
        if verbose: print(' - Getting wavelength range width (obs frame) corresponding to systemic velocity offset from AV15')
        lamwidth  = []
        wave_rest = [wave_restframe]*len(specs)
        for ss, spec in enumerate(specs):
            lam_obs, lam_offset, dlam = kbs.velocityoffset2dwave(objzs[ss],vshift[ss],wave_rest[ss])
            if dlam > 2.0:
                lamwidth.append(dlam*5.0)
            else:
                lamwidth.append(60.0)
    else:
        if verbose: print(' - Convert fixed rest-frame wavelength width to obs frame widths')
        lamwidth           = []
        wave_rest = [wave_restframe]*len(specs)
        for ss, spec in enumerate(specs):
            waveobs_low  = (wave_rest[ss]-lamwidth_restframe) * (1.0 + objzs[ss-1])
            waveobs_high = (wave_rest[ss]+lamwidth_restframe) * (1.0 + objzs[ss-1])
            lamwidth.append( (waveobs_high - waveobs_low) / 2. )

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Crosscorrelating templates to spectra using FELIS')
    picklefile = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/MUSEWideLAEs_CCresults'+datestr+'_'+line+'_RENAME_.pkl'
    if generateplots:
        plotdir            = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/MUSEwideLAE_FELISplots/'
        plot_allCCresults  = True
    else:
        plotdir            = None
        plot_allCCresults  = False
    ccdic      = felis.match_templates2specs(temps,specs,objzs,picklefile,wavewindow=lamwidth,plotdir=plotdir,
                                             wavecen_restframe=wave_rest,vshift=vshift,min_template_level=1e-4,
                                             plot_allCCresults=plot_allCCresults,subtract_spec_median=subtract_spec_median)
    return picklefile
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_FELISmatchOutput_OLD(picklefile,line='CIII',verbose=True,
                          plotdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/MUSEwideLAE_FELISplots/'):
    """
    Producing analytic plots based on a pickled output from match_templates2specs()

    --- EXAMPLE OF USE ---
    uves.plot_FELISmatchOutput('MUSEWideLAEs_CCresults180325_CIII_9templaterun.pkl',line='CIII')
    uves.plot_FELISmatchOutput('MUSEWideLAEs_CCresults180325_CIV_9templaterun.pkl',line='CIV')

    """
    CCdic   = felis.load_picklefile(picklefile)

    Nspecs  = len(CCdic.keys())
    if verbose: print(' - Loaded pickle file and found cross-correlation results for '+str(Nspecs)+' spectra')

    cr_arrmax        = []
    cn_arrmax        = []
    besttemp_fratios = []
    besttemp_sigmas  = []
    besttemp_zmax    = []
    v_offsetCC       = []
    v_offsetAH       = []

    NaNcount     = 0
    for ss, spec in enumerate(CCdic.keys()):
        cr_arr = CCdic[spec]['ccresultsarray']
        cr_arr = cr_arr[np.isfinite(cr_arr)]

        if len(cr_arr) == 0:
            if verbose: print(' WARNING No finite values in cross-correlation array for \n   '+spec)
            NaNcount = NaNcount + 1.0
            continue
        else:
            cr_arr = CCdic[spec]['ccresultsarray'] # need to re-define to get 2D
            cn_arr = CCdic[spec]['ccnormarray']    # need to re-define to get 2D

            try:
                cr_maxent = np.where(cr_arr == np.max(cr_arr))
                cn_maxent = np.where(cn_arr == np.max(cn_arr))

                if cn_arr[cn_maxent][0] < 0.6:
                    continue
                else:
                    cr_arrmax.append(cr_arr[cr_maxent][0])
                    cn_arrmax.append(cn_arr[cn_maxent][0])
            except:
                print('---->problems... cr array has no proper max (even though NaN arrays are igored)')
                pdb.set_trace()

            cr_besttemp  = cr_maxent[0][0]
            cn_besttemp  = cn_maxent[0][0]

            if cr_besttemp != cn_besttemp:
                print('---->problems... best temp do not match ')
                print('     '+spec)
                print('     Bestent: cr '+str(cr_maxent)+'  and cn '+str(cn_maxent)+'\n')
                #pdb.set_trace()

            besttemp = CCdic[spec]['templatevec'][cn_besttemp]

            besttempt_hdr = afits.open(besttemp)[1].header

            besttemp_fratios.append(besttempt_hdr['F'+line+'1_4']/besttempt_hdr['F'+line+'2_4'])
            besttemp_sigmas.append(besttempt_hdr['F'+line+'1_2'])

            zSysCC = CCdic[spec]['zCCmaxvec'][cn_besttemp]
            zLya    = CCdic[spec]['zLya']
            cc      = 299792.458 # km/s
            v_off   = ( (zLya - zSysCC) / (zSysCC + 1.0) ) * cc

            besttemp_zmax.append(zSysCC)
            v_offsetCC.append(v_off)
            v_offsetAH.append(CCdic[spec]['vshift'])

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_CCnormmax_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(cn_arrmax,color="r",bins=np.arange(-1,1,0.05),histtype="step",lw=1,label=r'')

    plt.xlabel(' Maximum value of normalized cross-correlation for '+str(Nspecs-NaNcount)+' spectra ('+str(NaNcount)+
               ' spectra with all-NaN cross correlation solutions)')
    # plt.ylabel(' S/N ')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_Fratio_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(besttemp_fratios,color="r",bins=30,histtype="step",lw=1,label=r'')

    if line == 'CIII':
        plt.xlabel(' Best matched template line flux ratio (CIII1907/CIII1909) ')
    elif line == 'CIV':
        plt.xlabel(' Best matched template line flux ratio (CIV1548/CIV1551) ')
    # plt.ylabel(' S/N ')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_linesigma_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(besttemp_sigmas,color="r",bins=30,histtype="step",lw=1,label=r'')

    plt.xlabel(' Best matched template line width (Gauss sigma) of '+line+' components [A]')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_voffset_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(v_offsetCC,color="r",bins=np.arange(-1000,1000,10.0),histtype="step",lw=1,label=r'Cross-Corr. prediction')
    hist = plt.hist(v_offsetAH,color="k",bins=np.arange(-1000,1000,10.0),histtype="step",lw=1,label=r'Verhamme prediction')

    plt.xlabel(' Velocity shift [km/s] ')

    leg = plt.legend(fancybox=True, loc='upper left',prop={'size':Fsize},ncol=1,numpoints=1)
    leg.get_frame().set_alpha(0.7)

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_FELISmatchOutput(picklefile,line='CIII',verbose=True,S2Ncut=3,  # only consider CC detections with S/N>S2Ncut
                          plotdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/MUSEwideLAE_FELISplots/',
                          zspecISzLya=False):
    """
    Producing analytic plots based on a pickled output from match_templates2specs()

    --- EXAMPLE OF USE ---
    uves.plot_FELISmatchOutput('MUSEWideLAEs_CCresults180325_CIII_9templaterun.pkl',line='CIII')
    uves.plot_FELISmatchOutput('MUSEWideLAEs_CCresults180325_CIV_9templaterun.pkl',line='CIV')

    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Ensure compatibility with FELIS output dictionaries from before 180912
    zkey = 'zspec'
    if zspecISzLya: zkey = 'zLya'
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    CCdic   = felis.load_picklefile(picklefile)

    Nspecs  = len(CCdic.keys())
    if verbose: print(' - Loaded pickle file and found cross-correlation results for '+str(Nspecs)+' spectra')

    spec_vec         = []
    max_S2N_vec      = []
    flux_vec         = []
    variance_vec     = []
    besttemp_fratios = []
    besttemp_sigmas  = []
    besttemp_zmax    = []
    v_offsetCC       = []
    v_offsetAH       = []

    for ss, spec in enumerate(CCdic.keys()):
        maxS2N   = np.max(CCdic[spec]['S2NCCmaxvec'])

        if maxS2N > S2Ncut:
            best_ent = np.where(CCdic[spec]['S2NCCmaxvec'] == maxS2N)[0]
            if len(best_ent) > 1:
                print('------> WARNING: More than one pixel with maximum S/N = '+str(maxS2N)+' -> choosing "first" template')
                best_ent = best_ent[0]
            besttemp = CCdic[spec]['templatevec'][best_ent][0]

            cc_best_S2N      = CCdic[spec]['ccresultsarr_S2N'][best_ent][0]
            cc_best_flux     = CCdic[spec]['ccresultsarray_flux'][best_ent][0]
            cc_best_variance = CCdic[spec]['ccresultsarray_variance'][best_ent][0]

            SNmax_ent        = np.where(cc_best_S2N == maxS2N)[0]

            if len(SNmax_ent) == 0:
                print('------> WARNING: No match to S/N in S/N vector. skipping data for key:')
                print('       '+spec)
            else:
                if len(np.atleast_1d(cc_best_flux)) == 1:
                    print('WARNING: CC flux vector only contains 1 value for '+spec)
                    continue
                else:
                    best_flux        = cc_best_flux[SNmax_ent]
                    best_variance    = cc_best_variance[SNmax_ent]

                besttempt_hdr = afits.open(besttemp)[1].header
                if 'fluxratio' in besttemp:
                    besttemp_fratios.append(besttempt_hdr['F'+line+'1_4']/besttempt_hdr['F'+line+'2_4'])
                    besttemp_sigmas.append(besttempt_hdr['F'+line+'1_2'])
                else:
                    besttemp_sigmas.append(besttempt_hdr['F'+line+'_2'])

                zSysCC  = CCdic[spec]['zCCmaxvec'][best_ent]
                zLya    = CCdic[spec][zkey]
                cc      = 299792.458 # km/s
                v_off   = ( (zLya - zSysCC) / (zSysCC + 1.0) ) * cc

                spec_vec.append(spec)
                max_S2N_vec.append(maxS2N)
                flux_vec.append(best_flux[0])
                variance_vec.append(best_variance[0])
                besttemp_zmax.append(zSysCC[0])
                v_offsetCC.append(v_off[0])
                v_offsetAH.append(CCdic[spec]['vshift'])

    if len(max_S2N_vec) == 0:
        sys.exit(' No detections passing the S/N cut of '+str(S2Ncut))

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if 'fluxratio' in besttemp:
        plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_Fratio_hist.pdf')
        if verbose: print(' - Setting up and generating plot')
        fig = plt.figure(figsize=(5, 5))
        fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
        Fsize    = 12
        lthick   = 2
        marksize = 4
        plt.rc('text', usetex=True)
        plt.rc('font', family='serif',size=Fsize)
        plt.rc('xtick', labelsize=Fsize)
        plt.rc('ytick', labelsize=Fsize)
        plt.clf()
        plt.ioff()

        hist = plt.hist(besttemp_fratios,color="r",bins=30,histtype="step",lw=1,label=r'')

        if line == 'CIII':
            lineratiostring = '(CIII1907/CIII1909)'
        elif line == 'CIV':
            lineratiostring = '(CIV1548/CIV1551)'
        elif line == 'OIII':
            lineratiostring = '(OIII1661/OIII1666)'
        elif line == 'NV':
            lineratiostring = '(NV1239/NV1243)'

        plt.xlabel(' Template line flux ratio '+lineratiostring)

        if verbose: print('   Saving plot to '+plotname)
        plt.savefig(plotname)
        plt.clf()
        plt.close('all')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_linesigma_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(besttemp_sigmas,color="r",bins=30,histtype="step",lw=1,label=r'')

    plt.xlabel(' Template line width (Gauss sigma) of '+line+' components [A]')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_voffset_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(v_offsetCC,color="r",bins=np.arange(-1000,1000,10.0),histtype="step",lw=1,label=r'Cross-Corr. prediction')
    hist = plt.hist(v_offsetAH,color="k",bins=np.arange(-1000,1000,10.0),histtype="step",lw=1,label=r'Verhamme prediction')

    plt.xlabel(' Velocity shift wrt. Ly$\\alpha$ [km/s] ')

    leg = plt.legend(fancybox=True, loc='upper left',prop={'size':Fsize},ncol=1,numpoints=1)
    leg.get_frame().set_alpha(0.7)

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_S2Nmax_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(max_S2N_vec,color="r",bins=30,histtype="step",lw=1,label=r'')

    plt.xlabel(' S/N ($>$'+str(S2Ncut)+' only)')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_FluxmaxVSS2Nmax.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.15, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    yerrbar = np.sqrt(variance_vec)
    plt.errorbar(max_S2N_vec,flux_vec, yerr=yerrbar,fmt='o', markerfacecolor='red', markeredgecolor='black',
                 ecolor='r', capthick=2)

    plt.xlabel(' S/N ($>$'+str(S2Ncut)+' only)')

    if line == 'CIII':
        tempindicator = 'CIII1907 + CIII1909'
    elif line == 'CIV':
        tempindicator = 'CIV1548 + CIV1551'
    elif line == 'OIII':
        tempindicator = 'OIII1661 + OIII1666'
    elif line == 'NV':
        tempindicator = 'NV1239 + NV1243'
    elif line == 'HEII':
        tempindicator = 'HeII1640'

    plt.ylabel(' $F_\\textrm{tot}$/[1e-20cgs] scaling for ('+tempindicator+')')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def check_neighbors(ids=[214063213],
                    sourcecatdir='/Volumes/DATABCKUP1/TDOSEextractions/180822_TDOSEextraction_LAEs60fields/tdose_sourcecats/',
                    modeldir='/Volumes/DATABCKUP1/TDOSEextractions/MW_LAEs_JKgalfitmodels/'):
    """

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.check_neighbors()

    """

    for id in ids:

        if str(id).startswith('2'):
            field = 'cosmos'
        else:
            field = 'cdfs'

        fieldno = str(id)[1:3]

        sc_generated = sourcecatdir+'tdose_sourcecat_LAEs_candels-'+field+'-'+str(fieldno)+'_id'+\
                       str(id)+'_cutout2p0x2p0arcsec.fits'
        sc_JKmodel   = modeldir+'model_acs_814w_candels-'+field+'-'+str(fieldno)+'_cut_v1.0_id'+\
                       str(id)+'_cutout2p0x2p0arcsec_sourcecatalog.fits'

        sc_gen = afits.open(sc_generated)[1].data
        sc_mod = afits.open(sc_JKmodel)[1].data

        print(' - - - - - - - - - - '+str(id)+' - - - - - - - - - - - ')
        print(" - SOURCE CATALOG GENERATED FROM CROSSMATCH TO MASTER SOURCE CAT")
        print('   '+str(sc_gen['PARENT_ID']))
        print('   '+str(sc_gen['ID']))
        print(" - SOURCE CATALOG CONTENT BASED ON JOSIE'S MODEL")
        print('   '+str(sc_mod['PARENT_ID']))
        print('   '+str(sc_mod['ID']))
        print(' ')
        try:
            print('   diff(PARENT_ID): '+str(sc_gen['PARENT_ID']-sc_mod['PARENT_ID']))
        except:
            print('   WARNING: mismatch in PARENT_ID source cats')
        try:
            print('   diff(ID): '+str(sc_gen['ID']-sc_mod['ID']))
        except:
            print('   WARNING: mismatch in ID source cats')
        print(' ')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def calculatelineratios_fromsummaryfiles(summaryfiles,lineindicators,outputfile, onesigmalimit=100.0, verbose=True):
    """
    Function to calculate the flux and line ratios for a set of summary files generated with
    containing the results from FELIS template matches to TDOSE spectra.

    Based (partially) on uves.calculatelineratios() below.

    --- INPUT ---
    summaryfiles     A list of summaryfiles to generate flux ratio output for
    lineindicators   List of strings indicating the content of the summary files (i.e. the lines that were
                     searched for with the FELIS template match). These are used to name output columns.
    outputfile       The ascii file to write results to.
    onesigmalimit    1 sigma flux limit to use for ratio limits (in units of spectra 10.0)
    verbose          Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves


    """
    if len(summaryfiles) != len(lineindicators):
        sys.exit('\nThe '+str(len(summaryfiles))+' provided do not match the '+str(len(lineindicators))+' provided \n')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Loading content of the '+str(lineindicators)+' summary files provided')
    dic_summarydat = {}
    fmt = '12a,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,200a,200a'
    for ss, sfile in enumerate(summaryfiles):
        summarydat  = np.genfromtxt(sfile,skip_header=25,dtype=fmt,comments='#',names=True)
        dic_summarydat[lineindicators[ss]] = summarydat

    ids = []
    for ll in lineindicators:
        ids = ids+list(dic_summarydat[ll]['id'])
    ids = np.unique(np.array(ids).astype(int))

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Initializing the output file: \n   '+outputfile)
    fout = open(outputfile,'w')
    fout.write('# Flux and line ratios estimated based on FELIS template match results summarized in:\n')
    fout.write('# '+str(summaryfiles)+'\n')
    fout.write('# \n')
    fout.write('# Upper and lower limits are given as negative values with uncertainty of +99 or -99, respectively. \n')
    fout.write('# For the limits a 1sigma limit of '+str(onesigmalimit)+' was used \n')
    fout.write('# \n')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Determine columns to fill in output')
    fluxratiodic = collections.OrderedDict()
    fluxratiodic['id'] = np.array([])
    for ll, numerator_line in enumerate(lineindicators):
        fluxratiodic['f_'+numerator_line]       = np.array([])
        fluxratiodic['ferr_'+numerator_line]    = np.array([])
        fluxratiodic['s2n_'+numerator_line]     = np.array([])
        fluxratiodic['sigma_'+numerator_line]   = np.array([])
        fluxratiodic['vshift_'+numerator_line]  = np.array([])

        if len(dic_summarydat[numerator_line]['id']) == 0:
            continue
        elif dic_summarydat[numerator_line]['Fratio_temp'][0] != 0:
            fluxratiodic['f1_'+numerator_line]      = np.array([])
            fluxratiodic['f1err_'+numerator_line]   = np.array([])
            fluxratiodic['f2_'+numerator_line]      = np.array([])
            fluxratiodic['f2err_'+numerator_line]   = np.array([])
            fluxratiodic['FR_'+numerator_line+'1'+numerator_line+'2']     = np.array([])
            fluxratiodic['FRerr_'+numerator_line+'1'+numerator_line+'2']  = np.array([])
            fluxratiodic['FRs2n_'+numerator_line+'1'+numerator_line+'2']  = np.array([])

        for kk, denominator_line in enumerate(lineindicators):
            if numerator_line == denominator_line:
                continue
            elif len(dic_summarydat[denominator_line]['id']) == 0:
                continue
            else:
                fluxratiodic['FR_'+numerator_line+denominator_line]     = np.array([])
                fluxratiodic['FRerr_'+numerator_line+denominator_line]  = np.array([])
                fluxratiodic['FRs2n_'+numerator_line+denominator_line]  = np.array([])

                if (dic_summarydat[numerator_line]['Fratio_temp'][0] != 0) & \
                        (dic_summarydat[denominator_line]['Fratio_temp'][0] == 0):
                    fluxratiodic['FR_'+numerator_line+'1'+denominator_line]     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'1'+denominator_line]  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'1'+denominator_line]  = np.array([])
                    fluxratiodic['FR_'+numerator_line+'2'+denominator_line]     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'2'+denominator_line]  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'2'+denominator_line]  = np.array([])
                elif (dic_summarydat[numerator_line]['Fratio_temp'][0] == 0) & \
                        (dic_summarydat[denominator_line]['Fratio_temp'][0] != 0):
                    fluxratiodic['FR_'+numerator_line+denominator_line+'1']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+denominator_line+'1']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+denominator_line+'1']  = np.array([])
                    fluxratiodic['FR_'+numerator_line+denominator_line+'2']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+denominator_line+'2']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+denominator_line+'2']  = np.array([])
                else:
                    fluxratiodic['FR_'+numerator_line+'1'+denominator_line+'1']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'1'+denominator_line+'1']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'1'+denominator_line+'1']  = np.array([])
                    fluxratiodic['FR_'+numerator_line+'1'+denominator_line+'2']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'1'+denominator_line+'2']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'1'+denominator_line+'2']  = np.array([])
                    fluxratiodic['FR_'+numerator_line+'2'+denominator_line+'1']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'2'+denominator_line+'1']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'2'+denominator_line+'1']  = np.array([])
                    fluxratiodic['FR_'+numerator_line+'2'+denominator_line+'2']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'2'+denominator_line+'2']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'2'+denominator_line+'2']  = np.array([])

    Ncols      = len(fluxratiodic.keys())
    # a simple dictionary containing the column locations in the output array (indexes)
    colents    = {}
    for oo, colname in enumerate(fluxratiodic.keys()):
        colents[colname] = oo
    if verbose: print('   The output file will contain '+str(Ncols)+' columns ')
    fout.write('# This file contains the following '+str(Ncols)+' columns:\n')
    fout.write('# '+' '.join(fluxratiodic.keys())+'  \n')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Filling the columns with data ')
    fluxratioarray = np.zeros([len(ids),Ncols])*np.nan
    for ii, id in enumerate(ids):
        if verbose: print('   Filling output for object '+str(id))
        fluxratioarray[ii,0] = float(id)

        for ll, numerator_line in enumerate(lineindicators):
            numerator_dat = dic_summarydat[numerator_line]
            ent_num       = np.where(numerator_dat['id'].astype(int) == id)[0]
            if len(ent_num) > 1:
                if verbose: print('       >>>WARNING<<<< '+str(id)+' appeared '+str(len(ent_num))+
                                  ' times in '+numerator_line+' summary ')
                continue
            elif len(ent_num) == 0:
                if verbose: print('       object '+str(id)+' not found in '+numerator_line+' summary (numerator)')
                continue

            fluxratioarray[ii,colents['f_'+numerator_line]]      = numerator_dat['Ftot_FELIS_S2Nmax'][ent_num]
            fluxratioarray[ii,colents['ferr_'+numerator_line]]   = numerator_dat['Ftot_FELIS_S2Nmax_err'][ent_num]
            fluxratioarray[ii,colents['s2n_'+numerator_line]]    = numerator_dat['FELIS_S2Nmax'][ent_num]
            fluxratioarray[ii,colents['sigma_'+numerator_line]]  = numerator_dat['sigma_temp_ang_rf'][ent_num]
            fluxratioarray[ii,colents['vshift_'+numerator_line]] = numerator_dat['vshift_CCmatch'][ent_num]

            if dic_summarydat[numerator_line]['Fratio_temp'][0] != 0:
                # error on q=|B|x where |B| is known exact is just dq=|B|dx
                f1      = numerator_dat['Ftot_FELIS_S2Nmax'][ent_num]     / (1 + 1/numerator_dat['Fratio_temp'][ent_num])
                f1err   = numerator_dat['Ftot_FELIS_S2Nmax_err'][ent_num] / (1 + 1/numerator_dat['Fratio_temp'][ent_num])
                f2      = f1    / numerator_dat['Fratio_temp'][ent_num]
                f2err   = f1err / numerator_dat['Fratio_temp'][ent_num]
                FR12    = f1/f2
                FR12err = np.sqrt((f1err/f1)**2+(f2err/f2)**2)

                fluxratioarray[ii,colents['f1_'+numerator_line]]                            = f1
                fluxratioarray[ii,colents['f1err_'+numerator_line]]                         = f1err
                fluxratioarray[ii,colents['f2_'+numerator_line]]                            = f2
                fluxratioarray[ii,colents['f2err_'+numerator_line]]                         = f2err
                fluxratioarray[ii,colents['FR_'+numerator_line+'1'+numerator_line+'2']]     = FR12
                fluxratioarray[ii,colents['FRerr_'+numerator_line+'1'+numerator_line+'2']]  = FR12err
                fluxratioarray[ii,colents['FRs2n_'+numerator_line+'1'+numerator_line+'2']]  = FR12/FR12err

            for kk, denominator_line in enumerate(lineindicators):
                denominator_dat = dic_summarydat[denominator_line]
                ent_denom       = np.where(denominator_dat['id'].astype(int) == id)[0]
                if len(ent_denom) > 1:
                    if verbose: print('       >>>WARNING<<<< '+str(id)+' appeared '+str(len(ent_denom))+
                                      ' times in '+numerator_line+' summary ')
                    continue
                elif len(ent_denom) == 0:
                    if verbose: print('       object '+str(id)+' not found in '+denominator_line+' summary (denominator) ')
                    continue

                if numerator_line == denominator_line:
                    continue
                else:
                    fluxratioarray[ii,colents['FR_'+numerator_line+denominator_line]]     = 55
                    fluxratioarray[ii,colents['FRerr_'+numerator_line+denominator_line]]  = 55
                    fluxratioarray[ii,colents['FRs2n_'+numerator_line+denominator_line]]  = 55

                    if (dic_summarydat[numerator_line]['Fratio_temp'][0] != 0) & \
                        (dic_summarydat[denominator_line]['Fratio_temp'][0] == 0):
                        fluxratioarray[ii,colents['FR_'+numerator_line+'1'+denominator_line]]     = 55
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'1'+denominator_line]]  = 55
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'1'+denominator_line]]  = 55
                        fluxratioarray[ii,colents['FR_'+numerator_line+'2'+denominator_line]]     = 55
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'2'+denominator_line]]  = 55
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'2'+denominator_line]]  = 55
                    elif (dic_summarydat[numerator_line]['Fratio_temp'][0] == 0) & \
                        (dic_summarydat[denominator_line]['Fratio_temp'][0] != 0):
                        fluxratioarray[ii,colents['FR_'+numerator_line+denominator_line+'1']]     = 55
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+denominator_line+'1']]  = 55
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+denominator_line+'1']]  = 55
                        fluxratioarray[ii,colents['FR_'+numerator_line+denominator_line+'2']]     = 55
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+denominator_line+'2']]  = 55
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+denominator_line+'2']]  = 55
                    else:
                        fluxratioarray[ii,colents['FR_'+numerator_line+'1'+denominator_line+'1']]     = 55
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'1'+denominator_line+'1']]  = 55
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'1'+denominator_line+'1']]  = 55
                        fluxratioarray[ii,colents['FR_'+numerator_line+'1'+denominator_line+'2']]     = 55
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'1'+denominator_line+'2']]  = 55
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'1'+denominator_line+'2']]  = 55
                        fluxratioarray[ii,colents['FR_'+numerator_line+'2'+denominator_line+'1']]     = 55
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'2'+denominator_line+'1']]  = 55
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'2'+denominator_line+'1']]  = 55
                        fluxratioarray[ii,colents['FR_'+numerator_line+'2'+denominator_line+'2']]     = 55
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'2'+denominator_line+'2']]  = 55
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'2'+denominator_line+'2']]  = 55


    for ll in np.arange(len(ids)):
        outstr = str(int(fluxratioarray[ll,0]))+' '+' '.join([str("%10.4f" % ff) for ff in fluxratioarray[ll,1:]])

        # outstr = ' '
        # for key in fluxratiodic.keys():
        #     if key =='id':
        #         outstr = outstr+str(fluxratiodic[key][ll])+' '
        #     else:
        #         outstr = outstr+str("%10.4f" % fluxratiodic[key][ll])+' '
        fout.write(outstr+' \n')
    fout.close()
    if verbose: print('\n - Wrote the flux ratio output to \n   '+outputfile)
    fmt = ','.join(Ncols*['f'])
    fluxratiodat = np.genfromtxt(outputfile,skip_header=7,dtype=fmt,comments='#',names=True)
    return fluxratiodat
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def calculatelineratios(outputfile='./fluxratioresults.txt', S2Nmaxrange=[5.0,100.0], zspecrange=[0.0,10.0],
                        voffsetrange=[-1500.0,1500.0], onesigmalimit=100.0, plotdir=None, verbose=True):
    """
    Function to calculate the flux and line ratios for a selection of objects with FELIS template matches
    satisfying a set of criteria based on the FELIS output pickle.

    --- INPUT ---
    outputfile       The ascii file to write results to
    S2Nmaxrange      Range of S/N template matches to unclude
    zspecrange       The range of redshifts for objects to include
    voffsetrange     Estimated velocity offset of line to include
    onesigmalimit    1 sigma flux limit to use for ratio limits (in units of spectra 10.0)
    plotdir          Provide path to output directory, to plot selected tempalte matches.
    verbose          Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.calculatelineratios(outputfile='./fluxratioresults.txt', S2Nmaxrange=[5.0,100.0], zspecrange=[0.0,10.0], voffsetrange=[-1500.0,1500.0], onesigmalimit=100.0)

    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - The estimated line flux ratios will be based on the following FELIS outputs ')
    picklepath  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/'
    pickleCIII  = picklepath+'MUSEWideLAEs_CCresultsdateofrun_CIII_all575specX180914templates.pkl'
    pickleCIV   = picklepath+'MUSEWideLAEs_CCresultsdateofrun_CIV_all575specX180914templates.pkl'
    pickleHeII  = picklepath+'MUSEWideLAEs_CCresultsdateofrun_HEII_all575specX180914templates.pkl'
    pickleOIII  = picklepath+'MUSEWideLAEs_CCresultsdateofrun_OIII_all575specX180914templates.pkl'
    pickleNV    = picklepath+'MUSEWideLAEs_CCresultsdateofrun_NV_all575specX180914templates.pkl'
    zspecISzLya = False

    if verbose: print('   '+pickleCIII)
    if verbose: print('   '+pickleCIV)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Performing selection on FELIS output ')

    goodkeysCIII    = felis.selection_from_picklefile(pickleCIII, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)
    goodkeysCIV     = felis.selection_from_picklefile(pickleCIV, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)
    goodkeysHeII    = felis.selection_from_picklefile(pickleHeII, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)
    goodkeysOIII    = felis.selection_from_picklefile(pickleOIII, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)
    goodkeysNV      = felis.selection_from_picklefile(pickleNV, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)

    goodkeys_unique = np.unique(goodkeysCIV+goodkeysCIII+goodkeysHeII+goodkeysOIII+goodkeysNV)

    loaddicCIII     = felis.load_picklefile(pickleCIII)
    loaddicCIV      = felis.load_picklefile(pickleCIV)
    loaddicHeII     = felis.load_picklefile(pickleHeII)
    loaddicOIII     = felis.load_picklefile(pickleOIII)
    loaddicNV       = felis.load_picklefile(pickleNV)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if os.path.isfile(outputfile):
        sys.exit('Ouptut file '+outputfile+' already exists')

    if verbose: print(' - Initializing the output file '+outputfile)
    fout = open(outputfile,'w')
    fout.write('# Flux and line ratios estimated based on FELIS template match results.\n')
    fout.write('# \n')
    fout.write('# Each template match was narrowed down to only contain matches with \n')
    fout.write('#   - z_spec         :  ['+str(zspecrange[0])+','+str(zspecrange[1])+']\n')
    fout.write('#   - max(S/N)       :  ['+str(S2Nmaxrange[0])+','+str(S2Nmaxrange[1])+']\n')
    fout.write('#   - voffset[km/s]  :  ['+str(voffsetrange[0])+','+str(voffsetrange[1])+']\n')
    fout.write('# \n')
    fout.write('# The selection was performed on the following pickle files outputted by FELIS \n')
    fout.write('#   - CIII: '+pickleCIII+'\n')
    fout.write('#     ('+str(len(goodkeysCIII))+' satisfying the cuts)\n')
    fout.write('#   - CIV: '+pickleCIV+'\n')
    fout.write('#     ('+str(len(goodkeysCIV))+' satisfying the cuts)\n')
    fout.write('#   - HeII: '+pickleHeII+'\n')
    fout.write('#     ('+str(len(goodkeysHeII))+' satisfying the cuts)\n')
    fout.write('#   - OIII: '+pickleOIII+'\n')
    fout.write('#     ('+str(len(goodkeysOIII))+' satisfying the cuts)\n')
    fout.write('#   - NV: '+pickleNV+'\n')
    fout.write('#     ('+str(len(goodkeysNV))+' satisfying the cuts)\n')
    fout.write('# \n')
    fout.write('# In total '+str(len(goodkeys_unique))+' template matches satisfied the cuts and are included in this file \n')
    fout.write('# \n')
    fout.write('# Upper and lower limits are given as negative values with uncertainty of +99 or -99, respectively. \n')
    fout.write('# For the limits a 1sigma limit of '+str(onesigmalimit)+' was used \n')
    fout.write('# \n')
    fout.write('# This file contains the following columns:\n')

    fluxratiodic = collections.OrderedDict()
    fluxratiodic['vshift_AV18']          = 999
    fluxratiodic['vshift_ciii1908']      = 999
    fluxratiodic['vshift_civ1550']       = 999
    fluxratiodic['vshift_heii1640']      = 999
    fluxratiodic['vshift_oiii1663']      = 999
    fluxratiodic['vshift_nv1241']        = 999

    fluxratiodic['f_ciii1908']           = 999
    fluxratiodic['ferr_ciii1908']        = 999
    fluxratiodic['S2N_ciii1908']         = 999
    fluxratiodic['sigma_ciii1908']       = 999

    fluxratiodic['f_civ1550']            = 999
    fluxratiodic['ferr_civ1550']         = 999
    fluxratiodic['S2N_civ1550']          = 999
    fluxratiodic['sigma_civ1550']        = 999

    fluxratiodic['f_heii1640']           = 999
    fluxratiodic['ferr_heii1640']        = 999
    fluxratiodic['S2N_heii1640']         = 999
    fluxratiodic['sigma_heii1640']       = 999

    fluxratiodic['f_oiii1663']           = 999
    fluxratiodic['ferr_oiii1663']        = 999
    fluxratiodic['S2N_oiii1663']         = 999
    fluxratiodic['sigma_oiii1663']       = 999

    fluxratiodic['f_nv1241']             = 999
    fluxratiodic['ferr_nv1241']          = 999
    fluxratiodic['S2N_nv1241']           = 999
    fluxratiodic['sigma_nv1241']         = 999

    fluxratiodic['ciii1907ciii1909']     = 999
    fluxratiodic['ciii1907ciii1909err']  = 999
    fluxratiodic['civ1549civ1551']       = 999
    fluxratiodic['civ1549civ1551err']    = 999
    fluxratiodic['oiii1661oiii1666']     = 999
    fluxratiodic['oiii1661oiii1666err']  = 999
    fluxratiodic['nv1239nv1243']         = 999
    fluxratiodic['nv1239nv1243err']      = 999

    fluxratiodic['civ1550ciii1908']      = 999
    fluxratiodic['civ1550ciii1908err']   = 999
    fluxratiodic['ciii1908heii1640']     = 999
    fluxratiodic['ciii1908heii1640err']  = 999
    fluxratiodic['civ1550heii1640']      = 999
    fluxratiodic['civ1550heii1640err']   = 999
    fluxratiodic['oiii1663heii1640']     = 999
    fluxratiodic['oiii1663heii1640err']  = 999
    fluxratiodic['nv1241heii1640']       = 999
    fluxratiodic['nv1241heii1640err']    = 999
    fluxratiodic['nv1241civ1550']        = 999
    fluxratiodic['nv1241civ1550err']     = 999

    hdrstr = '# id_musewide '
    for col in fluxratiodic.keys():
        hdrstr = hdrstr+col+' '
    hdrstr = hdrstr+'\n'
    fout.write(hdrstr)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Calculating line ratios based on FELIS template matches')
    for goodkey in goodkeys_unique:
        template_ciii1908, vshift_V18_ciii1908, vshift_ciii1908, f_ciii1908, \
        ferr_ciii1908, S2Nmax_ciii1908, Ngoodent_ciii1908, chi2_ciii1908, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicCIII,goodkey)
        template_civ1550, vshift_V18_civ1550, vshift_civ1550, f_civ1550, \
        ferr_civ1550, S2Nmax_civ1550, Ngoodent_civ1550, chi2_civ1550, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicCIV,goodkey)
        template_heii1640, vshift_V18_heii1640, vshift_heii1640, f_heii1640, \
        ferr_heii1640, S2Nmax_heii1640, Ngoodent_heii1640, chi2_heii1640, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicHeII,goodkey)
        template_oiii1663, vshift_V18_oiii1663, vshift_oiii1663, f_oiii1663, \
        ferr_oiii1663, S2Nmax_oiii1663, Ngoodent_oiii1663, chi2_oiii1663, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicOIII,goodkey)
        template_nv1241, vshift_V18_nv1241, vshift_nv1241, f_nv1241, \
        ferr_nv1241, S2Nmax_nv1241, Ngoodent_nv1241, chi2_nv1241, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicNV,goodkey)

        fluxratiodic['vshift_AV18']          = np.max(np.array([vshift_V18_ciii1908, vshift_V18_civ1550,
                                                                vshift_V18_heii1640, vshift_V18_oiii1663,
                                                                vshift_V18_nv1241])) # max to handle -99 values
        fluxratiodic['vshift_ciii1908']      = vshift_ciii1908
        fluxratiodic['vshift_civ1550']       = vshift_civ1550
        fluxratiodic['vshift_heii1640']      = vshift_heii1640
        fluxratiodic['vshift_oiii1663']      = vshift_oiii1663
        fluxratiodic['vshift_nv1241']        = vshift_nv1241


        if template_ciii1908 is 'None':
            f_ciii1908    = -1.0 * onesigmalimit
            ferr_ciii1908 = +99
        if template_civ1550 is 'None':
            f_civ1550     = -1.0 * onesigmalimit
            ferr_civ1550  = +99
        if template_heii1640 is 'None':
            f_heii1640    = -1.0 * onesigmalimit
            ferr_heii1640 = +99
        if template_oiii1663 is 'None':
            f_oiii1663    = -1.0 * onesigmalimit
            ferr_oiii1663 = +99
        if template_nv1241 is 'None':
            f_nv1241      = -1.0 * onesigmalimit
            ferr_nv1241   = +99

        fluxratiodic['f_ciii1908']           = f_ciii1908
        fluxratiodic['ferr_ciii1908']        = ferr_ciii1908
        # fluxratiodic['S2N_ciii1908_calc']    = f_ciii1908/ferr_ciii1908
        fluxratiodic['S2N_ciii1908']         = S2Nmax_ciii1908

        fluxratiodic['f_civ1550']            = f_civ1550
        fluxratiodic['ferr_civ1550']         = ferr_civ1550
        # fluxratiodic['S2N_civ1550_calc']     = f_civ1550/ferr_civ1550
        fluxratiodic['S2N_civ1550']          = S2Nmax_civ1550

        fluxratiodic['f_heii1640']           = f_heii1640
        fluxratiodic['ferr_heii1640']        = ferr_heii1640
        # fluxratiodic['S2N_heii1640_calc']    = f_heii1640/ferr_heii1640
        fluxratiodic['S2N_heii1640']         = S2Nmax_heii1640

        fluxratiodic['f_oiii1663']           = f_oiii1663
        fluxratiodic['ferr_oiii1663']        = ferr_oiii1663
        # fluxratiodic['S2N_oiii1663_calc']    = f_oiii1663/ferr_oiii1663
        fluxratiodic['S2N_oiii1663']         = S2Nmax_oiii1663

        fluxratiodic['f_nv1241']           = f_nv1241
        fluxratiodic['ferr_nv1241']        = ferr_nv1241
        # fluxratiodic['S2N_nv1241_calc']    = f_nv1241/ferr_nv1241
        fluxratiodic['S2N_nv1241']         = S2Nmax_nv1241

        if template_ciii1908 is 'None':
            fluxratiodic['ciii1907ciii1909']    = -99
            fluxratiodic['ciii1907ciii1909err'] = -99
            fluxratiodic['sigma_ciii1908']      = -99
        else:
            fluxratiodic['ciii1907ciii1909']    = float(template_ciii1908.split('fluxratio_')[-1].split('.')[0].replace('p','.'))
            fluxratiodic['ciii1907ciii1909err'] = ferr_ciii1908
            temp_sigma_ciii1908                 = float(template_ciii1908.split('sig_')[-1].split('_')[0].replace('p','.'))
            fluxratiodic['sigma_ciii1908']      = 299792.458 * 2.354 * temp_sigma_ciii1908 / 1908.0

        if template_civ1550 is 'None':
            fluxratiodic['civ1549civ1551']     = -99
            fluxratiodic['civ1549civ1551err']  = -99
            fluxratiodic['sigma_civ1550']      = -99
        else:
            fluxratiodic['civ1549civ1551']     = float(template_civ1550.split('fluxratio_')[-1].split('.')[0].replace('p','.'))
            fluxratiodic['civ1549civ1551err']  = ferr_civ1550
            temp_sigma_civ1550                 = float(template_civ1550.split('sig_')[-1].split('_')[0].replace('p','.'))
            fluxratiodic['sigma_civ1550']      = 299792.458 * 2.354 * temp_sigma_civ1550 / 1550.0

        if template_oiii1663 is 'None':
            fluxratiodic['oiii1661oiii1666']    = -99
            fluxratiodic['oiii1661oiii1666err'] = -99
            fluxratiodic['sigma_oiii1663']      = -99
        else:
            fluxratiodic['oiii1661oiii1666']    = float(template_oiii1663.split('fluxratio_')[-1].split('.')[0].replace('p','.'))
            fluxratiodic['oiii1661oiii1666err'] = ferr_oiii1663
            temp_sigma_oiii1663                 = float(template_oiii1663.split('sig_')[-1].split('_')[0].replace('p','.'))
            fluxratiodic['sigma_oiii1663']      = 299792.458 * 2.354 * temp_sigma_oiii1663 / 1550.0

        if template_nv1241 is 'None':
            fluxratiodic['nv1239nv1243']     = -99
            fluxratiodic['nv1239nv1243err']  = -99
            fluxratiodic['sigma_nv1241']     = -99
        else:
            fluxratiodic['nv1239nv1243']     = float(template_nv1241.split('fluxratio_')[-1].split('.')[0].replace('p','.'))
            fluxratiodic['nv1239nv1243err']  = ferr_nv1241
            temp_sigma_nv1241                = float(template_nv1241.split('sig_')[-1].split('_')[0].replace('p','.'))
            fluxratiodic['sigma_nv1241']     = 299792.458 * 2.354 * temp_sigma_nv1241 / 1550.0

        if template_heii1640 is 'None':
            fluxratiodic['sigma_heii1640']       = -99
        else:
            temp_sigma_heii1640                  = float(template_heii1640.split('sig_')[-1].split('.fi')[0].replace('p','.'))
            fluxratiodic['sigma_heii1640']       = 299792.458 * 2.354 * temp_sigma_heii1640 / 1640.0

        fluxratiodic['civ1550ciii1908'], fluxratiodic['civ1550ciii1908err'] = \
            uves.set_ratios(template_civ1550,template_ciii1908,f_civ1550,ferr_civ1550,f_ciii1908,ferr_ciii1908)

        fluxratiodic['ciii1908heii1640'], fluxratiodic['ciii1908heii1640err'] = \
            uves.set_ratios(template_ciii1908,template_heii1640,f_ciii1908,ferr_ciii1908,f_heii1640,ferr_heii1640)

        fluxratiodic['civ1550heii1640'], fluxratiodic['civ1550heii1640err'] = \
            uves.set_ratios(template_civ1550,template_heii1640,f_civ1550,ferr_civ1550,f_heii1640,ferr_heii1640)

        fluxratiodic['oiii1663heii1640'], fluxratiodic['oiii1663heii1640err'] = \
            uves.set_ratios(template_oiii1663,template_heii1640,f_oiii1663,ferr_oiii1663,f_heii1640,ferr_heii1640)

        fluxratiodic['nv1241heii1640'], fluxratiodic['nv1241heii1640err'] = \
            uves.set_ratios(template_nv1241,template_heii1640,f_nv1241,ferr_nv1241,f_heii1640,ferr_heii1640)

        fluxratiodic['nv1241civ1550'], fluxratiodic['nv1241civ1550err'] = \
            uves.set_ratios(template_nv1241,template_civ1550,f_nv1241,ferr_nv1241,f_civ1550,ferr_civ1550)

        outstr = ' '
        outstr = outstr+goodkey.split('-')[-1].split('.')[0][1:]+' '
        for col in fluxratiodic.keys():
            outstr = outstr+str("%12.2f" % fluxratiodic[col])+' '
        outstr = outstr+'\n'
        fout.write(outstr)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Wrote results to '+outputfile)
    fout.close()
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if plotdir is not None:
        if verbose: print(' - plotobjects=True so plotting selections to the directory:\n    '+plotdir)
        goodkeysall = [goodkeysCIII,goodkeysCIV,goodkeysHeII,goodkeysOIII,goodkeysNV]
        picklefiles = [pickleCIII,pickleCIV,pickleHeII,pickleOIII,pickleNV]
        lines = ['CIII1908','CIV1549','HeII1640','OIII1663','NV1241']

        for gg, goodkeys in enumerate(goodkeysall):
            plotnames = []
            plotnameinput = []
            for key in goodkeys:
                fname = key.split('/')[-1]
                plotnameinput.append(key.replace('.fits','_maxS2Ntemplatematch_'+lines[gg]+'.pdf'))
                plotnames.append(plotdir+fname.replace('.fits','_maxS2Ntemplatematch_'+lines[gg]+'.pdf'))

            felis.plot_picklefilecontent(goodkeys, picklefiles[gg], plotdir=plotdir, plotnames=plotnameinput,
                                         showspecerr=False, zspecISzLya=zspecISzLya)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def set_ratios(tempnum,tempdenom,numerator,numeratorerr,denominator,denominatorerr):
    """

    """
    if (tempnum is 'None') & (tempdenom is 'None' ):
        ratio      = -99
        ratioerr   = -99
    elif (tempnum is not 'None') & (tempdenom is not 'None' ):
        ratio      = numerator/denominator
        ratioerr   = np.sqrt(numerator**2+denominatorerr**2)
    elif (tempnum is 'None') & (tempdenom is not 'None' ):
        ratio      = numerator/denominator
        ratioerr   = -99
    elif (tempnum is not 'None') & (tempdenom is 'None' ):
        ratio      = numerator/denominator
        ratioerr   = +99
    else:
        print(' Something went wrong in uves.set_ratios() - setting trace to investigate')
        pdb.set_trace()

    return ratio, ratioerr
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def TDOSE_sourcecat_from_infofile(infofile,outputdir,minRaper=0.5,minCutwidth=4.5,goodmatchsep=0.25,overwrite=False,verbose=True):
    """
    Generate a TDOSE source catatalog (and catalog with intitial guesses for Gaussian modeling) from
    an infofile generated with uves.build_LAEfitstable().
    Based on the MUSEWideUtilities.TDOSE_sourcecat_from_*() scripts

    --- INPUT ---
    infofile          infofile from uves.build_LAEfitstable() to based source catalogs on
    outputdir         location of output
    goodmatchsep      Any match to the photometric catalog below goodmatchsep is replaced by MW object
    overwrite         Overwrite output files if they exists?
    verbose           Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits'
    outputdir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecatalogs_100fields/'
    uves.TDOSE_sourcecat_from_infofile(infofile,outputdir,minRaper=0.25,minCutwidth=4.5,goodmatchsep=0.25,overwrite=True,verbose=True)

    """
    if verbose: print(' - Generating TDOSE source catalog from the infofile:\n'+infofile+' '
                      '   Restricting source to FoV of individual reference images\n'
                      '   Output will be saved to '+outputdir)

    infodat              = afits.open(infofile)[1].data
    ids_all              = infodat['id']
    ras_all              = infodat['ra']
    decs_all             = infodat['dec']
    aimage_arr_inarcsec  = np.array([])

    skelcosmos     = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
    skelcosmosdat  = afits.open(skelcosmos)[1].data

    skelcdfs       = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
    skelcdfsdat    = afits.open(skelcdfs)[1].data

    rafelskicat    = '/Users/kschmidt/work/catalogs/rafelski/uvudf_rafelski_2015.fits'
    rafelskidat    = afits.open(rafelskicat)[1].data

    imgpath        = '/Users/kschmidt/work/images_MAST/MUSEWidePointings/'
    refimages      = glob.glob(imgpath+'*_814w_*cdfs*.fits')
    refimages      = refimages + glob.glob(imgpath+'*_814w_*cosmos*.fits')
    refimages      = refimages + glob.glob(imgpath+'*_160w_*hudf09*.fits')
    refimages      = refimages + glob.glob(imgpath+'*_775w_*udf-0*rot.fits')
    refimages      = refimages + ['/Users/kschmidt/work/images_MAST/MUSEWidePointings/acs_775w_udf-10_cut.fits']

    for refimage in refimages:
        if '_wht_' in refimage:
            continue
        else:
            if 'udf-' in refimage:
                outputnamebase = outputdir+refimage.split('/')[-1].\
                    replace('acs_775w','tdose_sourcecat_MWuves_acs_775w').replace('.fits','')
            elif 'hudf09' in refimage:
                outputnamebase = outputdir+refimage.split('/')[-1].\
                    replace('wfc3_160w','tdose_sourcecat_MWuves_wfc3_160w').replace('.fits','')
            else:
                outputnamebase = outputdir+refimage.split('/')[-1].\
                    replace('acs_814w','tdose_sourcecat_MWuves_acs_814w').replace('.fits','')

        refimgdata       = afits.open(refimage)[0].data
        refimghdr        = afits.open(refimage)[0].header

        if '-cosmos-' in refimage:
            skeltondat       = skelcosmosdat
        else:
            skeltondat       = skelcdfsdat

        if '_udf-' in refimage:
            match_sep          = infodat['sep_rafelski']
            match_id           = infodat['id_rafelski']
            phot_id_all        = rafelskidat['ID']
            phot_ra_all        = rafelskidat['RA']
            phot_dec_all       = rafelskidat['DEC']
            phot_flux_all      = rafelskidat['FLUX_ISO_F775W']
            phot_theta_all     = rafelskidat['THETA']
            phot_a_image_all   = np.sqrt(rafelskidat['AREAF']/np.pi/(1-rafelskidat['ELLIPTICITY']))
            phot_b_image_all   = (1.0-rafelskidat['ELLIPTICITY'])*phot_a_image_all
            arcsecPerPix_phot  = 0.03
            fivesigma_maglimit = 29.5  # f775w 5sigma limit
            onesigma_flux     = 10**((8.90-fivesigma_maglimit)/2.5) / 5.0 * 1e6 # flux in muJy
        else:
            match_sep          = infodat['sep_skelton']
            match_id           = infodat['id_skelton']
            phot_id_all        = skeltondat['id']
            phot_ra_all        = skeltondat['ra']
            phot_dec_all       = skeltondat['dec']
            phot_flux_all      = skeltondat['f_f160w']
            phot_theta_all     = skeltondat['theta_j2000']
            phot_a_image_all   = skeltondat['a_image']
            phot_b_image_all   = skeltondat['b_image']
            arcsecPerPix_phot  = 0.06
            if '-cosmos-' in refimage:
                fivesigma_maglimit = 25.8  # f160w 5sigma limit COSMOS
            else:
                fivesigma_maglimit = 26.4  # f160w 5sigma limit GOODS-S
            onesigma_flux     = 10**((25-fivesigma_maglimit)/2.5) / 5.

        fluxf_all   = []
        theta_all   = []
        a_image_all = []
        b_image_all = []

        matchedids = []
        for mm, mid in enumerate(match_id):
            MWid = ids_all[mm]
            firstdigit = int(str(MWid)[0])
            if '-cosmos-' in refimage:
                if firstdigit in [2]:
                    includeobj = True
                    if match_sep[mm] < goodmatchsep: matchedids.append(mid)
                else:
                    includeobj = False
            elif '_udf-0' in refimage:
                if firstdigit in [6]: # Include the mosaic full-deth ids; not the MWmock ids (firstdigit=5).
                    includeobj = True
                    if match_sep[mm] < goodmatchsep: matchedids.append(mid)
                else:
                    includeobj = False
            elif '_udf-10' in refimage:
                if firstdigit in [7]:
                    includeobj = True
                    if match_sep[mm] < goodmatchsep: matchedids.append(mid)
                else:
                    includeobj = False
            else:
                if firstdigit in [1,3,4]:
                    includeobj = True
                    if match_sep[mm] < goodmatchsep: matchedids.append(mid)
                else:
                    includeobj = False

            if includeobj:
                if  (match_sep[mm] < goodmatchsep) & (match_sep[mm] > 0.0):
                    phot_ent = np.where(phot_id_all== mid)[0]
                    fluxf_all.append(phot_flux_all[phot_ent][0])
                    theta_all.append(phot_theta_all[phot_ent][0])
                    a_image_all.append(phot_a_image_all[phot_ent][0])
                    b_image_all.append(phot_b_image_all[phot_ent][0])
                else:
                    fluxf_all.append(onesigma_flux)
                    theta_all.append(0.0)
                    a_image_all.append(2.0)
                    b_image_all.append(2.0)

                if len(aimage_arr_inarcsec) == 0:
                    aimage_arr_inarcsec = np.array([str(MWid),str(np.asarray(a_image_all)[-1]*arcsecPerPix_phot)])
                else:
                    aimage_arr_inarcsec = np.vstack([aimage_arr_inarcsec,
                                                     np.array([str(MWid),str(np.asarray(a_image_all)[-1]*arcsecPerPix_phot)])])
            else:
                fluxf_all.append(-99)
                theta_all.append(-99)
                a_image_all.append(-99)
                b_image_all.append(-99)

        # if '_udf-10' in refimage: pdb.set_trace()
        fluxf_all    = np.asarray(fluxf_all)
        theta_all    = np.asarray(theta_all)
        a_image_all  = np.asarray(a_image_all)
        b_image_all  = np.asarray(b_image_all)

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print(' - Finding objects within reference image field-of-view')
        if verbose: print('   (Estimating pixel positions using wcs info from header)')
        striphdr   = tu.strip_header(refimghdr,verbose=verbose,delkeys=['COMMENT','HISTORY','','A_ORDER','B_ORDER'])
        wcs_in     = wcs.WCS(striphdr)
        arcsecPerPix_refimg = wcs.utils.proj_plane_pixel_scales(wcs_in)*60*60

        skycoord   = SkyCoord(ras_all, decs_all, frame='fk5', unit='deg')
        pixcoord   = wcs.utils.skycoord_to_pixel(skycoord,wcs_in,origin=1)
        xpos       = pixcoord[0]
        ypos       = pixcoord[1]
        goodent    = np.where((xpos < refimghdr['NAXIS1']) & (xpos > 0) &
                              (ypos < refimghdr['NAXIS2']) & (ypos > 0) &
                              (a_image_all > 0.0))[0]

        if verbose: print('   (Make sure no 0s exist in a 6x6 pixel region around position, '
                          'i.e., ignoring 0-edges of ref images.)')
        Ngoodinit  = len(goodent)
        intxpos    = np.round(xpos).astype(int)
        intypos    = np.round(ypos).astype(int)
        for ent in goodent:
            if (refimgdata[np.max([intypos[ent]-5,0]):np.min([intypos[ent]+5,refimghdr['NAXIS2']-1]),
                np.max([intxpos[ent]-5,0]):np.min([intxpos[ent]+5,refimghdr['NAXIS1']-1])] == 0).any():
                goodent[np.where(goodent == ent)[0]] = -99
        Nedge     = len(np.where(goodent == -99)[0])
        goodent   = goodent[np.where(goodent != -99)[0]]
        if verbose: print('   (Ended up removing '+str(Nedge)+'/'+str(Ngoodinit)+
                          ' objects that fall in the edge region but are within the image FoV)')

        ids             = ids_all[goodent]
        ras             = ras_all[goodent]
        decs            = decs_all[goodent]
        x_image         = xpos[goodent]
        y_image         = ypos[goodent]
        fluxscale       = fluxf_all[goodent]
        a_image         = a_image_all[goodent] * arcsecPerPix_phot / np.mean(arcsecPerPix_refimg)
        b_image         = b_image_all[goodent] * arcsecPerPix_phot / np.mean(arcsecPerPix_refimg)
        theta           = theta_all[goodent]

        MWidsinfield    = ids
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print(' - Add photometric objects around MUSE-Wide objects of interest')

        skycoord   = SkyCoord(phot_ra_all, phot_dec_all, frame='fk5', unit='deg')
        pixcoord   = wcs.utils.skycoord_to_pixel(skycoord,wcs_in,origin=1)
        xpos       = pixcoord[0]
        ypos       = pixcoord[1]
        goodent    = np.where((xpos < refimghdr['NAXIS1']) & (xpos > 0) &
                              (ypos < refimghdr['NAXIS2']) & (ypos > 0) &
                              (phot_a_image_all > 0.0))[0]

        if verbose: print('   (Make sure no 0s exist in a 6x6 pixel region around position, '
                          'i.e., ignoring 0-edges of ref images.)')
        Ngoodinit  = len(goodent)
        intxpos    = np.round(xpos).astype(int)
        intypos    = np.round(ypos).astype(int)
        for ent in goodent:
            if (refimgdata[np.max([intypos[ent]-5,0]):np.min([intypos[ent]+5,refimghdr['NAXIS2']-1]),
                np.max([intxpos[ent]-5,0]):np.min([intxpos[ent]+5,refimghdr['NAXIS1']-1])] == 0).any() or \
                    (phot_id_all[ent] in matchedids):
                goodent[np.where(goodent == ent)[0]] = -99
        Nedge     = len(np.where(goodent == -99)[0])
        goodent   = goodent[np.where(goodent != -99)[0]]
        if verbose: print('   (Ended up removing '+str(Nedge)+'/'+str(Ngoodinit)+
                          ' objects that fall in the edge region but are within the image FoV)')

        ids        = np.append(ids,phot_id_all[goodent])
        ras        = np.append(ras,phot_ra_all[goodent])
        decs       = np.append(decs,phot_dec_all[goodent])
        x_image    = np.append(x_image,xpos[goodent])
        y_image    = np.append(y_image,ypos[goodent])
        fluxscale  = np.append(fluxscale,phot_flux_all[goodent])
        a_image    = np.append(a_image,phot_a_image_all[goodent]* arcsecPerPix_phot / np.mean(arcsecPerPix_refimg))
        b_image    = np.append(b_image,phot_b_image_all[goodent]* arcsecPerPix_phot / np.mean(arcsecPerPix_refimg))
        theta      = np.append(theta,phot_theta_all[goodent])
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        outtxt          = outputnamebase+'.txt'
        if (overwrite == False) & os.path.isfile(outtxt):
            sys.exit('Output ('+outtxt+') already exists and clobber=False')
        else:
            if verbose: print(' - Will save source catalog to '+outtxt+' (overwriting any existing files)')
            fout = open(outtxt,'w')
            fout.write('# TDOSE Source catalog generated with '
                       'uvEmissionlineSearch.TDOSE_sourcecat_from_infofile() on '+kbs.DandTstr2()+'\n')
            fout.write('# see objects with ds9 '+refimage+' -regions '+outputnamebase+'.reg \n')
            fout.write('# parent_id id ra dec x_image y_image fluxscale a_image b_image theta \n')
            for ii, id in enumerate(ids):
                fout.write(str(ids[ii])+' '+str(ids[ii])+' '+str(ras[ii])+' '+str(decs[ii])+' '+
                           str(x_image[ii])+' '+str(y_image[ii])+' '+str(fluxscale[ii])+' '+
                           str(a_image[ii])+' '+str(b_image[ii])+' '+str(theta[ii])+'  \n')

            fout.close()

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            regionfile = outtxt.replace('.txt','.reg')
            if verbose: print(' - Storing DS9 region file to '+regionfile)
            idsstr     = [str(id) for id in ids]
            tu.create_simpleDS9region(regionfile,ras,decs,color='cyan',
                                      circlesize=2.0 * a_image * np.mean(arcsecPerPix_refimg),
                                      textlist=idsstr,clobber=overwrite)
            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            outnamefits = outtxt.replace('.txt','.fits')
            if verbose: print(' - Saving fits version of source catalog to '+outnamefits)
            fitsfmt       = ['D']*10
            sourcecatfits = tu.ascii2fits(outtxt,asciinames=True,skip_header=2,fitsformat=fitsfmt,verbose=verbose)

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            extidcat      = outtxt.replace('.txt','_objects2extract.txt')
            if verbose: print(' - Will save ids of objects to extract in '+extidcat+' (overwriting any existing files)')
            fout = open(extidcat,'w')
            fout.write('# id \n')
            for mm, mwid in enumerate(MWidsinfield):
                fout.write(str(MWidsinfield[mm])+'  \n')
            fout.close()

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Creating cutoutsizes.txt and aperturesizes.txt for the TDOSE extractions along the way ')
    uid, uindex = np.unique(aimage_arr_inarcsec[:,0].astype(int), return_index=True)
    aimage_arr_inarcsec = aimage_arr_inarcsec[uindex,:]

    # ===== CTUOUT SIZES =====
    cut_outtxt  = outputdir+'cutoutsizes_MWuves_4xA_IMAGE.txt'
    fout        = open(cut_outtxt,'w')
    fout.write('# Cutout sizes of 4*A_IMAGE on each side (corresponding to twice the aperture diameter '
               'used for the aperture extractions) estimated with '
               'uvEmissionlineSearch.TDOSE_sourcecat_from_infofile() on '+kbs.DandTstr2()+'\n')
    fout.write('# \n')
    fout.write('# id xsize ysize \n')
    for aa, arrid in enumerate(aimage_arr_inarcsec[:,0]):
        cutoutwidth = 4.0 * float(aimage_arr_inarcsec[aa,1])
        if (cutoutwidth >= 0.0) & (cutoutwidth < minCutwidth):
            cutoutwidth = minCutwidth
        if cutoutwidth > 10.0:
            cutoutwidth = 10.0000

        fout.write(str(arrid)+' '+
                   str(cutoutwidth)+' '+
                   str(cutoutwidth)+'  \n')
    fout.close()

    # ===== APERTURE SIZES =====
    aper_outtxt = outputdir+'apertureradii_MWuves_2xA_IMAGE.txt'
    fout        = open(aper_outtxt,'w')
    fout.write('# Aperturesizes of 2*A_IMAGE estimated with '
               'uvEmissionlineSearch.TDOSE_sourcecat_from_infofile() on '+kbs.DandTstr2()+'\n')
    fout.write('# \n')
    fout.write('# id aperturesize \n')
    for aa, arrid in enumerate(aimage_arr_inarcsec[:,0]):
        Raper_arcsec = 2.0 * float(aimage_arr_inarcsec[aa,1])
        if (Raper_arcsec >= 0.0) & (Raper_arcsec < minRaper):
            Raper_arcsec = minRaper
        fout.write(str(arrid)+' '+str(Raper_arcsec)+'  \n')
    fout.close()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_infofile_nondetections(infofile,goodmatchsep=0.25,outdir=None,magcuts=None,withheader=False,
                               magtocuton=['f814wcand','f160w','f814w','f775w'],verbose=True):
    """
    Generate object id lists of objects from the infofile which are (likely) not detected in the imaging
    and which should therfore be extracted as point sources with the "nondetections" keyword in the TDOSE setup files.

    --- INPUT ---
    infofile          infofile from uves.build_LAEfitstable() to base source catalogs on
    goodmatchsep      Any match to the photometric catalog below goodmatchsep is considered detectable
    outdir            To save results to output ascii files instead of printing IDs to screen provide an output directory
    magcuts           Applying magnitude cuts to the selection. Provide a list of 4 cuts to be applied
                      to [cdfs,cdfs-parallel,cosmos,udf] photometry.
    withheader        TDOSE expects no header in id list, but setting withheader=True will add on with info to each file
                      either way (the summary file always contains a header with the info)
    magtocuton        Corresponding to the magcuts, provide the names of the filters to cut on
    verbose           Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits'
    outdir        = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/nondetection_lists/'
    uves.get_infofile_nondetections(infofile,goodmatchsep=0.25,outdir=outdir,magcuts=[27.2,26.4,26.5,29.5],verbose=True) # mag cuts are Skelton and Rafelski 5sigma limiting depths

    """
    if outdir is not None:
        out_summary = outdir+'uves_nondetections_summary.txt'
        fout = open(out_summary,'w')
        fout.write('# List of MUSE ids to treat as non-detections for TDOSE extractions generated with uves.get_infofile_nondetections() on '+kbs.DandTstr2()+'\n')
        fout.write('# Selection based on: \n')
        fout.write('# goodmatchsep                                = '+str(goodmatchsep)+' \n')
        fout.write('# magtocuton[cdfs,cdfs-parallel,cosmos,udf]   = '+str(magtocuton)+' \n')
        fout.write('# magcuts[cdfs,cdfs-parallel,cosmos,udf]      = '+str(magcuts)+' \n# \n')

    infodat        = afits.open(infofile)[1].data

    skelcosmos     = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
    skelcosmosdat  = afits.open(skelcosmos)[1].data

    skelcdfs       = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
    skelcdfsdat    = afits.open(skelcdfs)[1].data

    rafelskicat    = '/Users/kschmidt/work/catalogs/rafelski/uvudf_rafelski_2015.fits'
    rafelskidat    = afits.open(rafelskicat)[1].data

    pointings      = np.unique(infodat['pointing'])

    if magcuts is None:
        if verbose: print(' - WARNING: No magnitude cuts provided')
        magcuts = [35,35,35,35]
    print(' - Including objects with matches brighter than: \n   [cdfs_'+str(magtocuton[0])+',cdfs-parallels_'+str(magtocuton[1])+',cosmos_'+str(magtocuton[2])+',udf_'+str(magtocuton[3])+'] = '+str(magcuts))

    if verbose & (outdir is None):
        print(' - - - - - - - - - - - - - - - OBJECTS FOR NONDETECTION KEYWORD - - - - - - - - - - - - - - - ')
    for pp, pointing in enumerate(pointings):
        pointingent     = np.where(infodat['pointing'] == pointing)
        ids_point       = infodat['id'][pointingent]
        match_sep_Skel  = infodat['sep_skelton'][pointingent]
        match_id_Skel   = infodat['id_skelton'][pointingent]
        match_sep_Raf   = infodat['sep_rafelski'][pointingent]
        match_id_Raf    = infodat['id_rafelski'][pointingent]

        pointing_nondetections   = []
        pointing_nondetections_s = []  # seperate list for UDF skelton objects
        for ii, museid in enumerate(ids_point):

            # magcuts = [cdfs,cdfs-parallel,cosmos,udf,udf10]
            if 'cdfs' in pointing:
                match_id  = match_id_Skel[ii]
                match_sep = match_sep_Skel[ii]
                phot_ent  = np.where(skelcdfsdat['id'] == match_id)[0]
                phot_mag  = 25.0 - 2.5**np.log10(skelcdfsdat['f_'+magtocuton[0]][phot_ent])
                mag_cut   = magcuts[0]

            elif 'hudf09' in pointing:
                match_id  = match_id_Skel[ii]
                match_sep = match_sep_Skel[ii]
                phot_ent  = np.where(skelcdfsdat['id'] == match_id)[0]
                phot_mag  = 25.0 - 2.5**np.log10(skelcdfsdat['f_'+magtocuton[1]][phot_ent])
                mag_cut   = magcuts[1]

            elif 'cosmos' in pointing:
                match_id  = match_id_Skel[ii]
                match_sep = match_sep_Skel[ii]
                phot_ent  = np.where(skelcosmosdat['id'] == match_id)[0]
                phot_mag  = 25.0 - 2.5*np.log10(skelcosmosdat['f_'+magtocuton[2]][phot_ent])
                mag_cut   = magcuts[2]

            elif ('mosaic' in pointing) or ('udf-' in pointing):
                match_id  = match_id_Raf[ii]
                match_sep = match_sep_Raf[ii]
                phot_ent  = np.where(rafelskidat['ID'] == match_id)[0]
                phot_mag  = rafelskidat['MAG_'+magtocuton[1].upper()][phot_ent]
                mag_cut   = magcuts[3]

                match_id_s  = match_id_Skel[ii]
                match_sep_s = match_sep_Skel[ii]
                phot_ent_s  = np.where(skelcdfsdat['id'] == match_id_s)[0]
                phot_mag_s  = 25.0 - 2.5**np.log10(skelcdfsdat['f_'+magtocuton[0]][phot_ent_s])
                mag_cut_s   = magcuts[0]

            else:
                sys.exit(' The pointing '+pointing+' was not recognised')


            if match_sep > goodmatchsep:
                pointing_nondetections.append(museid)
            else:
                if phot_mag > mag_cut:
                    pointing_nondetections.append(museid)

            if ('mosaic' in pointing) or ('udf-' in pointing):
                if match_sep_s > goodmatchsep:
                    pointing_nondetections_s.append(museid)
                else:
                    if phot_mag_s > mag_cut_s:
                        pointing_nondetections.append(museid)

        if verbose & (outdir is None):
            print('   '+str("%30s" % pointing)+' (Nobj='+str("%5i" % len(pointing_nondetections))+
                  ')  '+str(pointing_nondetections))

            if ('mosaic' in pointing) or ('udf-' in pointing):
                if verbose: print('   '+str("%30s" % (pointing+'_SKELTON'))+' (Nobj='+str("%5i" % len(pointing_nondetections_s))+
                                  ')  '+str(pointing_nondetections_s))
        else:
            fout.write('   '+str("%30s" % pointing)+' (Nobj='+str("%5i" % len(pointing_nondetections))+
                       ')  '+str(pointing_nondetections)+'\n')

            if ('mosaic' in pointing) or ('udf-' in pointing):
                fout.write('   '+str("%30s" % (pointing+'_SKELTON'))+' (Nobj='+str("%5i" % len(pointing_nondetections_s))+
                           ')  '+str(pointing_nondetections_s)+'\n')

        out_pointing = outdir+'uves_nondetections_'+pointing+'.txt'
        fout_p = open(out_pointing,'w')
        if withheader:
            fout_p.write('# List of MUSE ids to treat as non-detections for TDOSE extractions generated with uves.get_infofile_nondetections() on '+kbs.DandTstr2()+'\n')
            fout_p.write('# Selection based on: \n')
            fout_p.write('# goodmatchsep           = '+str(goodmatchsep)+' \n')
        if 'cdfs' in pointing:
            if withheader:
                fout_p.write('# magtocuton[cdfs]   = '+str(magtocuton[0])+' \n')
                fout_p.write('# magcuts[cdfs]      = '+str(magcuts[0])+' \n# \n')
            for nonid in pointing_nondetections: fout_p.write(str(nonid)+'\n')
        elif 'hudf09' in pointing:
            if withheader:
                fout_p.write('# magtocuton[cdfs-parallel]   = '+str(magtocuton[1])+' \n')
                fout_p.write('# magcuts[cdfs-parallel]      = '+str(magcuts[1])+' \n# \n')
            for nonid in pointing_nondetections: fout_p.write(str(nonid)+'\n')
        elif 'cosmos' in pointing:
            if withheader:
                fout_p.write('# magtocuton[cosmos]   = '+str(magtocuton[2])+' \n')
                fout_p.write('# magcuts[cosmos]      = '+str(magcuts[2])+' \n# \n')
            for nonid in pointing_nondetections: fout_p.write(str(nonid)+'\n')
        elif ('mosaic' in pointing) or ('udf-' in pointing):
            if withheader:
                fout_p.write('# magtocuton[udf]   = '+str(magtocuton[3])+' \n')
                fout_p.write('# magcuts[udf]      = '+str(magcuts[3])+' \n# \n')
            for nonid in pointing_nondetections: fout_p.write(str(nonid)+'\n')

            out_pointing_skelton = outdir+'uves_nondetections_'+pointing+'_skeltonbased.txt'
            fout_pS = open(out_pointing_skelton,'w')
            if withheader:
                fout_pS.write('# List of MUSE ids to treat as non-detections for TDOSE extractions generated with uves.get_infofile_nondetections() on '+kbs.DandTstr2()+'\n')
                fout_pS.write('# Selection based on: \n')
                fout_pS.write('# goodmatchsep           = '+str(goodmatchsep)+' \n')
                fout_pS.write('# magtocuton[udf]   = '+str(magtocuton[3])+' \n')
                fout_pS.write('# magcuts[udf]      = '+str(magcuts[3])+' \n# \n')
            for nonid in pointing_nondetections_s: fout_pS.write(str(nonid)+'\n')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def build_noise_spectrum(outfile='/Users/kschmidt/work/MUSE/spectra_noise/median_eff_noise_spectrum_RENAME.fits',
                         overwrite=False,verbose=True):
    """
    Build a median noise spectrum for the MUSE-Wide fields

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.build_noise_spectrum(outfile='/Users/kschmidt/work/MUSE/median_eff_noise_spectrum.fits')

    """
    if os.path.isfile(outfile) & (not overwrite):
        sys.exit(' - The output file '+outfile+' exists and overwrite=False')

    #### UDF ####
    # datacubes = glob.glob('/Users/kschmidt/work/MUSE/QtClassify/*/udf-*_mfs-and-effvar-cube.fits')
    # noiseext  = 'EFFVAR'
    # waveunits = 'Angstrom'
    # fluxunits = '1e-20 erg/s/cm2/A'

    #### CDFS/COSMOS MUSE-Wide ####
    datacubes = glob.glob('/Volumes/DATABCKUP1/MUSE-Wide/DATACUBES/DATACUBE_candels-*_v1.0_dcbgc_effnoised.fits')
    noiseext  = 'EFF_STAT'
    waveunits = 'Angstrom'
    fluxunits = '1e-20 erg/s/cm2/A'

    if verbose: print(' - Generating median vec for: ')
    for dd, cube in enumerate(datacubes):
        if verbose: print('   '+cube+'  (spec '+str(dd+1)+'/'+str(len(datacubes))+')')
        effstatarr = afits.open(cube)[noiseext].data
        mediannoisevec = np.sqrt(np.nanmedian(np.nanmedian(effstatarr[:,150:250,150:250],axis=1),axis=1))
        if dd == 0:
            noisearr               = mediannoisevec
            cubehdr_0              = afits.open(cube)[noiseext].header
            wavevec_0              = np.arange(cubehdr_0['NAXIS3'])*cubehdr_0['CD3_3']+cubehdr_0['CRVAL3']
        else:
            cubehdr                = afits.open(cube)[noiseext].header
            wavevec                = np.arange(cubehdr['NAXIS3'])*cubehdr['CD3_3']+cubehdr['CRVAL3']
            func                   = scipy.interpolate.interp1d(wavevec,mediannoisevec,kind='linear',fill_value="extrapolate")
            mediannoisevec_interp  = func(wavevec_0)

            noisearr  = np.vstack([noisearr,mediannoisevec_interp])

    noisevec = np.nanmedian(noisearr,axis=0)

    felis.save_spectrum(outfile,wavevec,noisevec,noisevec*0.0,
                        headerinfo=None,waveunits=waveunits,fluxunits=fluxunits,
                        overwrite=overwrite,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def strip_cube_from_spectra(specdir,outputdir,overwrite=False,verbose=True):
    """
    Remoce source cube extension from spectra.

    --- INPUT ---
    specdir            Directory containing spectra to strip soource cube extension from
    outputdir          Directory to store the stripped spectra to.
    overwrite          Overwrite output if it already exists.
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    outputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/spectra_aperture/'
    specdir   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/spectra_test/original/'

    uves.strip_cube_from_spectra(specdir,outputdir,overwrite=False,verbose=True)

    """
    spectra   = glob.glob(specdir+'tdose_spectrum_*.fits')
    for spectrum in spectra:
        tu.strip_extension_from_fitsfile(spectrum,outputdir,removeextension='SOURCECUBE',overwrite=overwrite,verbose=verbose)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def checkfluxscales(specWnoise=True):
    """
    function to check conversion of output flux scales to integrated line fluxes


    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.checkfluxscales()

    """
    Nsigma  = 3.0

    testdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStesting/felistest190910/'
    if specWnoise:
        noisestr = 'noisespec'
        pklfile  = testdir+ 'uves_mock_spectrum_fromsetup_CIIIdoublet_noisespec_sigma2p00_skew0p00_' \
                            'Ftot1028p57_Fratio1p40_z2p70_CCresults_templateCIII_matchto_spectrumCIIIdoublet.pkl'
    else:
        noisestr = 'noisestdNone'
        pklfile  = testdir+ 'uves_mock_spectrum_fromsetup_CIIIdoublet_noisestdNone_sigma2p00_skew0p00_' \
                            'Ftot1028p57_Fratio1p40_z2p70_CCresults_templateCIII_matchto_spectrumCIIIdoublet.pkl'

    loaddic  = felis.load_picklefile(pklfile)
    spectrum = loaddic.keys()[0]

    template, vshift_intr, vshift_match, alpha, alphaerr, S2Nmax, Ngoodent, chi2, zspec, zS2Nmax = \
        felis.getresult4maxS2N(loaddic,spectrum,zspecISzLya=False)

    # - - - - - - - - - - - Load spec and temp info - - - - - - - - - - - - -
    specdat   = afits.open(spectrum)[1].data
    spechdr   = afits.open(spectrum)[1].header
    sigma_obs = spechdr['FLINE1_2']
    fluxline1 = spechdr['FLINE1_4']
    fluxline2 = spechdr['FLINE2_4']
    fluxratio = fluxline1/fluxline2

    threesigma_obs = sigma_obs * Nsigma
    wavemin = spechdr['FLINE1_1']-threesigma_obs
    wavemax = spechdr['FLINE2_1']+threesigma_obs

    tempdat = afits.open(template)[1].data
    temphdr = afits.open(template)[1].header
    temp_sigma     = temphdr['FLINE1_2']
    temp_fluxline1 = temphdr['FLINE1_4']
    temp_fluxline2 = temphdr['FLINE2_4']
    temp_fluxratio = temp_fluxline1/temp_fluxline2

    threesigma_rf = temp_sigma * Nsigma
    wavemin_rf = spechdr['FLINE1_1']/(1.0+zspec)-threesigma_rf
    wavemax_rf = spechdr['FLINE2_1']/(1.0+zspec)+threesigma_rf
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    specent   = np.where((specdat['wave'] > wavemin) & (specdat['wave'] < wavemax))[0]
    tempent   = np.where((tempdat['wave'] > wavemin_rf) & (tempdat['wave'] < wavemax_rf))[0]

    print(' --------- Observed frame: ----------')
    Ftot_spec_full = np.sum(specdat['flux'])*np.median(np.diff(specdat['wave']))
    Ftot_temp_full = np.sum(tempdat['flux']/(1+zspec))*np.median(np.diff(tempdat['wave']*(1+zspec)))
    print('Ftot_spec_full      = '+str(Ftot_spec_full))
    print('Ftot_temp_full      = '+str(Ftot_temp_full))

    Ftot_spec_cut = np.sum(specdat['flux'][specent])*np.median(np.diff(specdat['wave'][specent]))
    Ftot_temp_cut = np.sum(tempdat['flux'][tempent]/(1+zspec))*np.median(np.diff(tempdat['wave'][tempent]*(1+zspec)))
    print('Ftot_spec_cut       = '+str(Ftot_spec_cut))
    print('Ftot_temp_cut       = '+str(Ftot_temp_cut))

    Ftot_spec_cut_trapz = np.trapz(specdat['flux'][specent],specdat['wave'][specent])
    Ftot_temp_cut_trapz = np.trapz(tempdat['flux'][tempent]/(1+zspec),tempdat['wave'][tempent]*(1+zspec))
    print('Ftot_spec_cut_trapz = '+str(Ftot_spec_cut_trapz))
    print('Ftot_temp_cut_trapz = '+str(Ftot_temp_cut_trapz))

    #
    # print(' --------- Rest frame: ----------')
    # Ftot_spec_full = np.sum(specdat['flux']*(1+zspec))*np.median(np.diff(specdat['wave']/(1+zspec)))
    # Ftot_temp_full = np.sum(tempdat['flux'])*np.median(np.diff(tempdat['wave']))
    # Ftot_spec_cut = np.sum(specdat['flux'][specent]*(1+zspec))*np.median(np.diff(specdat['wave'][specent]/(1+zspec)))
    # Ftot_temp_cut = np.sum(tempdat['flux'][tempent])*np.median(np.diff(tempdat['wave'][tempent]))
    # print('Ftot_spec_full = '+str(Ftot_spec_full))
    # print('Ftot_temp_full = '+str(Ftot_temp_full))
    # print('Ftot_spec_cut = '+str(Ftot_spec_cut))
    # print('Ftot_temp_cut = '+str(Ftot_temp_cut))

    print(' --------- Values from headers: ----------')
    template_scaled               = tempdat['flux'] / (temp_fluxline1+temp_fluxline2) * alpha
    print('alpha +/- alphaerr     = '+str(alpha)+' +/- '+str(alphaerr))
    print('spec total flux        = '+str(fluxline1+fluxline2))
    print('temp total flux        = '+str(temp_fluxline1+temp_fluxline2))
    print('spec flux ratio        = '+str(fluxratio))
    print('temp flux ratio        = '+str(temp_fluxratio))

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    print(' --------- Plotting overview: ----------')
    import matplotlib.pyplot as plt
    fig = plt.figure(figsize=(6, 3))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    plt.plot(specdat['wave'],specdat['flux'],color='gray')
    plt.plot(tempdat['wave']*(1+zspec),template_scaled/(1+zspec),color='pink')

    plt.plot([wavemin,wavemin],[np.min(specdat['flux'][specent]),np.max(specdat['flux'][specent])],color='k',ls=':')
    plt.plot([wavemax,wavemax],[np.min(specdat['flux'][specent]),np.max(specdat['flux'][specent])],color='k',ls=':')
    plt.plot(specdat['wave'][specent],specdat['flux'][specent],color='k')

    plt.plot([wavemin_rf*(1+zspec),wavemin_rf*(1+zspec)],
             [np.min(template_scaled[tempent]/(1+zspec)),np.max(template_scaled[tempent]/(1+zspec))],color='red',ls=':')
    plt.plot([wavemax_rf*(1+zspec),wavemax_rf*(1+zspec)],
             [np.min(template_scaled[tempent]/(1+zspec)),np.max(template_scaled[tempent]/(1+zspec))],color='red',ls=':')
    plt.plot(tempdat['wave'][tempent]*(1+zspec),tempdat['flux'][tempent]/(1+zspec),color='green')

    plt.plot(tempdat['wave'][tempent]*(1+zspec),template_scaled[tempent]/(1+zspec),color='red')
    plt.ylim([-50,140])

    plotname = testdir+'fluxscalecheck_'+noisestr+'.pdf'
    plt.savefig(plotname)
    # plt.savefig('/Users/kschmidt/Desktop/fluxscalecheck_'+noisestr+'.pdf')
    print('Saved plot to '+plotname)
    plt.clf()


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_UDF10masedaobjcomparison(overwrite=False,verbose=True):
    """
    plotting information on FELIS match to Maseda UDF-10 CIII emitters

    --- INPUT ---
    overwrite          Overwrite the plots if they already exist?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves
    uves.plot_UDF10masedaobjcomparison(summaryfile,plotbasename)

    """
    outdir       = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/CCresults_summary/'

    summaryfile  = outdir+'CCresults_summary_templateCIII_FELISmatch2udf10masedaobj190913.txt'
    fmt          = 'f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,200a,200a'
    summarydat   = np.genfromtxt(summaryfile,skip_header=24,dtype=fmt,comments='#',names=True)
    sortindex_S  = np.argsort(summarydat['id'])
    Nspecin      = len(summarydat['spectrum'])

    masedainfo   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/masedaUDF10emitters.txt'
    fmt          = '12a,f,f,f,f,f,f,f,f,f,f,f'
    masedadat    = np.genfromtxt(masedainfo,skip_header=1,dtype=fmt,comments='#',names=True)
    sortindex_M  = np.argsort(masedadat['id_uves'])

    Nsigmaplot   = 3.0 # the size of the error bars to show

    plotbasename = outdir+'UDF10_CIIIemitters_Maseda17comparison'
    if verbose: print(' - Plotting FELIS matches in summary file\n   '+summaryfile+'\n   where the following holds:')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext    = 'Comparison_onetoone_Fciii'
    plotname   = plotbasename+nameext+'.pdf'
    xvalues    = masedadat['f_ciii'][sortindex_M]
    xerr       = masedadat['df_ciii'][sortindex_M]*Nsigmaplot
    yvalues    = summarydat['Ftot_FELIS_S2Nmax'][sortindex_S]
    yerr       = summarydat['Ftot_FELIS_S2Nmax_err'][sortindex_S]*Nsigmaplot
    xlabel     = 'Flux(CIII,Maseda)'
    ylabel     = 'Flux(CIII,FELIS)'
    point_text = (summarydat['id'][sortindex_S].astype(int)).astype(str)


    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,'DUMMY-summarydat',
                                                   histaxes=True,Nbins=30,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][sortindex_S],
                                                   linetype='onetoone',point_text=point_text,
                                                   xlog=True,ylog=True,xrange=[10,1200],yrange=[10,1200],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext    = 'Comparison_horizontal_FciiiVSz'
    plotname   = plotbasename+nameext+'.pdf'
    xvalues    = summarydat['z_temp_S2Nmax'][sortindex_S]
    xerr       = [None]*len(xvalues)
    yvalues    = (summarydat['Ftot_FELIS_S2Nmax'][sortindex_S]/masedadat['f_ciii'][sortindex_M]) - 1
    yerr       = np.sqrt((summarydat['Ftot_FELIS_S2Nmax_err'][sortindex_S] /
                          summarydat['Ftot_FELIS_S2Nmax'][sortindex_S])**2.0+
                         (masedadat['df_ciii'][sortindex_M] /
                          masedadat['f_ciii'][sortindex_M])**2.0) * Nsigmaplot
    xlabel     = '$z$(FELIS)'
    ylabel     = '[Flux(CIII,FELIS)-Flux(CIII,Maseda)] - 1'
    point_text = (summarydat['id'][sortindex_S].astype(int)).astype(str)


    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,'DUMMY-summarydat',
                                                   histaxes=True,Nbins=30,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][sortindex_S],
                                                   linetype='horizontal',point_text=point_text,
                                                   xlog=False,ylog=False,xrange=[1.0,3.0],yrange=[-0.5,0.5],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext    = 'Comparison_horizontal_FciiiVSsigma'
    plotname   = plotbasename+nameext+'.pdf'
    xvalues    = summarydat['sigma_temp_ang_rf'][sortindex_S]
    xerr       = [None]*len(xvalues)
    yvalues    = (summarydat['Ftot_FELIS_S2Nmax'][sortindex_S]/masedadat['f_ciii'][sortindex_M]) - 1
    yerr       = np.sqrt((summarydat['Ftot_FELIS_S2Nmax_err'][sortindex_S] /
                          summarydat['Ftot_FELIS_S2Nmax'][sortindex_S])**2.0+
                         (masedadat['df_ciii'][sortindex_M]/
                          masedadat['f_ciii'][sortindex_M])**2.0) * Nsigmaplot
    xlabel     = '$\sigma$(FELIS)'
    ylabel     = '[Flux(CIII,FELIS)-Flux(CIII,Maseda)] - 1'
    point_text = (summarydat['id'][sortindex_S].astype(int)).astype(str)


    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,'DUMMY-summarydat',
                                                   histaxes=True,Nbins=30,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][sortindex_S],
                                                   linetype='horizontal',point_text=point_text,
                                                   xlog=False,ylog=False,xrange=[0.2,0.8],yrange=[-0.5,0.5],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =