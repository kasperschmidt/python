# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# Scripts, functions and routines to (enable) search for UV emission lines in MUSE data
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
import pdb
import os
import sys
import glob
import astropy
import scipy
import MiGs
import astropy.io.fits as afits
import pyfits as pyfitsOLD
import datetime
import numpy as np
import shutil
import time
import fits2ascii as f2a
import MUSEWideUtilities as mu
import MUSEWidePlots as mwp
import kbsutilities as kbs
import tdose_utilities as tu
from astropy import wcs
from astropy.coordinates import SkyCoord
from astropy import units as u
import subprocess
import collections
import uvEmissionlineSearch as uves
from uncertainties import unumpy
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.ticker import NullFormatter
import NEOGALmodels as nm
#import rxj2248_BooneBalestraSource as bbs
import felis_build_template as fbt
import felis
import literaturecollection_emissionlinestrengths as lce
import stacking
from itertools import combinations
import pickle
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def buildANDgenerate(clobber=True):
    """
    Convenience wrapper to build and generate all the files needed for the TDOSE run

    --- Needs to be updated to be used as of 171019 ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.buildANDgenerate()

    """
    LAEinfofile = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    uves.build_LAEfitstable(fitsname=LAEinfofile,clobber=clobber)

    sourcecatdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats/'
    uves.gen_LAEsourceCats(sourcecatdir,LAEinfofile,modelcoord=True)

    SETUPinfofile = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_setupfiles/MUSEWide_infofile_arche_PSFupdate_LAEs.txt'
    uves.gen_TDOSEsetupfiles(SETUPinfofile,clobber=clobber)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def run_TDOSEextraction():
    """
    Command (to copy-paste into arche) to run TDOSE on setup files generated with uves.gen_TDOSEsetupfiles()

    --- EXAMPLE OF USE ---
    copy-past into Max terminal (for copying over files to arche) and on arche (for running TDOSE)

    """
    # ---------------------------- Copying over files from Mac ----------------------------
    # scp /Users/kschmidt/work/MUSE/uvEmissionlineSearch/ref_image_galfit_models/*.fits kasper@arche.aip.de:/store/data/musewide/TDOSE/ref_image_galfit_models/

    # scp /Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_setupfiles/*candels*.txt kasper@arche.aip.de:/store/data/musewide/TDOSE/tdose_setupfiles/

    # scp /Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats/*.fits kasper@arche.aip.de:/store/data/musewide/TDOSE/tdose_sourcecats/

    # ------------------------ Running TDOSE on Arche - FewFileRun ------------------------
    # mkdir tdose_models tdose_cutouts tdose_spectra
    # ur_setup
    # ipython
    import tdose, glob
    import numpy as np
    Nsessions = 1

    setupfiles = [glob.glob('/store/data/musewide/TDOSE/tdose_setupfiles/MUSEWide_tdose_setup_LAEs_candels-*.txt')[0]] # COSMOS 06
    setupfiles = [glob.glob('/store/data/musewide/TDOSE/tdose_setupfiles/MUSEWide_tdose_setup_LAEs_candels-*.txt')[1]] # CDFS 01

    bundles, paralleldic = tdose.perform_extractions_in_parallel(setupfiles,Nsessions=Nsessions,clobber=True,performcutout=True,store1Dspectra=True,plot1Dspectra=True,generateFullFoVmodel=True,generateOverviewPlots=True,skipextractedobjects=False,logterminaloutput=True,verbosePE=True,verbosefull=True)

    # -------------------------- Running TDOSE on Arche - Full Run -------------------------
    # mkdir tdose_models, tdose_cutouts, tdose_spectra
    # ur_setup
    # nice ipython
    import tdose, glob
    import numpy as np
    Nsessions = 30

    setupfiles = glob.glob('/store/data/musewide/TDOSE/tdose_setupfiles/MUSEWide_tdose_setup_LAEs_candels-*.txt')

    bundles, paralleldic = tdose.perform_extractions_in_parallel(setupfiles,Nsessions=Nsessions,clobber=True,performcutout=True,store1Dspectra=True,plot1Dspectra=True,generateFullFoVmodel=True,generateOverviewPlots=True,skipextractedobjects=True,logterminaloutput=True)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def build_LAEfitstable(fitsname='./LAEinfoRENAME.fits',genDS9region=True,clobber=False,verbose=True):
    """
    Building a fits table containing information on the sources.
    Generated by combining multiple sources of information.

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.build_LAEfitstable(clobber=True)

    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Loading fits catalogs for LAEs:')
    catPSF            = '/Users/kschmidt/work/catalogs/MUSE_GTO/psf_all_Converted_cleaned.fits'
    catE24eltab       = '/Users/kschmidt/work/catalogs/MUSE_GTO/MW_1-24_emline_table_v3.2.fits'

    if verbose: print('   '+catPSF)
    datPSF      = afits.open(catPSF)[1].data
    if verbose: print('   Columns: '+str(datPSF.dtype.names)+'\n')

    if verbose: print('   '+catE24eltab)
    datE24eltab = afits.open(catE24eltab)[1].data
    if verbose: print('   Columns: '+str(datE24eltab.dtype.names)+'\n')

    catE24main        = '/Users/kschmidt/work/catalogs/MUSE_GTO/MW_1-24_main_table_v3.2.fits'
    catE36main        = '/Users/kschmidt/work/catalogs/MUSE_GTO/merged_catalog_e36_v1.0.fits'
    catE40main        = '/Users/kschmidt/work/catalogs/MUSE_GTO/merged_catalog_e40_v0.9.fits'
    catUDFSmain       = '/Users/kschmidt/work/catalogs/MUSE_GTO/merged_catalog_mosaic_shallow_v0.9.fits'
    catU10main        = '/Users/kschmidt/work/catalogs/MUSE_GTO/object_catalog_udf-10_v0.9.fits'
    catUDFmain        = '/Users/kschmidt/work/catalogs/MUSE_GTO/merged_catalog_udf-mosaic_v0.9.fits'
    # IDs in UDF mosaic catalog consist of 4 digits id followed by 4 digits running line number

    if verbose: print('   '+catE24main)
    datE24main  = afits.open(catE24main)[1].data
    if verbose: print('   Columns: '+str(datE24main.dtype.names)+'\n')

    if verbose: print('   '+catE36main)
    datE36main  = afits.open(catE36main)[1].data
    if verbose: print('   Columns: '+str(datE36main.dtype.names)+'\n')

    if verbose: print('   '+catE40main)
    datE40main  = afits.open(catE40main)[1].data
    if verbose: print('   Columns: '+str(datE40main.dtype.names)+'\n')

    if verbose: print('   '+catUDFSmain)
    datUDFSmain  = afits.open(catUDFSmain)[1].data
    if verbose: print('   Columns: '+str(datUDFSmain.dtype.names)+'\n')

    if verbose: print('   '+catUDFmain)
    datUDFmain  = afits.open(catUDFmain)[1].data
    if verbose: print('   Columns: '+str(datUDFmain.dtype.names)+'\n')

    if verbose: print('   '+catU10main)
    datU10main= afits.open(catU10main)[1].data
    if verbose: print('   Columns: '+str(datU10main.dtype.names)+'\n')


    catE24lineprops   = '/Users/kschmidt/work/catalogs/MUSE_GTO/MW_1-24_v3.1_LAEs_line_props.fits'
    catE36lineprops   = '/Users/kschmidt/work/catalogs/MUSE_GTO/e36_emline_master_v1.0_LAEs_line_props.fits'
    catE40lineprops   = 'None'
    catUDFSlineprops  = 'None'
    catUDFlineprops   = 'None'
    catU10lineprops   = 'None'

    if verbose: print('   '+catE24lineprops)
    datE24lp  = afits.open(catE24lineprops)[1].data
    if verbose: print('   Columns: '+str(datE24lp.dtype.names)+'\n')

    if verbose: print('   '+catE36lineprops)
    datE36lp    = afits.open(catE36lineprops)[1].data
    if verbose: print('   Columns: '+str(datE36lp.dtype.names)+'\n')

    catLyaEW          = '/Users/kschmidt/work/catalogs/MUSE_GTO/fluxes_EWs_line_props.fits'
    if verbose: print('   '+catLyaEW)
    datLyaEW  = afits.open(catLyaEW)[1].data
    if verbose: print('   Columns: '+str(datLyaEW.dtype.names)+'\n')

    catLyaJKthesis    = '/Users/kschmidt/work/catalogs/MUSE_GTO/kerutt_LAEparameters190926_EWs_0_clumps_ratio_line_props.fits'
    if verbose: print('   '+catLyaJKthesis)
    datLyaJKthesis  = afits.open(catLyaJKthesis)[1].data
    if verbose: print('   Columns: '+str(datLyaJKthesis.dtype.names)+'\n')

    catGuo     = '/Users/kschmidt/work/catalogs/guo/CANDELS.GOODSS.F160W.v1.fits'
    if verbose: print('   '+catGuo)
    datGuo     = afits.open(catGuo)[1].data

    catSkeltonGS  = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
    if verbose: print('   '+catSkeltonGS)
    datSkeltonGS  = afits.open(catSkeltonGS)[1].data

    catSkeltonCOS = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
    if verbose: print('   '+catSkeltonCOS)
    datSkeltonCOS = afits.open(catSkeltonCOS)[1].data

    catRafelski = '/Users/kschmidt/work/catalogs/rafelski/uvudf_rafelski_2015.fits'
    if verbose: print('   '+catRafelski)
    datRafelski = afits.open(catRafelski)[1].data

    #catLaigle = '/Users/kschmidt/work/catalogs/COSMOS2015_Laigle_v1.1.fits'
    catLaigle = '/Users/kschmidt/work/catalogs/COSMOS2015_Laigle_v1.1_candelsregion.fits' # generated with TOPCAT
    if verbose: print('   '+catLaigle )
    datLaigle  = afits.open(catLaigle)[1].data

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Counting LAEs and putting together ID list')
    e24_ids  = datE24main['UNIQUE_ID'].astype(str)
    e36_ids  = datE36main['ID'].astype(str)
    e40_ids  = datE40main['ID'].astype(str)
    udfs_ids = datUDFSmain['ID'].astype(str)
    udf_ids  = np.asarray(["6"+str("%08d" % udfid) for udfid in datUDFmain['ID']])
    u10_ids  = np.asarray(["7"+str("%08d" % u10id) for u10id in datU10main['ID']])
    objids   = []

    zcut     = 2.7 # LAEs
    zcut     = 1.5 # UVemitters; objects with potential CIII]1909 (or below) and no OII
    # - - - - - - - - - - - - - E24 - - - - - - - - - - - - - -
    for ii,id in enumerate(e24_ids):
        if datE24main['Z'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - E36 - - - - - - - - - - - - - -
    for ii,id in enumerate(e36_ids):
        if datE36main['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - E40 - - - - - - - - - - - - - -
    for ii,id in enumerate(e40_ids):
        if datE40main['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - UDF Shallow - - - - - - - - - - - - - -
    for ii,id in enumerate(udfs_ids):
        if datUDFSmain['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - UDF Mosaic - - - - - - - - - - - - - -
    for ii,id in enumerate(udf_ids):
        if datUDFmain['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - UDF-10 - - - - - - - - - - - - - -
    for ii,id in enumerate(u10_ids):
        if datU10main['REDSHIFT'][ii] > zcut:
            objids.append( id )
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    objids = np.sort(np.asarray(objids).astype(int))
    # objids[0] = 1: CDFS
    # objids[0] = 2: COSMOS
    # objids[0] = 3: Parallel hudf09-1
    # objids[0] = 4: Parallel hudf09-2
    # objids[0] = 5: UDF-mosaic-shallow
    # objids[0] = 6: UDF-mosaic
    # objids[0] = 7: UDF-10
    #objids = np.array([106003018,131016105,153024080,206004030,302038138,404010192,509084195,600100628,614564367,720060067])
    NLAEs  = len(objids)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Assembling info for the '+str(NLAEs)+' LAEs found')
    galfitmodeldir  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/imgblocks_josieGALFITmodels/'
    redshifts       = []
    ras             = []
    decs            = []
    pointing        = []
    x_image         = []
    y_image         = []
    name_model      = []
    N_model_comp    = []
    ras_model       = []
    decs_model      = []
    delta_coords    = []
    x_image_model   = []
    y_image_model   = []

    # v v v    line props    v v v
    z_vac_red           = []
    z_vac_error         = []
    z_vac_mean          = []
    num_peaks           = []
    fwhm_A              = []
    fwhm_A_std          = []
    fwhm_kms            = []
    fwhm_kms_std        = []
    peak_sep_A          = []
    peak_sep_A_std      = []
    peak_sep_kms        = []
    peak_sep_kms_std    = []
    sum_fit             = []
    sum_fit_std         = []
    sum_fit_blue        = []
    sum_fit_blue_std    = []
    sum_fit_red         = []
    sum_fit_red_std     = []
    sum_lsdcat          = []
    sum_lsdcat_std      = []

    red_peak_shift_V18_kms      = []  # Red peak shift estimate based on A. Verhamme et al. (2017) relations
    red_peak_shift_V18_kms_err  = []
    z_sys_V18                   = []  # Systemic redshift estimate based on A. Verhamme et al. (2017) relations
    z_sys_V18_err               = []

    # v v v    Lya EW props  v v v
    EW_0                 = []
    EW_0_err             = []
    beta                 = []
    beta_err             = []
    flux_acs_606w        = []
    flux_err_acs_606w    = []
    flux_acs_775w        = []
    flux_err_acs_775w    = []
    flux_acs_814w        = []
    flux_err_acs_814w    = []
    flux_wfc3_125w       = []
    flux_err_wfc3_125w   = []
    flux_wfc3_160w       = []
    flux_err_wfc3_160w   = []

    # v v v    Phot Cat Match  v v v
    idsGuo      = []
    sepsGuo     = []
    rasGuo      = []
    decsGuo     = []

    idsSkelton  = []
    sepsSkelton = []
    rasSkelton  = []
    decsSkelton = []

    idsRafelski  = []
    sepsRafelski = []
    rasRafelski  = []
    decsRafelski = []

    idsLaigle  = []
    sepsLaigle = []
    rasLaigle  = []
    decsLaigle = []

    leadline    = []
    leadlineSN  = []

    for ii,id in enumerate(objids):
        if verbose:
            infostr = '  >Getting info for '+str(id)+' ('+str("%.5d" % (ii+1))+' / '+str("%.5d" % NLAEs)+')  '
            if verbose: print(infostr)
            # sys.stdout.write("%s\r" % infostr)
            # sys.stdout.flush()
        imgignorstr = '_wht_'
        # - - - - - - - - - - GET LSDCAT COORDINATES - - - - - - - - - -
        if str(id) in e24_ids:
            pointingname = mu.gen_pointingname(id)
            pointing.append(pointingname)

            objent = np.where(datE24main['UNIQUE_ID'] == str(id))[0]
            redshifts.append(datE24main['Z'][objent][0])
            ras.append(datE24main['RA'][objent][0])
            decs.append(datE24main['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datE24main['RA'][objent],datE24main['DEC'][objent],pointingname,pixorigin=0,
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*814*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datE24main['LEAD_LINE'][objent][0])
            leadlineSN.append(datE24main['SN'][objent][0])
        elif str(id) in e36_ids:
            pointingname = mu.gen_pointingname(id)
            pointing.append(pointingname)

            objent = np.where(datE36main['ID'] == id)[0]
            redshifts.append(datE36main['REDSHIFT'][objent][0])
            ras.append(datE36main['RA'][objent][0])
            decs.append(datE36main['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datE36main['RA'][objent],datE36main['DEC'][objent],pointingname,
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*814*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datE36main['LINE_ID'][objent][0])
            leadlineSN.append(datE36main['S2N'][objent][0])
        elif str(id) in e40_ids:
            pointingname = mu.gen_pointingname(id)
            pointing.append(pointingname)

            objent = np.where(datE40main['ID'] == id)[0]
            redshifts.append(datE40main['REDSHIFT'][objent][0])
            ras.append(datE40main['RA'][objent][0])
            decs.append(datE40main['DEC'][objent][0])
            if str(id).startswith('1') or str(id).startswith('2'):
                imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*814*'
            else:
                imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*775*'
            ximg, yimg = mu.get_pixelpos(datE40main['RA'][objent],datE40main['DEC'][objent],pointingname,
                                         ignorestr=imgignorstr,imgdir=imgdir,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datE40main['LINE_ID'][objent][0])
            leadlineSN.append(datE40main['S2N'][objent][0])
        elif str(id) in udfs_ids:
            objent = np.where(udfs_ids == str(id))[0]

            pointingname = mu.gen_pointingname(id)
            pointing.append(pointingname)

            redshifts.append(datUDFSmain['REDSHIFT'][objent][0])
            ras.append(datUDFSmain['RA'][objent][0])
            decs.append(datUDFSmain['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datUDFSmain['RA'][objent],datUDFSmain['DEC'][objent],pointingname,
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*775*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datUDFSmain['LINE_ID'][objent][0])
            leadlineSN.append(datUDFSmain['S2N'][objent][0])
        elif str(id) in udf_ids:
            objent = np.where(udf_ids == str(id))[0]

            pointingname = 'udf-mosaic'
            pointing.append(pointingname)

            redshifts.append(datUDFmain['REDSHIFT'][objent][0])
            ras.append(datUDFmain['RA'][objent][0])
            decs.append(datUDFmain['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datUDFmain['RA'][objent],datUDFmain['DEC'][objent],pointingname,
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*775*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datUDFmain['LINE_ID'][objent][0])
            leadlineSN.append(datUDFmain['S2N'][objent][0])
        elif str(id) in u10_ids:
            objent = np.where(u10_ids == str(id))[0]

            pointingname = 'udf-10'
            pointing.append(pointingname)

            redshifts.append(datU10main['REDSHIFT'][objent][0])
            ras.append(datU10main['RA'][objent][0])
            decs.append(datU10main['DEC'][objent][0])
            ximg, yimg = mu.get_pixelpos(datU10main['RA'][objent],datU10main['DEC'][objent],'udf-mosaic_v1.5',
                                         imgdir='/Users/kschmidt/work/images_MAST/MUSEWidePointings/*775*',
                                         ignorestr=imgignorstr,imgext=0,verbose=False)
            x_image.append(ximg)
            y_image.append(yimg)
            leadline.append(datU10main['LINE_ID'][objent][0])
            leadlineSN.append(datU10main['S2N'][objent][0])
        else:
            print('\nWeird... ID= '+str(id)+' not found in E24, E36, E40, UDF10, UDF-shallow or UDF-mosaic id-list... #1\n')
            pdb.set_trace()
        # - - - - - - - - - - GET MODEL COORDINATES - - - - - - - - - -
        modelfile = glob.glob(galfitmodeldir+'imgblock_'+str("%.9d" % id)+'.fits')

        if len(modelfile) == 0:
            if verbose: print('   No model found; ')
            name_model.append("NoModelFoundIn_"+galfitmodeldir)
            N_model_comp.append(0)
            ras_model.append(0)
            decs_model.append(0)
            delta_coords.append(0)
            x_image_model.append(0)
            y_image_model.append(0)
        elif len(modelfile) > 1:
            sys.exit('Found more than one model file for '+str("%.9d" % id)+'; Found the models '+modelfile)
        else:
            refimg_hdr  = afits.open(modelfile[0])[1].header
            model_hdr   = afits.open(modelfile[0])[2].header
            comps       = []
            for hdrkey in model_hdr.keys():
                if ('COMP_' in hdrkey) & (model_hdr[hdrkey] != 'sky'):
                    comps.append(hdrkey)

            imgwcs      = wcs.WCS(tu.strip_header(refimg_hdr.copy()))

            pix_based_on_model = False
            if pix_based_on_model:
                xstr        = model_hdr['1_XC'].split(' ')
                ystr        = model_hdr['1_YC'].split(' ')

                if len(xstr) > 1:
                    xpix    = int(float(xstr[0]))
                else:
                    if verbose: print('   Model xpix has no err; ')
                    xpix    = int(float(xstr[0][1:-1]))

                if len(ystr) > 1:
                    ypix    = int(float(ystr[0]))
                else:
                    if verbose: print('   Model ypix has no err; ')
                    ypix    = int(float(ystr[0][1:-1]))
            else:
                fit_region     = model_hdr['FITSECT']
                cutrange_low_x = int(float(fit_region.split(':')[0].split('[')[-1]))
                cutrange_low_y = int(float(fit_region.split(',')[-1].split(':')[0]))
                xsize          = model_hdr['NAXIS1']
                ysize          = model_hdr['NAXIS2']

                xpix           = cutrange_low_x + int(xsize/2.)
                ypix           = cutrange_low_y + int(ysize/2.)

            if 'cdfs' in pointingname:
                skycoord    = wcs.utils.pixel_to_skycoord(xpix,ypix,imgwcs, origin=1)
            elif 'cosmos' in pointingname:
                skycoord    = wcs.utils.pixel_to_skycoord(xpix,ypix,imgwcs, origin=0)

            ra_model    = skycoord.ra.value
            dec_model   = skycoord.dec.value

            delta_coord = np.sqrt( (np.cos(np.deg2rad(dec_model))*(ras[ii]-ra_model))**2.0 + (decs[ii]-dec_model)**2.0 )

            name_model.append(modelfile[0])
            N_model_comp.append(len(comps))
            ras_model.append(ra_model)
            decs_model.append(dec_model)
            delta_coords.append(delta_coord*3600.)
            x_image_model.append(xpix)
            y_image_model.append(ypix)

        # - - - - - - - - - - ADD INFO FROM LINE PROPS TABLES - - - - - - - - - -
        if len(modelfile) == 0:
            z_vac_red.append(0.0)
            z_vac_error.append(0.0)
            z_vac_mean.append(0.0)
            num_peaks.append(0.0)
            fwhm_A.append(0.0)
            fwhm_A_std.append(0.0)
            fwhm_kms.append(0.0)
            fwhm_kms_std.append(0.0)
            peak_sep_A.append(0.0)
            peak_sep_A_std.append(0.0)
            peak_sep_kms.append(0.0)
            peak_sep_kms_std.append(0.0)
            sum_fit.append(0.0)
            sum_fit_std.append(0.0)
            sum_fit_blue.append(0.0)
            sum_fit_blue_std.append(0.0)
            sum_fit_red.append(0.0)
            sum_fit_red_std.append(0.0)
            sum_lsdcat.append(0.0)
            sum_lsdcat_std.append(0.0)
            red_peak_shift_V18_kms.append(0.0)
            red_peak_shift_V18_kms_err.append(0.0)
            z_sys_V18.append(0.0)
            z_sys_V18_err.append(0.0)
        else:
            if str(id) in e24_ids:
                objent = np.where(datE24lp['UNIQUE_ID'] == str(id))[0]
                z_vac_red.append(datE24lp['z_vac_red'][objent][0])
                z_vac_error.append(datE24lp['z_vac_error'][objent][0])
                z_vac_mean.append(datE24lp['z_vac_mean'][objent][0])
                num_peaks.append(datE24lp['num_peaks'][objent][0])
                fwhm_A.append(datE24lp['fwhm_A'][objent][0])
                fwhm_A_std.append(datE24lp['fwhm_A_std'][objent][0])
                fwhm_kms.append(datE24lp['fwhm_kms'][objent][0])
                fwhm_kms_std.append(datE24lp['fwhm_kms_std'][objent][0])
                peak_sep_A.append(datE24lp['peak_sep_A'][objent][0])
                peak_sep_A_std.append(datE24lp['peak_sep_A_std'][objent][0])
                peak_sep_kms.append(datE24lp['peak_sep_kms'][objent][0])
                peak_sep_kms_std.append(datE24lp['peak_sep_kms_std'][objent][0])
                sum_fit.append(datE24lp['sum_fit'][objent][0])
                sum_fit_std.append(datE24lp['sum_fit_std'][objent][0])
                sum_fit_blue.append(datE24lp['sum_fit_blue'][objent][0])
                sum_fit_blue_std.append(datE24lp['sum_fit_blue_std'][objent][0])
                sum_fit_red.append(datE24lp['sum_fit_red'][objent][0])
                sum_fit_red_std.append(datE24lp['sum_fit_red_std'][objent][0])
                sum_lsdcat.append(datE24lp['sum_lsdcat'][objent][0])
                sum_lsdcat_std.append(datE24lp['sum_lsdcat_std'][objent][0])
            elif str(id) in e36_ids:
                objent = np.where(datE36lp['UNIQUE_ID'] == str(id))[0]
                z_vac_red.append(datE36lp['z_vac_red'][objent][0])
                z_vac_error.append(datE36lp['z_vac_error'][objent][0])
                z_vac_mean.append(datE36lp['z_vac_mean'][objent][0])
                num_peaks.append(datE36lp['num_peaks'][objent][0])
                fwhm_A.append(datE36lp['fwhm_A'][objent][0])
                fwhm_A_std.append(datE36lp['fwhm_A_std'][objent][0])
                fwhm_kms.append(datE36lp['fwhm_kms'][objent][0])
                fwhm_kms_std.append(datE36lp['fwhm_kms_std'][objent][0])
                peak_sep_A.append(datE36lp['peak_sep_A'][objent][0])
                peak_sep_A_std.append(datE36lp['peak_sep_A_std'][objent][0])
                peak_sep_kms.append(datE36lp['peak_sep_kms'][objent][0])
                peak_sep_kms_std.append(datE36lp['peak_sep_kms_std'][objent][0])
                sum_fit.append(datE36lp['sum_fit'][objent][0])
                sum_fit_std.append(datE36lp['sum_fit_std'][objent][0])
                sum_fit_blue.append(datE36lp['sum_fit_blue'][objent][0])
                sum_fit_blue_std.append(datE36lp['sum_fit_blue_std'][objent][0])
                sum_fit_red.append(datE36lp['sum_fit_red'][objent][0])
                sum_fit_red_std.append(datE36lp['sum_fit_red_std'][objent][0])
                sum_lsdcat.append(datE36lp['sum_lsdcat'][objent][0])
                sum_lsdcat_std.append(datE36lp['sum_lsdcat_std'][objent][0])
            elif (str(id) in e40_ids) or (str(id) in udfs_ids) or (str(id) in udf_ids) or (str(id) in u10_ids):
                z_vac_red.append(-99)
                z_vac_error.append(-99)
                z_vac_mean.append(-99)
                num_peaks.append(-99)
                fwhm_A.append(-99)
                fwhm_A_std.append(-99)
                fwhm_kms.append(-99)
                fwhm_kms_std.append(-99)
                peak_sep_A.append(-99)
                peak_sep_A_std.append(-99)
                peak_sep_kms.append(-99)
                peak_sep_kms_std.append(-99)
                sum_fit.append(-99)
                sum_fit_std.append(-99)
                sum_fit_blue.append(-99)
                sum_fit_blue_std.append(-99)
                sum_fit_red.append(-99)
                sum_fit_red_std.append(-99)
                sum_lsdcat.append(-99)
                sum_lsdcat_std.append(-99)
            else:
                print('Weird... ID not found in E24, E36, E40, UDF-10, UDF-shallow or UDF-mosaic id-list... #2')
                pdb.set_trace()

            if peak_sep_kms[ii] != 0.0:
                rp_shift_V18_kms     = 1.00 * peak_sep_kms[ii]/2.
                rp_shift_V18_kms_err = np.abs(rp_shift_V18_kms) * \
                                        np.sqrt( (peak_sep_kms_std[ii]/peak_sep_kms[ii])**2 + (0.04/1.00)**2)
            elif peak_sep_kms[ii] == -99:
                rp_shift_V18_kms     = -99
                rp_shift_V18_kms_err = -99
            else:
                rp_shift_V18_kms     = 0.86 * fwhm_kms[ii]
                rp_shift_V18_kms_err = np.abs(rp_shift_V18_kms) * \
                                        np.sqrt( (fwhm_kms_std[ii]/fwhm_kms[ii])**2 + (0.04/0.86)**2)

            # Estimate systemic redshift using Lya offest from Verhamme+17 and Eq. (5) Erb+14 relating this to z_sys
            if rp_shift_V18_kms == -99:
                z_sys           = -99
                z_sys_err       = -99
            else:
                c_val           = astropy.constants.c.value/1000.
                numerator       = ( z_vac_red[ii] - rp_shift_V18_kms/c_val)
                numerator_err   = np.sqrt( z_vac_error[ii]**2.0 + (rp_shift_V18_kms_err/rp_shift_V18_kms)**2.0 )
                denominator     = (rp_shift_V18_kms/c_val + 1.0)
                denominator_err = rp_shift_V18_kms_err/np.abs(rp_shift_V18_kms)
                z_sys           = numerator / denominator
                z_sys_err       = np.abs(z_sys) * \
                                  np.sqrt( (numerator_err/numerator)**2.0 + (denominator_err/denominator)**2.0 )

            red_peak_shift_V18_kms.append(rp_shift_V18_kms)
            red_peak_shift_V18_kms_err.append(rp_shift_V18_kms_err)
            z_sys_V18.append(z_sys)
            z_sys_V18_err.append(z_sys_err)

        # - - - - - - - - - - ADD INFO FROM EW LINE PROPS TABLE - - - - - - - - - -
        if len(modelfile) == 0:
            EW_0.append(0.0)
            EW_0_err.append(0.0)
            beta.append(0.0)
            beta_err.append(0.0)
            flux_acs_606w.append(0.0)
            flux_err_acs_606w.append(0.0)
            flux_acs_775w.append(0.0)
            flux_err_acs_775w.append(0.0)
            flux_acs_814w.append(0.0)
            flux_err_acs_814w.append(0.0)
            flux_wfc3_125w.append(0.0)
            flux_err_wfc3_125w.append(0.0)
            flux_wfc3_160w.append(0.0)
            flux_err_wfc3_160w.append(0.0)
        else:
            objent = np.where(datLyaEW['IDs'] == str(id))[0]
            EW_0.append(datLyaEW['EW_0'][objent][0])
            EW_0_err.append(datLyaEW['EW_0_err'][objent][0])
            beta.append(datLyaEW['beta'][objent][0])
            beta_err.append(datLyaEW['beta_err'][objent][0])
            flux_acs_606w.append(datLyaEW['flux_acs_606w'][objent][0])
            flux_err_acs_606w.append(datLyaEW['flux_err_acs_606w'][objent][0])
            flux_acs_775w.append(datLyaEW['flux_acs_775w'][objent][0])
            flux_err_acs_775w.append(datLyaEW['flux_err_acs_775w'][objent][0])
            flux_acs_814w.append(datLyaEW['flux_acs_814w'][objent][0])
            flux_err_acs_814w.append(datLyaEW['flux_err_acs_814w'][objent][0])
            flux_wfc3_125w.append(datLyaEW['flux_wfc3_125w'][objent][0])
            flux_err_wfc3_125w.append(datLyaEW['flux_err_wfc3_125w'][objent][0])
            flux_wfc3_160w.append(datLyaEW['flux_wfc3_160w'][objent][0])
            flux_err_wfc3_160w.append(datLyaEW['flux_err_wfc3_160w'][objent][0])

        # - - - - - - - - - - ADD MATCHES TO PHOTOMETRIC CATALOGS - - - - - - - - - -
        coordMUSE = SkyCoord(ra=ras[ii]*u.degree, dec=decs[ii]*u.degree)

        if str(id)[0] in ['1','5','6','7']: # <------- Match to Guo catalog
            coordGuo  = SkyCoord(ra=datGuo['RA']*u.degree, dec=datGuo['DEC']*u.degree)
            entGuo, match_2DGuo, match_3DGuo = coordMUSE.match_to_catalog_sky(coordGuo)
            idsGuo.append(datGuo['ID'][entGuo])
            sepsGuo.append(match_2DGuo.value[0] * 3600.0)
            rasGuo.append(datGuo['RA'][entGuo])
            decsGuo.append(datGuo['DEC'][entGuo])
        else:
            idsGuo.append(-99)
            sepsGuo.append(-99)
            rasGuo.append(-99)
            decsGuo.append(-99)

        if str(id)[0] in ['1','3','4','5','6','7']: # <------- Match to Skelton GOODS-SOUTH catalog
            coordSkelton  = SkyCoord(ra=datSkeltonGS['RA']*u.degree, dec=datSkeltonGS['DEC']*u.degree)
            entSkelton, match_2DSkelton, match_3DSkelton = coordMUSE.match_to_catalog_sky(coordSkelton)
            idsSkelton.append(datSkeltonGS['ID'][entSkelton])
            sepsSkelton.append(match_2DSkelton.value[0] * 3600.0)
            rasSkelton.append(datSkeltonGS['RA'][entSkelton])
            decsSkelton.append(datSkeltonGS['DEC'][entSkelton])
        elif str(id)[0] in ['2']: # <------- Match to Skelton COSMOS catalog
            coordSkelton  = SkyCoord(ra=datSkeltonCOS['RA']*u.degree, dec=datSkeltonCOS['DEC']*u.degree)
            entSkelton, match_2DSkelton, match_3DSkelton = coordMUSE.match_to_catalog_sky(coordSkelton)
            idsSkelton.append(datSkeltonCOS['ID'][entSkelton])
            sepsSkelton.append(match_2DSkelton.value[0] * 3600.0)
            rasSkelton.append(datSkeltonCOS['RA'][entSkelton])
            decsSkelton.append(datSkeltonCOS['DEC'][entSkelton])
        else:
            idsSkelton.append(-99)
            sepsSkelton.append(-99)
            rasSkelton.append(-99)
            decsSkelton.append(-99)

        if str(id)[0] in ['1','5','6','7']: # <------- Match to Rafelski catalog
            coordRafelski  = SkyCoord(ra=datRafelski['RA']*u.degree, dec=datRafelski['DEC']*u.degree)
            entRafelski, match_2DRafelski, match_3DRafelski = coordMUSE.match_to_catalog_sky(coordRafelski)
            idsRafelski.append(datRafelski['ID'][entRafelski])
            sepsRafelski.append(match_2DRafelski.value[0] * 3600.0)
            rasRafelski.append(datRafelski['RA'][entRafelski])
            decsRafelski.append(datRafelski['DEC'][entRafelski])
        else:
            idsRafelski.append(-99)
            sepsRafelski.append(-99)
            rasRafelski.append(-99)
            decsRafelski.append(-99)

        if str(id)[0] in ['2']: # <------- Match to Laigle cosmos catalog
            coordLaigle  = SkyCoord(ra=datLaigle['ALPHA_J2000']*u.degree, dec=datLaigle['DELTA_J2000']*u.degree)
            entLaigle, match_2DLaigle, match_3DLaigle = coordMUSE.match_to_catalog_sky(coordLaigle)
            idsLaigle.append(datLaigle['NUMBER'][entLaigle])
            sepsLaigle.append(match_2DLaigle.value[0] * 3600.0)
            rasLaigle.append(datLaigle['ALPHA_J2000'][entLaigle])
            decsLaigle.append(datLaigle['DELTA_J2000'][entLaigle])
        else:
            idsLaigle.append(-99)
            sepsLaigle.append(-99)
            rasLaigle.append(-99)
            decsLaigle.append(-99)

    if verbose: print('\n   done...')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Defining fits table and filling it with data')
    c1  = pyfitsOLD.Column(name='id', format='J', unit='', array=objids)
    c2  = pyfitsOLD.Column(name='pointing', format='A30', unit='', array=pointing)
    c3  = pyfitsOLD.Column(name='ra', format='D', unit='DEF', array=ras)
    c4  = pyfitsOLD.Column(name='dec', format='D', unit='DEG', array=decs)
    c5  = pyfitsOLD.Column(name='redshift', format='D', unit='', array=redshifts)
    c6  = pyfitsOLD.Column(name='x_image', format='D', unit='PIXEL', array=x_image)
    c7  = pyfitsOLD.Column(name='y_image', format='D', unit='PIXEL', array=y_image)

    c8  = pyfitsOLD.Column(name='modelname', format='A110', unit='', array=name_model)
    c9  = pyfitsOLD.Column(name='Nmodelcomponents', format='D', unit='DEF', array=N_model_comp)
    c10 = pyfitsOLD.Column(name='ra_model', format='D', unit='DEF', array=ras_model)
    c11 = pyfitsOLD.Column(name='dec_model', format='D', unit='DEG', array=decs_model)
    c12 = pyfitsOLD.Column(name='deltacoord', format='D', unit='DEG', array=delta_coords)
    c13 = pyfitsOLD.Column(name='x_image_model', format='D', unit='PIXEL', array=x_image_model)
    c14 = pyfitsOLD.Column(name='y_image_model', format='D', unit='PIXEL', array=y_image_model)

    c15 = pyfitsOLD.Column(name='z_vac_red', format='D', unit='', array=z_vac_red)
    c16 = pyfitsOLD.Column(name='z_vac_error', format='D', unit='', array=z_vac_error)
    c17 = pyfitsOLD.Column(name='z_vac_mean', format='D', unit='', array=z_vac_mean)
    c18 = pyfitsOLD.Column(name='num_peaks', format='D', unit='', array=num_peaks)
    c19 = pyfitsOLD.Column(name='fwhm_A', format='D', unit='A', array=fwhm_A)
    c20 = pyfitsOLD.Column(name='fwhm_A_std', format='D', unit='A', array=fwhm_A_std)
    c21 = pyfitsOLD.Column(name='fwhm_kms', format='D', unit='KM/S', array=fwhm_kms)
    c22 = pyfitsOLD.Column(name='fwhm_kms_std', format='D', unit='KM/S', array=fwhm_kms_std)
    c23 = pyfitsOLD.Column(name='peak_sep_A', format='D', unit='A', array=peak_sep_A)
    c24 = pyfitsOLD.Column(name='peak_sep_A_std', format='D', unit='A', array=peak_sep_A_std)
    c25 = pyfitsOLD.Column(name='peak_sep_kms', format='D', unit='KM/S', array=peak_sep_kms)
    c26 = pyfitsOLD.Column(name='peak_sep_kms_std', format='D', unit='KM/S', array=peak_sep_kms_std)
    c27 = pyfitsOLD.Column(name='sum_fit', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit)
    c28 = pyfitsOLD.Column(name='sum_fit_std', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_std)
    c29 = pyfitsOLD.Column(name='sum_fit_blue', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_blue)
    c30 = pyfitsOLD.Column(name='sum_fit_blue_std', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_blue_std)
    c31 = pyfitsOLD.Column(name='sum_fit_red', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_red)
    c32 = pyfitsOLD.Column(name='sum_fit_red_std', format='D', unit='1e-20*ERG/S/CM**2', array=sum_fit_red_std)
    c33 = pyfitsOLD.Column(name='sum_lsdcat', format='D', unit='1e-20*ERG/S/CM**2', array=sum_lsdcat)
    c34 = pyfitsOLD.Column(name='sum_lsdcat_std', format='D', unit='1e-20*ERG/S/CM**2', array=sum_lsdcat_std)

    c35 = pyfitsOLD.Column(name='red_peak_shift_V18_kms', format='D', unit='KM/S', array=red_peak_shift_V18_kms)
    c36 = pyfitsOLD.Column(name='red_peak_shift_V18_kms_err', format='D', unit='KM/S', array=red_peak_shift_V18_kms_err)
    c37 = pyfitsOLD.Column(name='z_sys_V18', format='D', unit='', array=z_sys_V18)
    c38 = pyfitsOLD.Column(name='z_sys_V18_err', format='D', unit='', array=z_sys_V18_err)

    c39 = pyfitsOLD.Column(name='EW_0', format='D', unit='A', array=EW_0)
    c40 = pyfitsOLD.Column(name='EW_0_err', format='D', unit='A', array=EW_0_err)
    c41 = pyfitsOLD.Column(name='beta', format='D', unit='', array=beta)
    c42 = pyfitsOLD.Column(name='beta_err', format='D', unit='', array=beta_err)
    c43 = pyfitsOLD.Column(name='flux_acs_606w', format='D', unit='ERG/S/CM**2', array=flux_acs_606w)
    c44 = pyfitsOLD.Column(name='flux_err_acs_606w', format='D', unit='ERG/S/CM**2', array=flux_err_acs_606w)
    c45 = pyfitsOLD.Column(name='flux_acs_775w', format='D', unit='ERG/S/CM**2', array=flux_acs_775w)
    c46 = pyfitsOLD.Column(name='flux_err_acs_775w', format='D', unit='ERG/S/CM**2', array=flux_err_acs_775w)
    c47 = pyfitsOLD.Column(name='flux_acs_814w', format='D', unit='ERG/S/CM**2', array=flux_acs_814w)
    c48 = pyfitsOLD.Column(name='flux_err_acs_814w', format='D', unit='ERG/S/CM**2', array=flux_err_acs_814w)
    c49 = pyfitsOLD.Column(name='flux_wfc3_125w', format='D', unit='ERG/S/CM**2', array=flux_wfc3_125w)
    c50 = pyfitsOLD.Column(name='flux_err_wfc3_125w', format='D', unit='ERG/S/CM**2', array=flux_err_wfc3_125w)
    c51 = pyfitsOLD.Column(name='flux_wfc3_160w', format='D', unit='ERG/S/CM**2', array=flux_wfc3_160w)
    c52 = pyfitsOLD.Column(name='flux_err_wfc3_160w', format='D', unit='ERG/S/CM**2', array=flux_err_wfc3_160w)

    c53 = pyfitsOLD.Column(name='id_guo'     , format='D', unit='', array=idsGuo)
    c54 = pyfitsOLD.Column(name='sep_guo'    , format='D', unit='ARCSEC', array=sepsGuo)
    c55 = pyfitsOLD.Column(name='ra_guo'     , format='D', unit='DEG', array=rasGuo)
    c56 = pyfitsOLD.Column(name='dec_guo'    , format='D', unit='DEG', array=decsGuo)

    c57 = pyfitsOLD.Column(name='id_skelton' , format='D', unit='', array=idsSkelton)
    c58 = pyfitsOLD.Column(name='sep_skelton', format='D', unit='ARCSEC', array=sepsSkelton)
    c59 = pyfitsOLD.Column(name='ra_skelton' , format='D', unit='DEG', array=rasSkelton)
    c60 = pyfitsOLD.Column(name='dec_skelton', format='D', unit='DEG', array=decsSkelton)

    c61 = pyfitsOLD.Column(name='id_rafelski' , format='D', unit='', array=idsRafelski)
    c62 = pyfitsOLD.Column(name='sep_rafelski', format='D', unit='ARCSEC', array=sepsRafelski)
    c63 = pyfitsOLD.Column(name='ra_rafelski' , format='D', unit='DEG', array=rasRafelski)
    c64 = pyfitsOLD.Column(name='dec_rafelski', format='D', unit='DEG', array=decsRafelski)

    c65 = pyfitsOLD.Column(name='id_Laigle' , format='D', unit='', array=idsLaigle)
    c66 = pyfitsOLD.Column(name='sep_Laigle', format='D', unit='ARCSEC', array=sepsLaigle)
    c67 = pyfitsOLD.Column(name='ra_Laigle' , format='D', unit='DEG', array=rasLaigle)
    c68 = pyfitsOLD.Column(name='dec_Laigle', format='D', unit='DEG', array=decsLaigle)

    c69 = pyfitsOLD.Column(name='leadline', format='10A', unit='', array=leadline)
    c70 = pyfitsOLD.Column(name='leadlineS2N', format='D', unit='', array=leadlineSN)

    coldefs = pyfitsOLD.ColDefs([c1,c2,c3,c4,c5,c6,c7,c8,
                                 c9,c10,c11,c12,c13,c14,
                                 c15,c16,c17,c18,c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30,c31,c32,c33,c34,
                                 c35,c36,c37,c38,
                                 c39,c40,c41,c42,c43,c44,c45,c46,c47,c48,c49,c50,c51,c52,
                                 c53,c54,c55,c56,c57,c58,c59,c60,
                                 c61,c62,c63,c64,c65,c66,c67,c68,
                                 c69,c70])
    th      = pyfitsOLD.new_table(coldefs) # creating default header

    # writing hdrkeys:'---KEY--',                             '----------------MAX LENGTH COMMENT-------------'
    #th.header.append(('MAG     ' , spec2D[0].header['MAG']   ,'MAG_AUTO from interlaced catalog'),end=True)

    head    = th.header
    tbHDU   = pyfitsOLD.new_table(coldefs, header=head)
    tbHDU.writeto(fitsname, clobber=clobber)
    if verbose: print('   Fits table stored in \n   '+fitsname)

    if genDS9region:
        if verbose: print(' - Generating DS9 region file')
        regionname = fitsname.replace('.fits','.reg')
        kbs.create_DS9region(regionname,ras,decs,color='magenta',circlesize=0.5,textlist=objids.astype(str),clobber=clobber)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def append_JKthesisCat2maininfofile(objinfofile='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits', objrmatch=0.2, overwrite=False, verbose=True):
    """
    Script appending the LAE parameter information from Joesie Kerutt's thesis to the objecet infofile generated with
    uves.build_LAEfitstable()

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.append_JKthesisCat2maininfofile()

    """
    out_file = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/objectinfofile_zGT1p5_3timesUDFcats_JKthesisInfo.fits'
    if os.path.isfile(out_file) and (overwrite == False):
        sys.exit('The output file '+out_file+' already exists and overwrite=False ')

    if verbose: print(' - Loading data ')
    cat_jk     = '/Users/kschmidt/work/catalogs/MUSE_GTO/kerutt_LAEparameters190926_EWs_0_clumps_ratio_line_props.fits'
    hdu_jk     = afits.open(cat_jk)
    dat_jk     = hdu_jk[1].data
    col_jk     = hdu_jk[1].columns
    Ncol_jk    = len(dat_jk.dtype.names)

    hdu_info   = afits.open(objinfofile)
    dat_info   = hdu_info[1].data
    col_info   = hdu_info[1].columns
    Ncol_info  = len(dat_info.dtype.names)

    for cc, colname in enumerate(hdu_jk[1].columns.names):
        if colname.lower() in [cn.lower() for cn in hdu_info[1].columns.names]:
            hdu_jk[1].columns[cc].name = colname.lower()+'_jk'

    xtracol     = afits.ColDefs([afits.Column(name='sep_infoVSjk', format='D',array=np.zeros(len(dat_info))*np.nan)])

    col_out     = col_info + col_jk + xtracol
    hdu_out     = afits.BinTableHDU.from_columns(col_out)

    if verbose: print(' - Fill the columns in the new table looping though info file objects')
    for ii, id in enumerate(dat_info['id']):
        objra      = hdu_info[1].data['ra'][ii]
        objdec     = hdu_info[1].data['dec'][ii]
        rsep       = np.sqrt( (np.cos(np.deg2rad(objdec))*(hdu_jk[1].data['ra_jk']-objra))**2.0 +
                              (hdu_jk[1].data['dec_jk']-objdec)**2.0 )
        # minsep_ent = np.where(rsep == np.min(rsep))[0]
        minsep_ent = np.where(rsep*3600 < objrmatch)[0]
        objselids  = hdu_jk[1].data['id_jk'][minsep_ent]

        if verbose:
            infostr = '   Matching data for id='+str(id)+' ('+str("%.5d" % (ii+1))+' / '+str("%.5d" % len(dat_info['id']))+')     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        jk_ent = np.where(dat_jk['id_jk'].astype(int) == int(id))[0]
        if len(jk_ent) == 1:
            for colname in col_info.names:
                hdu_out.data[colname][ii] = hdu_info[1].data[colname][ii]
            for colname in col_jk.names:
                if colname ==  'z_vac_red': pdb.set_trace()
                hdu_out.data[colname][ii] = hdu_jk[1].data[colname][jk_ent[0]]

            if (len(minsep_ent) > 1):
                useent   = minsep_ent[np.where(objselids == hdu_jk[1].data['id_jk'][jk_ent[0]])[0]]
                hdu_out.data['sep_infoVSjk'][ii] = rsep[useent]*3600
            else:
                hdu_out.data['sep_infoVSjk'][ii] = rsep[minsep_ent]*3600
        else:
            if (len(minsep_ent) > 1):
                print('\n   > WARNING: There were multiple best matches below the threshold ('+str(objrmatch)+'arcsec) for id='+
                      str(id)+', namely id_jk='+str(hdu_jk[1].data['id_jk'][minsep_ent])+' at '+str(rsep[minsep_ent]*3600)+' arcsec')
                bestent   = minsep_ent[np.where(objselids == np.min(objselids))[0]]
                print('   > Selected to match with id_jk='+str(hdu_jk[1].data['id_jk'][bestent[0]])+' (lowest id indicating UDF)\n')
                minsep_ent = bestent

            if (len(minsep_ent) == 1):
                for colname in col_info.names:
                    hdu_out.data[colname][ii] = hdu_info[1].data[colname][ii]
                for colname in col_jk.names:
                    hdu_out.data[colname][ii] = hdu_jk[1].data[colname][minsep_ent[0]]
                hdu_out.data['sep_infoVSjk'][ii] = rsep[minsep_ent]*3600
            elif (len(minsep_ent) == 0):
                for colname in col_jk.names:
                    if hdu_out.data[colname].dtype == int:
                        hdu_out.data[colname][ii] =  - 99
                    elif 'string' in hdu_out.data[colname].dtype.name:
                        hdu_out.data[colname][ii] = 'None'
                    else:
                        hdu_out.data[colname][ii] = np.nan
            else:
                print('Something went wrong in selecting one of the IDs below the threshold ')
                pdb.set_trace()


    hdu_out.writeto(out_file, overwrite=overwrite)
    if verbose: print(' - Output written to:\n   '+out_file)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_LAEidLists(sourcecatalog,skipids=True,includecomponentinfo=True,verbose=True):
    """
    Generate TDOSE setupfiles for the LAE extractions

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    sourcecatalog = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    idlists = uves.get_LAEidLists(sourcecatalog)

    """
    sourcetab = afits.open(sourcecatalog)[1].data
    pointings = np.unique(np.sort(sourcetab['pointing']))

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    counterNB = 0
    counterNC = 0
    ids2skip = []
    if skipids:
        ids2skip.append(121033078)  # Object with CIV being main line (conf=1) with potential Lya; no model available
        ids2skip.append(211049280)  # Potential CIII emitter (conf=1) at 2.76, i.e., no Lya in MUSE

        if includecomponentinfo:
            # IDs with no component corresponding to LAE in model, according to:
            compinfo  = open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/171012_LAEs_component_info.txt','r')
            for ll, line in enumerate(compinfo.readlines()):
                if not line.startswith('#'):
                    cols = line.split()
                    # - - - - - - - - - - - - Check for no assigned components - - - - - - - - - - - -
                    assignedcomponent = False
                    for col in cols:
                        if (len(col) == 3) & (':' in col):
                            if col.split(':')[1] == '1':
                                assignedcomponent = True

                    if not assignedcomponent:
                        counterNC = counterNC+1
                        ids2skip.append(int(cols[1]))
                        if verbose: print('   '+str(ll)+', '+str(counterNC)+
                                          '   No assigned component for '+cols[1]+' as '+
                                          ' '.join(cols[2:8])+'[...]')
                    # - - - - - - Check for neighbors, i.e., dublicate IDs in source catalogs - - - - - -
                    if ' NB ' in line:
                        counterNB = counterNB+1
                        ids2skip.append(int(cols[1]))
                        if verbose: print('   '+str(ll)+', '+str(counterNB)+
                                          "   Close neighbor causing duplicate ID'ing for "+cols[1])
                    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ids2skip  = np.unique(np.sort(np.asarray(ids2skip)))
    Nobj_skip = len(ids2skip)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Nobj      = len(sourcetab['id'])
    if verbose: print(' - Will put id lists together for the '+str(Nobj-Nobj_skip)+
                      '; (Nobj, Nobj_NB, Nobj_Ncomp, Nobj_skip) = ('+str(Nobj)+', '+str(counterNB)+', '+str(counterNC)+', 2)')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    idlists = {}

    for pp, pointing in enumerate(pointings):
        objents     = np.where(sourcetab['pointing'] == pointing)[0]
        idlist      = []
        for laeid in sourcetab['id'][objents]:
            if not laeid in ids2skip:
                idlist.append(laeid)

        if verbose: print(pointing+'    '+str(idlist).replace(', ',','))
        idlists[pointing] = idlist

    return idlists
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_LAEsourceCats(outputdir,sourcecatalog,modelcoord=False,verbose=True):
    """
    Generating MUSE-Wide pointing source catalogs for TDOSE extraction of LAEs

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.gen_LAEsourceCats('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats/','/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits',modelcoord=True)

    """
    sourcetab = afits.open(sourcecatalog)[1].data
    pointings = np.unique(np.sort(sourcetab['pointing']))

    for pp, pointing in enumerate(pointings):
        objents     = np.where(sourcetab['pointing'] == pointing)[0]
        pointingcat = outputdir+'tdose_sourcecat_LAEs_'+pointing+'.txt'
        fout = open(pointingcat,'w')
        fout.write('# TDOSE Source catalog generated with uvEmissionlineSearch.gen_LAEsourceCats() \n')
        fout.write('# \n')
        fout.write('# parent_id id ra dec x_image y_image fluxscale \n')

        # if '02' in pointing:        pdb.set_trace()
        ids2skip = []
        ids2skip.append(121033078)  # Object with CIV being main line (conf=1) with potential Lya; no model available
        ids2skip.append(211049280)  # Potential CIII emitter (conf=1) at 2.76, i.e., no Lya in MUSE

        for objent in objents:
            objstr = ' -99  '

            if sourcetab['ID'][objent] in ids2skip:
                continue
            else:
                objstr = objstr + str(sourcetab['ID'][objent]) + ' '
                if modelcoord == True:
                    objstr = objstr + str(sourcetab['ra_model'][objent]) + ' '
                    objstr = objstr + str(sourcetab['dec_model'][objent]) + ' '
                    objstr = objstr + str(sourcetab['x_image_model'][objent]) + ' '
                    objstr = objstr + str(sourcetab['y_image_model'][objent]) + ' '
                else:
                    objstr = objstr + str(sourcetab['RA'][objent]) + ' '
                    objstr = objstr + str(sourcetab['DEC'][objent]) + ' '
                    objstr = objstr + str(sourcetab['x_image_F814W'][objent]) + ' '
                    objstr = objstr + str(sourcetab['y_image_F814W'][objent]) + ' '
                objstr = objstr + ' 1.0000 ' + ' \n'

                fout.write(objstr)
        fout.close()

        pointingcat_fits = f2a.ascii2fits(pointingcat,asciinames=True,skip_header=2,fitsformat='D',verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_LAEsourceCats_fromGALFITmodelCubeSourceCats(outputdir,sourcecatalog,modelsourcecatdir,ignore99s=False,verbose=True):
    """
    Generating MUSE-Wide pointing source catalogs for TDOSE extraction of LAEs where all objects from
    the source catalogs generated when converting GALFIT models into cubes are combined

    --- INPUT ---
    outputdir            Output directory to contain pointing source catalogs
    sourcecatalog        Source catalog of LAEs to get pointing names from
    modelsourcecatdir    Directory containing the source catalogs generated when converting
                         LAE galfit models into cubes that TDOSE can understand for the spectral extractions.
    ignore99s            Ignore objects with (parent)IDs of -99? These are the central coordinates of the models.

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    outputdir         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats/'
    sourcecat         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    modelsourcecatdir = '/Volumes/DATABCKUP1/TDOSEextractions/MW_LAEs_JKgalfitmodels/'

    uves.gen_LAEsourceCats_fromGALFITmodelCubeSourceCats(outputdir,sourcecat,modelsourcecatdir,ignore99s=False)

    """
    sourcetab = afits.open(sourcecatalog)[1].data
    pointings = np.unique(np.sort(sourcetab['pointing']))

    for pp, pointing in enumerate(pointings):
        modelsourcecats = glob.glob(modelsourcecatdir+'/*'+pointing+'*_sourcecatalog.txt')

        pointingcat     = outputdir+'tdose_sourcecat_LAEs_'+pointing+'.txt'
        fout = open(pointingcat,'w')
        fout.write('# TDOSE Source catalog generated with uvEmissionlineSearch.gen_LAEsourceCats_fromGALFITmodelCubeSourceCats() on '+tu.get_now_string()+'  \n')
        fout.write('# \n')
        fout.write('# parent_id id ra dec x_image y_image fluxscale \n')

        for modcat in modelsourcecats:
            catinfo = open(modcat,'r')
            for line in catinfo.readlines():
                if line.startswith('#'):
                    pass
                else:
                    if ignore99s:
                        if line.split()[0] == '-99':
                            pass
                        else:
                            fout.write(line)
                    else:
                        fout.write(line)
        fout.close()

        pointingcat_fits = f2a.ascii2fits(pointingcat,asciinames=True,skip_header=2,fitsformat='D',verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_LAEsourceCats_FromPhotCat(outputdir,MUSEIDlist,LAEinfo,sourcecatradius=15.0,photcat='skelton',
                                  refimgdir='/Volumes/DATABCKUP1/MUSE-Wide/hst_cutouts/',returnSeparations=False,
                                  clobber=False,verbose=True):
    """
    Generate source catalogs based on photometric catalogs for individual MUSE Wide objects
    but adding the LSDCat coordinates as seperate soource


    --- INPUT ---
    outputdir            Output directory to contain object source catalogs
    MUSEIDlist           List of objects to generate source catalogs for
    LAEinfo              LAE info file
    sourcecatradius      Radius to search and return in the source catalogs
    photcat              The photmetric cataog to match to
    refimgdir            The reference image directory used to get WCS info
    returnSeparations    Return the separations in the fluxscale column of the source catalog

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    outputdir         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats_noModelComponent/'
    LAEinfo           = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    MUSEIDlist        = [121033078,211015198]
    #MUSEIDlist        = [101005016,117027076,123016117,125049122,141003075,144008046,146069355,201073224,202013030,202044085,203007099,204053120,206014089,207022169,209006108,211015198,212029067,213022109,215016042]
    uves.gen_LAEsourceCats_FromPhotCat(outputdir,MUSEIDlist,LAEinfo,photcat='skelton',returnSeparations=False)

    """
    LAEinfo = afits.open(LAEinfo)[1].data

    for Mid in MUSEIDlist:
        idstr = str(Mid)
        if idstr.startswith('1') or idstr.startswith('6'):
            if photcat == 'skelton': # GOODS-S (incl. UDF)
                fitscat = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
            elif photcat == 'guo':
                fitscat = '/Users/kschmidt/work/catalogs/guo/CANDELS.GOODSS.F160W.v1.fits'
            else:
                print(' WARNING photcat = '+photcat+' has no setup for GOODS-S source; using Skelton catalog ')
                fitscat = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
        elif idstr.startswith('2'): # COSMOS
            if photcat == 'skelton':
                fitscat = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
            else:
                print(' WARNING photcat = '+photcat+' has no setup for COSMOS source; using Skelton catalog ')
                fitscat = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
        # elif idstr.startswith('6'): # UDF
        #     if photcat == 'skelton':
        #         print(' WARNING photcat = '+photcat+' will be ignored, as object in UDF where Rafelski will be used')
        #         fitscat = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
        #     else:
        #         print(' WARNING photcat = '+photcat+' has no setup for COSMOS source; using Skelton catalog ')
        #         fitscat = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
        else:
            sys.exit(' MUSE-Wide id = '+idstr+' is neither in GOODS-S (starts with "1") nor in COSMOS (starts with "2")')

        objent  = np.where(LAEinfo['id'] == Mid)[0]
        objra   = LAEinfo['ra'][objent][0]
        objdec  = LAEinfo['dec'][objent][0]
        if len(objent) == 0:
            print(' WARNING No match in LAE info file for MUSE-Wide_ID = '+idstr)

        refimg       = refimgdir+'acs_814w_'+LAEinfo['pointing'][objent][0]+'_cut_v1.0.fits'
        if idstr.startswith('6'):
            refimg   = refimgdir+'hlsp_hlf_hst_acs-30mas_goodss_f775w_udf-mosaic_v1.5_sci.fits'
        imgheader    = afits.open(refimg)[0].header
        sourcelist   = [ [Mid, Mid, objra, objdec, 1]]
        outname      = outputdir+'tdose_sourcecat_from_fitscat_id'+idstr+'.txt'

        if returnSeparations:
            fluxfactor = 'separation'
        else:
            fluxfactor = 1.0

        sourcecat    = tu.gen_sourcecat_from_FitsCat(fitscat,'id','ra','dec',[objra,objdec],sourcecatradius,imgheader,
                                                     fluxfactor=fluxfactor,outname=outname,newsources=sourcelist,
                                                     clobber=clobber,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_GALFITmodelcubes(GALFITmodels,outputdir,PSFmodels=None,PSFmodelext=2,sourcecat_compinfo=None,
                         refnamebase='model_acs_814w_PPPP_cut_v1.0_idIIII_cutout2p0x2p0arcsec.fits',
                         pointsourcefile=None,pointsourcescale=1.0,ignore_radius=0.5,clobber=False,verbose=True):
    """

    Function loading galfit models from modelinputdir (assumed to be names as imgblock_ID.fits), renaming them,
    converting them to cubes and generating the corresponding source catalogs needed by TDOSE. It also generates
    a template component info file which can be edited (after copying to a new file) and be provided back to the
    script for a second run updating the the cubes and source catalogs accordingly.

    --- INPUT ---


    --- EXMAMPLE OF USE ---
    import glob
    import uvEmissionlineSearch as uves

    GALFITmodels    = glob.glob('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/imgblocks_josieGALFITmodels/imgblock_*.fits')
    outputdir       = '/Volumes/DATABCKUP2/TDOSEextractions/MW_LAEs_JKgalfitmodels/'
    PSFmodels       = ['/Users/kschmidt/work/MUSE/uvEmissionlineSearch/F814Wpsfmodel_imgblock_6475.fits']*len(GALFITmodels)
    pointsourcefile = None #'/Users/kschmidt/work/MUSE/uvEmissionlineSearch/pointsourceobjects.txt'
    uves.gen_GALFITmodelcubes(GALFITmodels,outputdir,PSFmodels=PSFmodels,sourcecat_compinfo=None,pointsourcefile=pointsourcefile)

    """
    Nmodels = len(GALFITmodels)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Renaming files of '+str(Nmodels)+' models profived to GALFITmodels keyword')
    models_renamed = []
    model_ids      = []
    for modelname in GALFITmodels:
        objid    = modelname.split('block_')[-1].split('.fit')[0]
        pointing = mu.gen_pointingname(objid)
        newname  = outputdir+'/'+refnamebase.replace('IIII',str(objid)).replace('PPPP',pointing)
        cpcmd    = ' cp '+modelname+' '+newname
        if os.path.isfile(newname) & (clobber == False):
            if verbose: print(' clobber = False and '+newname+' already exists, so moving on to next file.')
        else:
            cpout = commands.getoutput(cpcmd)
        models_renamed.append(newname)
        model_ids.append(objid)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if pointsourcefile is not None:
        if verbose: print(' - Assembling list of models for objects to use point source extractions for ')
        pointsources      = np.genfromtxt(pointsourcefile,dtype=None,comments='#')
        try:
            pointsourcescales = [pointsourcescale]*len(pointsources)
            ignore_radii      = [ignore_radius]*2 # same radius in x and y dimension
        except:
            pointsourcescales = pointsourcescale
            ignore_radii      = ignore_radius
    else:
        pointsources      = None
        pointsourcescales = 'dummy'
        ignore_radii      = 'dummy'

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if PSFmodels is None:
        PSFlist = None
    else:
        if verbose: print(' - Loading PSF models ')
        if type(PSFmodels) is list:
            PSFlist = []
            if type(PSFmodelext) is not list:
                PSFmodelext = [PSFmodelext] * len(PSFmodels)
            for mm, PSFmodel in enumerate(PSFmodels):
                PSFlist.append(afits.open(PSFmodel)[PSFmodelext[mm]].data)
        else:
            PSFlist = [afits.open(PSFmodels)[PSFmodelext].data]*len(GALFITmodels)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    gen_compinfofile = True
    if sourcecat_compinfo is None:
        compinfofile = None
    else:
        if os.path.isfile(sourcecat_compinfo):
            if verbose: print(' - Will use existing point source component file provided:\n   '+sourcecat_compinfo)
            compinfofile     = sourcecat_compinfo
            gen_compinfofile = False
            if verbose: print('   (no new file/template will be generated)')
        else:
            compinfofile = None

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Building cubes from renamed GALFIT models')
    # newlist = []
    # for mod in models_renamed:
    #     if 'id12400' in mod: newlist.append(mod)
    # models_renamed = newlist

    tu.galfit_convertmodel2cube(models_renamed,includewcs=True,savecubesumimg=True,convkernels=PSFlist,
                                sourcecat_compinfo=compinfofile,normalizecomponents=True,pointsources=pointsources,
                                ignore_radius=ignore_radii,pointsourcescales=pointsourcescales,includesky=False,
                                clobber=clobber,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if gen_compinfofile:
        if verbose: print(' - Generating component info file template for source catalog updates')
        skip = False
        if sourcecat_compinfo is None:
            compinfofile = './component_info_template_RENAME_.txt'
            if os.path.isfile(compinfofile) & (clobber == False):
                if verbose: print('   ... but '+compinfofile+' exists and clobber=False, so skipping.')
                skip = True
        else:
            if os.path.isfile(compinfofile) & (clobber == False):
                if verbose: print('   ... but '+compinfofile+' exists and clobber=False, so skipping.')
                skip = True
            else:
                compinfofile = sourcecat_compinfo

        if not skip:
            fout = open(compinfofile,'w')
            fout.write("""# TDOSE source catalog components keys for J. Kerutt's 2x2 arcsec GALFIT models of the MUSE-Wide LAEs from
# the first 60 MUSE-Wide pointings.
#
# --- TEMPLATE --- generated with uvEmissionlineSearch.gen_GALFITmodelcubes() on %s
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# modelfilename        Path and name of model file
# id                   MUSE-Wide object ID
# componentinfo        Information on the model components given as ComponentNumber:InfoKey
#                      where the info keys are:  1 = object, 2 = contaminant and 3 = sky
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The following default notes are used for commenting after ">>>Notes>>>:" (appended by notes from JK's inspection)
#
# NoteKey      ShortRef           NoteExplanation
#
# ND           Non Detection      A (visual) non detection in all the optical bands (606, 775W, 814W, 850LP)
# PS           Point Source       Add a point source at central location to represent the soource
# BD           Blue detection     Detection in filters blue-wards of the Lyalpha line (filters not including the Lyalpha wavelength)
# WD           Weak drop          There is a week drop in the filters blue wards of the Lyalpha line
# MO           Model offset       The model appears offset compared to LSDCat (Lyalpha) location
# NBid         Neighbor           A neioghboring LAE (with id "id") which can potentially cause confusion/overlap of LAE spectra exists
# DFfilter     Detection Filter   Object only detected in (a few) filters. Indicate those with multiple DFfilter comments
# OCtext       Other Comment      Anything else to comment on? Follow comment by text
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# modefilename  id  componentinfo
""" % tu.get_now_string())

            for mm, GFmodel in enumerate(GALFITmodels):
                modelheader = afits.open(models_renamed[mm])[2].header
                compstring  = ' '
                for key in modelheader.keys():
                    if 'COMP_' in key:
                        compNo = key.split('OMP_')[-1]
                        if modelheader[key] == 'sky':
                            compstring = compstring + compNo + ':3  '
                        else:
                            compstring = compstring + compNo + ':?  '

                outstring = models_renamed[mm]+'  '+model_ids[mm]+'  '+compstring.ljust(50)+\
                            '     # >>>Notes>>>:  ND  PS  BD  WD  MO  NBid  DFfilter  OCtext    >>>JK notes>>>: '
                jknotes   = open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/imgblocks_josieGALFITmodels_all_ids.txt','r')
                for line in jknotes.readlines():
                    if str(model_ids[mm]) in line:
                        outstring = outstring+'  '+line.replace('\n','').replace('	','   ')+'  '
                jknotes.close()
                fout.write(outstring+' \n')
            fout.close()
            if verbose: print(' - Wrote component info to: '+compinfofile)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def inspect_GALFITmodels(modeldir='/Volumes/DATABCKUP2/TDOSEextractions/MW_LAEs_JKgalfitmodels/',
                         imgdir='/Volumes/DATABCKUP2/MUSE-Wide/hst_cutouts/',modelstart=1,showPhotRegions=True,
                         objids=None,verbose=True):
    """
    Script to put open DS9 windows showing galfit models so they can be inspected

    --- INPUT ---
    modeldir     Directory containing models to display
    modelstart   Where to start the inspection in list of models/objects. Useful to skip ahead in long object lists.
                 E.g. when all models in a directory are to be inspected. First model has modelstart=1
    objids       List of objects ids to display. If None, all objects found in modeldir will be displayed

    --- EXAMPLE OF USE ---

    models = glob.glob('/Volumes/DATABCKUP2/TDOSEextractions/MW_LAEs_JKgalfitmodels/model*arcsec.fits')
    tu.galfit_model_ds9region(models,clobber=True)

    uves.inspect_GALFITmodels(modelstart=3)

    """
    import commands # only works on Python2.7; has to convert to subprocess.Popen() for Python3
    LAEinfo = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data

    if objids is None:
        GALFITmodels = glob.glob(modeldir+'model*arcsec.fits')
    else:
        GALFITmodels = []
        for objid in objids:
            GALFITmodels = GALFITmodels + [mod for mod in glob.glob(modeldir+'model*'+str(objid)+'*arcsec.fits')]
    GALFITmodels      = np.asarray(GALFITmodels)
    if verbose: print(' - Found '+str(len(GALFITmodels))+' GALFIT models')

    loopmodels        = GALFITmodels[modelstart-1:]

    MWregion_cosmos   = '/Users/kschmidt/work/catalogs/MUSE_GTO/MUSE-Wide_objects_cosmos.reg' #candels_cosmos_pointings-all.reg'
    MWregion_cdfs     = '/Users/kschmidt/work/catalogs/MUSE_GTO/MUSE-Wide_objects_cdfs.reg' #candels_cdfs_pointings-all.reg'

    if verbose: print(' - Will look through '+str(len(loopmodels))+' of the models starting with model number '+str(modelstart))

    ds9cmd       = "ds9 -view layout vertical -lock frame wcs -height 650 -width 650 -tile grid layout 4 4 "
    pds9         = subprocess.Popen(ds9cmd,shell=True,executable=os.environ["SHELL"])
    time.sleep(1.1)# sleep to make sure ds9 appear in PIDlist
    for ii in np.arange(1,13):
        out = commands.getoutput('xpaset -p ds9 frame new')
    out = commands.getoutput('xpaset -p ds9 tile yes ')

    Guo_goodss_reg     = '/Users/kschmidt/work/catalogs/guo/CANDELS.GOODSS.F160W.v1_ds9.reg'
    Skelton_goodss_reg = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat_ds9.reg'
    Skelton_cosmos_reg = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat_ds9.reg'

    for mm, GFmodel in enumerate(loopmodels):
        if verbose:
            infostr = '   Displaying files for model '+str("%.5d" % (mm+1))+' / '+str("%.5d" % len(loopmodels))+' in DS9.'
            print(infostr)

        modelid      = GFmodel.split('_id')[-1][:9]
        compregion   = GFmodel.replace('.fits','_ds9region.reg')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        out = commands.getoutput('xpaset -p ds9 frame 1 ')
        out = commands.getoutput('xpaset -p ds9 file '+GFmodel+'[1]')
        out = commands.getoutput('xpaset -p ds9 regions '+compregion)
        out = commands.getoutput('xpaset -p ds9 zoom to fit ')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        out = commands.getoutput('xpaset -p ds9 frame 2 ')
        out = commands.getoutput('xpaset -p ds9 file '+GFmodel+'[2]')
        out = commands.getoutput('xpaset -p ds9 regions '+compregion)
        out = commands.getoutput('xpaset -p ds9 zoom to fit ')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        modelcubesum = GFmodel.replace('.fits','_cubesum.fits')
        if os.path.isfile(modelcubesum):
            out = commands.getoutput('xpaset -p ds9 frame 4 ')
            out = commands.getoutput('xpaset -p ds9 file '+modelcubesum)
            out = commands.getoutput('xpaset -p ds9 regions '+compregion)

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        HSTcutouts   = glob.glob(imgdir+'*'+GFmodel.split('/')[-1][15:-37]+'*fits')
        for cc, HSTcutout in enumerate(HSTcutouts):
            out = commands.getoutput('xpaset -p ds9 frame '+str(5+cc))
            out = commands.getoutput('xpaset -p ds9 file '+HSTcutout)
            if 'cosmos' in HSTcutout:
                out = commands.getoutput('xpaset -p ds9 regions '+MWregion_cosmos)
                if showPhotRegions & ('814' in HSTcutout):
                    out = commands.getoutput('xpaset -p ds9 regions '+Skelton_cosmos_reg)
            else:
                out = commands.getoutput('xpaset -p ds9 regions '+MWregion_cdfs)
                if showPhotRegions & ('814' in HSTcutout):
                    out = commands.getoutput('xpaset -p ds9 regions '+Skelton_goodss_reg)
                    out = commands.getoutput('xpaset -p ds9 regions '+Guo_goodss_reg)

            out = commands.getoutput('xpaset -p ds9 scale log 1 10')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        modelcube = GFmodel.replace('.fits','_cube.fits')
        if os.path.isfile(modelcube):
            out = commands.getoutput('xpaset -p ds9 frame 3 ')
            out = commands.getoutput('xpaset -p ds9 file '+modelcube)
            out = commands.getoutput('xpaset -p ds9 regions '+compregion)
            out = commands.getoutput('xpaset -p ds9 zoom to fit ')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        narrowbandimages = glob.glob(modeldir+'*'+modelid+'*narrowbandimage*.fits')
        if len(narrowbandimages) > 0:
            for nn, nbimg in enumerate(narrowbandimages):
                out = commands.getoutput('xpaset -p ds9 frame '+str(13+nn))
                out = commands.getoutput('xpaset -p ds9 file '+nbimg)
                if 'cosmos' in GFmodel:
                    out = commands.getoutput('xpaset -p ds9 regions '+MWregion_cosmos)
                else:
                    out = commands.getoutput('xpaset -p ds9 regions '+MWregion_cdfs)
            out = commands.getoutput('xpaset -p ds9 zoom to fit ')

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        # Printing info of object
        if verbose:
            objent =  np.where(LAEinfo['ID'] == int(modelid))
            print('   ID        =  '+modelid)
            print('   [ra,dec]  = ['+str(LAEinfo['RA'][objent][0])+','+str(LAEinfo['DEC'][objent][0])+']')
            print('   zMUSE     = '+str(LAEinfo['redshift'][objent][0]))
            lamLya    = (LAEinfo['redshift'][objent][0]+1.0) * 1216.0
            print('   lamdaLya  = '+str("%.2f" % lamLya))
            bandsLya  = uves.wavelength_in_bands(lamLya)
            print('   bandsLya  = '+str(bandsLya))
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print('\n Move on to the next model (y/n)? ')
        input = raw_input()
        if (input.lower() == 'y') or (input.lower() == 'yes'):
            continue
        else:
            if verbose: print('\n - Okay; then shutting down ')
            return
    if verbose: print('\n - Done; no more objects in loop')
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def wavelength_in_bands(wavelength):
    """
    Returning band names containing a given wavelength
    Can be used to return bands where a certain emission line is included

    Band widths are taken from
    http://svo2.cab.inta-csic.es/svo/theory/fps3/index.php?mode=browse&gname=HST&gname2=ACS_WFC

    Curves are at
    http://www.stsci.edu/hst/wfc3/ins_performance/UVIS_sensitivity/UVIS_Longx.jpg
    http://www.stsci.edu/hst/wfc3/ins_performance/UVIS_sensitivity/UVIS_Wide1.jpg
    http://www.stsci.edu/hst/wfc3/ins_performance/UVIS_sensitivity/UVIS_Wide2.jpg
    http://www.stsci.edu/hst/wfc3/ins_performance/IR_sensitivity/IR4_Wide1_single.jpg
    Linked from
    http://www.stsci.edu/hst/wfc3/ins_performance/ground/components/filters

    """
    infodic           = {}
    infodic['F275W']  = [2286,3120]
    infodic['F336W']  = [3014,3707]
    infodic['F435W']  = [3599,4861]
    infodic['F606W']  = [4634,7180]
    infodic['F775W']  = [6804,8632]
    infodic['F814W']  = [6885,9648]
    infodic['F850LP'] = [8007,10865]
    infodic['F105W']  = [8947,12129]
    infodic['F125W']  = [10845,14139]
    infodic['F160W']  = [13854,16999]

    bands = []
    for key in infodic.keys():
        if (wavelength >= infodic[key][0]) & (wavelength <= infodic[key][1]):
            bands.append(key)

    return bands
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_TDOSEsetupfiles(infofile,namebase='MUSEWide_tdose_setup_LAEs',clobber=False,
                        outputdir='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_setupfiles/',verbose=True):
    """
    Generate TDOSE setupfiles for the LAE extractions

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    infofile = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_setupfiles/MUSEWide_infofile_arche_PSFupdate_LAEs.txt'
    uves.gen_TDOSEsetupfiles(infofile)

    """
    tu.duplicate_setup_template(outputdir,infofile,namebase=namebase,clobber=clobber,loopcols='all',infofmt="S250",infohdr=2)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def rename_models(outputdir,sourcecatalog,cutoutsize=[2.0,2.0],clobber=False,
                  modeldir='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/imgblocks_josieGALFITmodels/',verbose=True):
    """
    Renmae GALFIT models to comply with TDOSE naming convention (i.e. so TDOSE can find the models when
    looking for them using model_*refimage+cutoutstring*)

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    outputdir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/ref_image_galfit_models/'
    sourcecatalog = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    uves.rename_models(outputdir,sourcecatalog,cutoutsize=[2.0,2.0],clobber=False)
    """
    modelfiles = glob.glob(modeldir+'/imgblock*.fits')
    sourcetab  = afits.open(sourcecatalog)[1].data
    if verbose: print(' - Found '+str(len(modelfiles))+' in modeldir to rename ')

    for oldname in modelfiles:
        id     = oldname.split('/')[-1].split('_')[-1].split('.fit')[0]
        objent = np.where(sourcetab['id'] == int(id))[0]

        if len(objent) != 1:
            print(' - No match in sourcecatalog to object '+id)
        else:
            pointing = sourcetab['pointing'][objent][0]

            if cutoutsize is None:
                cutoutstr = ''
            else:
                cutoutstr = ('_id'+str("%.9d" % float(id))+'_cutout'+str(cutoutsize[0])+
                             'x'+str(cutoutsize[1])+'arcsec').replace('.','p')

            if 'cdfs' in pointing:
                newname = outputdir+'model_acs_814w_'+pointing+'_cut_v1.0'+cutoutstr+'.fits'
            elif 'cosmos' in pointing:
                newname = outputdir+'model_acs_814w_'+pointing+'_cut_v1.0'+cutoutstr+'.fits'

            if os.path.isfile(newname) & (clobber == False):
                print(' - Clobber = False and '+newname+' already exists so no new copy made. Moving on')
            else:
                if verbose: print(' - Copying '+oldname+' to '+newname)
                shutil.copy(oldname,newname)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_ModelReferencePixelCoordinates(modeldir,pixpos='center',printcoords=True,verbose=True):
    """
    Extract the reference coordinates of the GALFIT models from the fits headers

    PROBLEM! GALFIT apparantly doesn't propogate the coordinates of the cutouts. It quotes the reference
             pixel coordinate from the image the cutout was generated from. In the case of the MUSE cutouts
             this means that the coordiantes are the reference position for the fullf-FoV muse pointing
             cutouts and not the individual object cutouts GALFIT is modeling.

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    modeldir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/ref_image_galfit_models/'
    coordarray   = uves.get_ModelReferencePixelCoordinates(modeldir,printcoords=True,verbose=True)

    """
    modelfiles = glob.glob(modeldir+'*.fits')
    Nfiles     = len(modelfiles)
    if verbose: print(' - Found '+str(Nfiles)+' models to extract coordinates from ')

    if verbose: print(' - Looping over models and extracting coordinates from: ')
    coordarray = np.zeros(Nfiles, dtype={'names':['modelfile','xpix','ypix','ra','dec'],
                                         'formats':['a250', 'f8', 'f8', 'f8', 'f8']})
    for mm, modelfile in enumerate(modelfiles[0:5]):
        model_refimghdr = afits.open(modelfile)[1].header
        imgwcs    = wcs.WCS(tu.strip_header(model_refimghdr.copy()))

        if pixpos == 'center':
            model_shape     = afits.open(modelfile)[1].data.shape
            xpix      = int(model_shape[1]/2.)
            ypix      = int(model_shape[0]/2.)
        else:
            xpix      = pixpos[1]
            ypix      = pixpos[0]

        print(imgwcs)
        skycoord  = wcs.utils.pixel_to_skycoord(xpix,ypix,imgwcs, origin=0)
        ra        = skycoord.ra.value
        dec       = skycoord.dec.value

        if printcoords & verbose:
            print('   '+modelfile.split('/')[-1]+':  (ra,dec) = ('+str(ra)+','+str(dec)+')')

        coordarray['modelfile'][mm] = modelfile
        coordarray['xpix'][mm]      = xpix
        coordarray['ypix'][mm]      = ypix
        coordarray['ra'][mm]        = ra
        coordarray['dec'][mm]       = dec

    return coordarray
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_narrowbandimages(LAEinfofile,datacubestring,outputdir,linewaves=[1216,1549,1909],fwhmkey='FWHM',
                         clobber=False,verbose=True):
    """
    Generate narrow band images around the location for a set of emission lines.

    If FWHM value is found in LAEinfo file, the relation from Verhamme+17 is used to predict systemic redshift

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    LAEinfofile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    datacubestring = '/Volumes/DATABCKUP2/MUSE-Wide/datacubes_dcbgc_effnoised/DATACUBE_PPPP_v1.0_dcbgc_effnoised.fits'
    outputdir      = '/Volumes/DATABCKUP2/TDOSEextractions/MW_LAEs_JKgalfitmodels/'

    uves.gen_narrowbandimages(LAEinfofile,datacubestring,outputdir,linewaves=[1216,1549,1909],fwhmkey='FWHM',verbose=True)

    """
    LAEinfo = afits.open(LAEinfofile)[1].data

    pointings = LAEinfo['pointing']

    for pointing in np.unique(np.sort(pointings)):
        pointing_objs = np.where(pointings == pointing)[0]

        datacube = glob.glob(datacubestring.replace('PPPP',pointing))

        if len(datacube) == 0:
            if verbose: print(' -----> WARNING No data cube found globbing for ')
            if verbose: print('        '+datacubestring.replace('PPPP',pointing))
        elif len(datacube) > 1:
            if verbose: print(' -----> WARNING More than 1 data cube found globbing for ')
            if verbose: print('        '+datacubestring.replace('PPPP',pointing))
            if verbose: print('        Using the first found in the list, i.e., ')
            datacube = datacube[0]
            if verbose: print('        Extracting from: '+datacube)
        else:
            datacube = datacube[0]
            if verbose: print('\n - Extracting from: '+datacube)

        ras       = LAEinfo['ra'][pointing_objs]
        decs      = LAEinfo['dec'][pointing_objs]
        names     = LAEinfo['id'][pointing_objs].astype(str)
        redshifts = LAEinfo['redshift'][pointing_objs]

        if fwhmkey in  LAEinfo.columns.names:
            fwhms = LAEinfo[fwhmkey][pointing_objs]
        else:
            fwhms = []

        wcenters = []
        dwaves   = []
        for redshift in redshifts:
            wcen = []
            dwav = []
            if len(fwhms) != 0:
                if verbose: print(' - Estimating systemic redshift using Verhamme+17 z_sys vs Lya_FWHM relation ')
                zsys = None
            else:
                zsys = redshift

            for lw in linewaves:
                if lw == 1216:
                    wcen.append(lw*(redshift+1.0))
                    dwav.append(10)
                else:
                    wcen.append(lw*(zsys+1.0))
                    dwav.append(10)

            wcenters.append(wcen)
            dwaves.append(dwav)

        mu.create_narrowband_subcube(datacube,ras,decs,5.0,5.0,wcenters,dwaves,outputdir,names=names,clobber=clobber)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def estimate_limits(spectra,sourcecatalog,lines=['lya','civ','ciii'],deltalam=10,plot=True,verbose=True,printresults=False):
    """
    Get limits at line locations from 1D spectra

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves, glob
    spectra       = glob.glob('/Volumes/DATABCKUP1/TDOSEextractions/tdose_spectra/tdose_spectrum_candels*.fits')
    sourcecatalog = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits'
    limit_output  = uves.estimate_limits(spectra,sourcecatalog,lines=['lya','civ','ciii'],deltalam=3)

    plotbasename = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/estimatelimits'
    uves.plot_limits(sourcecatalog,plotbasename,limit_output)

    """
    if verbose: print(' - Loading source catalog ')
    sourcecat = afits.open(sourcecatalog)[1].data

    Nspec = len(spectra)
    if verbose: print(' - Will estimate limits for lines '+str(lines)+' for '+str(Nspec)+' spectra found')
    outputdic = {}
    outputdic['deltalam'] = deltalam


    for ll, line in enumerate(lines):
        if line.lower() == 'lya':
            line_lams  = [1215.6737]
            use_sys    = False
            keys       = ['lya']
        elif line.lower() == 'civ':
            line_lams  = [1548.195,1550.770]
            use_sys    = True
            keys       = ['civ1548','civ1551']
        elif line.lower() == 'ciii':
            line_lams  = [1907.00,1909.00]
            use_sys    = True
            keys       = ['ciii1907','ciii1909']
        elif line.lower() == 'heii':
            line_lams  = [1640.420]
            use_sys    = True
            keys       = ['heii1640']
        elif line.lower() == 'nv':
            line_lams  = [1238.821,1242.804]
            use_sys    = True
            keys       = ['nv1239','nv1243']

        else:
            sys.exit(' Did not find any setups for the line designated '+line)

        for ll, line_lam in enumerate(line_lams):
            ids                 = []
            # v v v   From uves.lineinfofromspec()   v v v
            fluxval             = []
            fluxerr             = []
            SNval               = []
            fluxval_Dlam        = []
            fluxstd_Dlam        = []
            fluxerr_Dlam        = []
            SNval_Dlam          = []
            fluxval_Dlam_max    = []
            SNval_Dlam_max      = []
            fluxval_Dlam_sum    = []
            SNval_Dlam_sum      = []
            # ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
            EW                  = []
            EW_Dlam             = []
            EW_Dlam_sum         = []

            if verbose: print(' - Looping over spectra for line = '+keys[ll])
            for ss, spec in enumerate(spectra):
                id       = spec.split('/')[-1].split('.fit')[0][-9:]
                objent   = np.where(sourcecat['id'] == int(id))[0]
                specdat  = afits.open(spec)[1].data
                spec_lam = specdat['wave']
                spec_f   = specdat['flux']
                spec_err = specdat['fluxerror']
                spec_s2n = specdat['s2n']

                if use_sys:
                    try:
                        z_lam    = sourcecat['z_sys_AV17'][objent] # using systemic redshift
                    except:
                        z_lam    = sourcecat['z_sys_V18'][objent] # using systemic redshift
                else:
                    z_lam    = sourcecat['z_vac_red'][objent]  # using Lya redshiftfrom red peak

                line_wave  = (z_lam+1)*line_lam
                lineinfo   = uves.lineinfofromspec(line_wave,spec_lam,spec_f,spec_err,spec_s2n,
                                                   deltalam=deltalam,verbose=verbose)

                ids.append(id)

                fluxval.append(lineinfo[0])
                fluxerr.append(lineinfo[1])
                SNval.append(lineinfo[2])
                fluxval_Dlam.append(lineinfo[3])
                fluxstd_Dlam.append(lineinfo[4])
                fluxerr_Dlam.append(lineinfo[5])
                SNval_Dlam.append(lineinfo[6])
                fluxval_Dlam_max.append(lineinfo[7])
                SNval_Dlam_max.append(lineinfo[8])
                fluxval_Dlam_sum.append(lineinfo[9])
                SNval_Dlam_sum.append(lineinfo[10])

                # - - - - -  Estimate EW  - - - - -
                beta          = sourcecat['beta'][objent][0]
                try:
                    bandswithLya  = uves.wavelength_in_bands( 1216 * (sourcecat['z_sys_AV17'][objent][0] + 1))
                except:
                    bandswithLya  = uves.wavelength_in_bands( 1216 * (sourcecat['z_sys_V18'][objent][0] + 1))
                bandswithline = uves.wavelength_in_bands( line_wave )

                f_cont        = []
                bands         = ['F606W','F775W','F814W','F125W']
                wave_refs     = [6034.0,7730.0,8140.2,12516.2]
                for bb, band in enumerate(bands):
                    if (band not in bandswithLya) & (band not in bandswithline):
                        if band == 'F125W':
                            f_ref  = sourcecat[ 'flux_wfc3_'+band.lower()[1:] ][objent][0] * 1e20
                        else:
                            f_ref  = sourcecat[ 'flux_acs_'+band.lower()[1:] ][objent][0] * 1e20
                        f_wave = uves.estimate_continuumlevel_viaBeta(line_wave, wave_refs[bb], f_ref, beta, verbose=False)
                        f_cont.append(f_wave)

                if (len(f_cont) > 0):
                    EW.append( fluxval[ss] / np.mean(np.asarray(f_cont)) )
                else:
                    EW.append( np.NaN )

                if (len(f_cont) > 0):
                    EW_Dlam.append( fluxval_Dlam[ss] / deltalam / np.mean(np.asarray(f_cont)) )
                else:
                    EW_Dlam.append( np.NaN )

                if (len(f_cont) > 0):
                    EW_Dlam_sum.append( fluxval_Dlam_sum[ss] / deltalam / np.mean(np.asarray(f_cont)) )
                else:
                    EW_Dlam_sum.append( np.NaN )

                # - - - - - - - - - - - - - - - - - -

            outputdic[keys[ll]] = ids, \
                                  fluxval, fluxerr, SNval, \
                                  fluxval_Dlam, fluxstd_Dlam, fluxerr_Dlam, SNval_Dlam, \
                                  fluxval_Dlam_max, SNval_Dlam_max, \
                                  fluxval_Dlam_sum, SNval_Dlam_sum, \
                                  EW, EW_Dlam, EW_Dlam_sum

    if printresults:
        for ss, spec in enumerate(spectra):
            id = spec.split('/')[-1].split('.fit')[0][-9:]
            print(' - - - - - - Object '+id+' (Dlam = lambda +/-'+str(outputdic['deltalam'])+'A)- - - - - -  ')
            for key in outputdic.keys():
                if key is not 'deltalam':
                    print(' - '+key+' flux           = '+str('%.4f' % outputdic[key][1][ss])+' +/- '+\
                          str('%.4f' % outputdic[key][2][ss]))
                    print(' - '+key+' S/N            = '+str('%.4f' % outputdic[key][3][ss]))
                    print(' - '+key+' flux_Dlam      = '+str('%.4f' % outputdic[key][4][ss])+' +/- '+\
                          str('%.4f' % outputdic[key][5][ss]))
                    print(' - '+key+' S/N_Dlam       = '+str('%.4f' % outputdic[key][7][ss]))
                    print(' - '+key+' flux_Dlam_max  = '+str('%.4f' % outputdic[key][8][ss]))
                    print(' - '+key+' S/N_Dlam_max   = '+str('%.4f' % outputdic[key][9][ss]))
                    print(' - '+key+' flux_Dlam_sum  = '+str('%.4f' % outputdic[key][10][ss]))
                    print(' - '+key+' S/N_Dlam_sum   = '+str('%.4f' % outputdic[key][11][ss]))
                    print(' - '+key+' EW             = '+str('%.4f' % outputdic[key][12][ss]))
                    print(' - '+key+' EW_Dlam        = '+str('%.4f' % outputdic[key][13][ss]))
                    print(' - '+key+' EW_Dlam_sum    = '+str('%.4f' % outputdic[key][14][ss]))

    return outputdic
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def estimate_continuumlevel_viaBeta(wave, wave_ref, f_ref, beta, verbose=True):
    """
    Estiamting the continuum level assuming a spectrum with a fixed beta extrapolating ot the provided wavelength

    --- INPUT ---
    wave          The wavelength at whihc the continuum is estimated
    wave_ref      Referece wavelength at whihc the flux is known
    f_ref         Flux at wave_ref
    beta          The conitnuum slope to use for estrapolation to wave. Will assum f ~ wave**beta

    --- EXAMPLE OF USE ---

    sourcecatdat = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data
    objent       = np.where(sourcecatdat['id'] == 102013086)[0]
    wave         = 1551 * (sourcecatdat['redshift'][objent][0] + 1)
    beta         = sourcecatdat['beta'][objent][0]
    bandswithLya = uves.wavelength_in_bands( 1216 * (sourcecatdat['redshift'][objent][0] + 1))

    wave_ref     = 8140.2
    f_ref        = sourcecatdat['flux_acs_814w'][objent][0]
    f_wave = uves.estimate_continuumlevel_viaBeta(wave, wave_ref, f_ref, beta)

    wave_ref     = 7730.0
    f_ref        = sourcecatdat['flux_acs_775w'][objent][0]
    f_wave = uves.estimate_continuumlevel_viaBeta(wave, wave_ref, f_ref, beta)

    wave_ref     = 6034.0
    f_ref        = sourcecatdat['flux_acs_606w'][objent][0]
    f_wave = uves.estimate_continuumlevel_viaBeta(wave, wave_ref, f_ref, beta)


    """
    if verbose: print(' - Estimating flux at wavelength '+str(wave)+' using:')
    if verbose: print('   reference wave = '+str(wave_ref))
    if verbose: print('   reference flux = '+str(f_ref))
    if verbose: print('   beta           = '+str(beta))
    if verbose: print('   ')

    f_wave = f_ref * (wave / wave_ref)**beta
    if verbose: print('   f_'+str(int(np.round(wave)))+'         = '+str(f_wave)+'\n')

    return f_wave
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_limits(sourcecatalog, namebase, limits_dictionary, colorcode=True, colortype='redshift', zoom = False,
                ignoreSNlt3=False, showids=False, verbose=True):
    """
    Plotting the output from uves.estimate_limits()

    """
    sourcedat = afits.open(sourcecatalog)[1].data

    for key in limits_dictionary.keys():
    #for key in ['lya']:
        if key == 'deltalam':
            continue

        ids, \
        fluxval, fluxerr, SNval, \
        fluxval_Dlam, fluxstd_Dlam, fluxerr_Dlam, SNval_Dlam, \
        fluxval_Dlam_max, SNval_Dlam_max, \
        fluxval_Dlam_sum, SNval_Dlam_sum, \
        EW, EW_Dlam, EW_Dlam_sum = limits_dictionary[key]

        # - - - - build vectors from source catalog using IDs - - - -
        z_sys      = []
        z_lya      = []
        EW_lya     = []
        EW_lya_err = []
        beta       = []

        for ii,id in enumerate(ids):
            objent = np.where(sourcedat['id'] == int(id))[0]
            try:
                z_sys.append(sourcedat['z_sys_AV17'][objent][0])
            except:
                z_sys.append(sourcedat['z_sys_V18'][objent][0])
            z_lya.append(sourcedat['z_vac_red'][objent][0])
            EW_lya.append(sourcedat['EW_0'][objent][0])
            EW_lya_err.append(sourcedat['EW_0_err'][objent][0])
            beta.append(sourcedat['beta'][objent][0])

        # - - - - - - - - - - - - - - - - - - - - - - PLOTTING - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print(' - Setting up and generating plot')
        plotname = namebase+'_'+key+'_EWlyaVSEW'+key+'.pdf'
        if zoom: plotname = plotname.replace('.pdf','_zoom.pdf')
        if ignoreSNlt3: plotname = plotname.replace('.pdf','_noSNlt3.pdf')
        fig = plt.figure(figsize=(7, 5))
        fig.subplots_adjust(wspace=0.1, hspace=0.1,left=0.2, right=0.97, bottom=0.10, top=0.9)
        Fsize    = 10
        lthick   = 2
        marksize = 4
        plt.rc('text', usetex=True)
        plt.rc('font', family='serif',size=Fsize)
        plt.rc('xtick', labelsize=Fsize)
        plt.rc('ytick', labelsize=Fsize)
        plt.clf()
        plt.ioff()
        #plt.title(inforstr[:-2],fontsize=Fsize)

        xvalues = np.asarray(EW_lya)
        #yvalues = np.asarray(EW)
        #yvalues = np.asarray(EW_Dlam)
        yvalues = np.asarray(EW_Dlam_sum)
        xerr    = [None]*len(xvalues)
        yerr    = [None]*len(xvalues)

        if colorcode:
            cmap    = plt.cm.get_cmap('rainbow')

            if colortype == 'redshift':
                cmin    = 2.8
                cmax    = 6.2
            else:
                sys.exit(' Color type '+colortype+' not enabled ')

            colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
            cmaparr = np.linspace(cmin, cmax, cmax-cmin)
            m       = plt.cm.ScalarMappable(cmap=cmap)
            m.set_array(cmaparr)
            cb      = plt.colorbar(m)

            if colortype == 'redshift':
                cb.set_label('redshift')

            for ii,id in enumerate(ids):

                if colortype == 'redshift':
                    objcol = cmap(colnorm(z_sys[ii]))

                if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
                    marker = 'o'
                    ms     = marksize
                    mec    = objcol
                    mfc    = objcol

                    if SNval_Dlam_sum[ii] < 3.0:
                        mfc    = 'None'
                        if ignoreSNlt3: continue

                    if (beta[ii] == -2.0) & (SNval_Dlam_sum[ii] > 3.0):
                        #marker = r'$\downarrow$'
                        marker = r'$\nearrow$'
                        ms     = ms*2

                        plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr[ii],yerr=yerr[ii],
                                     marker=marker,lw=0, markersize=ms,alpha=1.0,
                                     markerfacecolor=mfc,ecolor=objcol,
                                     markeredgecolor=mec,zorder=10)
                    else:
                        if SNval_Dlam_sum[ii] > 0.0:
                            plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr[ii],yerr=yerr[ii],
                                         marker=marker,lw=0, markersize=ms,alpha=1.0,
                                         markerfacecolor=mfc,ecolor=objcol,
                                         markeredgecolor=mec,zorder=10)
                        else:
                            pass # not plotting S/N < 0 points

        else:
            plt.errorbar(xvalues,yvalues,xerr=xerr,yerr=yerr,
                         marker='o',lw=0, markersize=marksize,alpha=0.5,
                         markerfacecolor='gray',ecolor='k',
                         markeredgecolor='k',zorder=10)

        #marking AGN:
        AGN     = ['104014050','115003085','214002011']
        AGNcand = ['123048186','123501191','121033078']
        for ii,id in enumerate(ids):
            if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGN):
                plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
                                 marker='*',lw=0, markersize=marksize*2,alpha=1.0,
                                 markerfacecolor='None',ecolor=objcol,
                                 markeredgecolor='black',zorder=20)

            if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGNcand):
                plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
                                 marker='D',lw=0, markersize=marksize,alpha=1.0,
                                 markerfacecolor='None',ecolor=objcol,
                                 markeredgecolor='black',zorder=20)

        if showids:
            for ii,id in enumerate(ids):
                if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
                    plt.text(xvalues[ii],yvalues[ii],id,color='black',fontsize=Fsize/2.)

        if key.lower() == 'lya':
            plt.plot([-5000,5000],[-5000,5000],'--',color='gray',lw=lthick,zorder=5)
            plt.xscale('log')
            plt.yscale('log')

        plt.xlabel(' EW( Ly$\\alpha$ ) ')
        plt.ylabel(' EW( '+key+' )')

        #--------- RANGES ---------
        goodent = np.where(np.isfinite(xvalues) & np.isfinite(yvalues))
        xmin = np.min(xvalues[goodent])
        xmax = np.max(xvalues[goodent])
        dx   = xmax-xmin

        ymin = np.min(yvalues[goodent])
        ymax = np.max(yvalues[goodent])
        dy   = ymax-ymin

        plt.xlim([xmin-dx*0.05,xmax+dx*0.05])
        plt.ylim([ymin-dy*0.05,ymax+dy*0.05])
        if zoom:
            plt.xlim([0,400])
            plt.ylim([0,30])

        # if logx:
        #     plt.xscale('log')
        # if logy:
        #     plt.yscale('log')

        #--------- LEGEND ---------
        plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='k',ecolor='k',markeredgecolor='black',zorder=1,label='MW LAE (S/N\_'+key+' $>$ 3)')
        plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='None',ecolor='k',markeredgecolor='black',zorder=1,label='MW LAE (S/N\_'+key+' $<$ 3)')
        plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker=r'$\nearrow$',lw=0, markersize=marksize*2,alpha=1.0,
                     markerfacecolor='None',ecolor='k',markeredgecolor='black',zorder=1,
                     label='MW LAE (HST non-det. lower limit)')


        plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='*',lw=0, markersize=marksize*2,alpha=1.0,
                     markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN')
        plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='D',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN candidate')

        leg = plt.legend(fancybox=True, loc='upper center',prop={'size':Fsize/1.7},ncol=3,numpoints=1,
                         bbox_to_anchor=(0.5, 1.1),)  # add the legend
        leg.get_frame().set_alpha(0.7)
        #--------------------------

        if verbose: print('   Saving plot to',plotname)
        plt.savefig(plotname)
        plt.clf()
        plt.close('all')


        # - - - - - - - - - - - - - - - - - - - - - - PLOTTING - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print(' - Setting up and generating plot')
        plotname = namebase+'_'+key+'_fluxVSs2n.pdf'
        if zoom: plotname = plotname.replace('.pdf','_zoom.pdf')
        fig = plt.figure(figsize=(7, 5))
        fig.subplots_adjust(wspace=0.1, hspace=0.1,left=0.2, right=0.97, bottom=0.10, top=0.9)
        Fsize    = 10
        lthick   = 2
        marksize = 4
        plt.rc('text', usetex=True)
        plt.rc('font', family='serif',size=Fsize)
        plt.rc('xtick', labelsize=Fsize)
        plt.rc('ytick', labelsize=Fsize)
        plt.clf()
        plt.ioff()
        #plt.title(inforstr[:-2],fontsize=Fsize)

        xvalues = np.asarray(SNval_Dlam_sum)
        yvalues = np.asarray(fluxval)
        xerr    = None
        yerr    = np.asarray(fluxerr)

        if colorcode:
            cmap    = plt.cm.get_cmap('rainbow')

            if colortype == 'redshift':
                cmin    = 2.8
                cmax    = 6.2
            else:
                sys.exit(' Color type '+colortype+' not enabled ')

            colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
            cmaparr = np.linspace(cmin, cmax, cmax-cmin)
            m       = plt.cm.ScalarMappable(cmap=cmap)
            m.set_array(cmaparr)
            cb      = plt.colorbar(m)

            if colortype == 'redshift':
                cb.set_label('redshift')

            for ii,id in enumerate(ids):

                if colortype == 'redshift':
                    objcol = cmap(colnorm(z_sys[ii]))

                if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
                    plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr,yerr=yerr[ii],
                                 marker='o',lw=0, markersize=marksize,alpha=1.0,
                                 markerfacecolor=objcol,ecolor=objcol,
                                 markeredgecolor='None',zorder=10)
        else:
            plt.errorbar(xvalues,yvalues,xerr=xerr,yerr=yerr,
                         marker='o',lw=0, markersize=marksize,alpha=0.5,
                         markerfacecolor='gray',ecolor='k',
                         markeredgecolor='k',zorder=10)

        #marking AGN:
        AGN     = ['104014050','115003085','214002011']
        AGNcand = ['123048186','123501191','121033078']
        for ii,id in enumerate(ids):
            if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGN):
                plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
                                 marker='*',lw=0, markersize=marksize*2,alpha=1.0,
                                 markerfacecolor='None',ecolor=objcol,
                                 markeredgecolor='black',zorder=20)

            if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGNcand):
                plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
                                 marker='D',lw=0, markersize=marksize,alpha=1.0,
                                 markerfacecolor='None',ecolor=objcol,
                                 markeredgecolor='black',zorder=20)


        if showids:
            for ii,id in enumerate(ids):
                if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
                    plt.text(xvalues[ii],yvalues[ii],id,color='black',fontsize=Fsize/2.)

        plt.plot([3,3],[-5000,5000],'--',color='gray',lw=lthick,zorder=5)

        plt.xlabel('S/N of MUSE-Wide LAE 1D spectra at location of '+key)
        plt.ylabel('Flux [1e-20cgs] of MUSE-Wide LAE 1D spectra at location of '+key)


        #--------- RANGES ---------
        xmin = np.min(xvalues[np.isfinite(xvalues)])
        xmax = np.max(xvalues[np.isfinite(xvalues)])
        dx   = xmax-xmin

        ymin = np.min(yvalues[np.isfinite(yvalues)])
        ymax = np.max(yvalues[np.isfinite(yvalues)])
        dy   = ymax-ymin

        plt.xlim([xmin-dx*0.05,xmax+dx*0.05])
        plt.ylim([ymin-dy*0.05,ymax+dy*0.05])

        if zoom:
            plt.xlim([-10,10])
            plt.ylim([-100,100])
            if key.lower() == 'lya':
                plt.xlim([0,10])
                plt.ylim([0,300])

        # if logx:
        #     plt.xscale('log')
        # if logy:
        #     plt.yscale('log')

        #--------- LEGEND ---------
        plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='k',ecolor='k',markeredgecolor='black',zorder=1,label='MUSE-Wide LAE')
        plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='*',lw=0, markersize=marksize*2,alpha=1.0,
                     markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN')
        plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='D',lw=0, markersize=marksize,alpha=1.0,
                     markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN candidate')

        leg = plt.legend(fancybox=True, loc='upper center',prop={'size':Fsize/1.0},ncol=5,numpoints=1,
                         bbox_to_anchor=(0.5, 1.1),)  # add the legend
        leg.get_frame().set_alpha(0.7)
        #--------------------------

        if verbose: print('   Saving plot to '+plotname)
        plt.savefig(plotname)
        plt.clf()
        plt.close('all')

        # # - - - - - - - - - - - - - - - - - - - - - - PLOTTING - - - - - - - - - - - - - - - - - - - - - -
        # if verbose: print(' - Setting up and generating plot'
        # plotname = namebase+'_'+key+'_LyaEWVSflux.pdf'
        # fig = plt.figure(figsize=(7, 5))
        # fig.subplots_adjust(wspace=0.1, hspace=0.1,left=0.2, right=0.97, bottom=0.10, top=0.9)
        # Fsize    = 10
        # lthick   = 2
        # marksize = 4
        # plt.rc('text', usetex=True)
        # plt.rc('font', family='serif',size=Fsize)
        # plt.rc('xtick', labelsize=Fsize)
        # plt.rc('ytick', labelsize=Fsize)
        # plt.clf()
        # plt.ioff()
        # #plt.title(inforstr[:-2],fontsize=Fsize)
        #
        # xvalues = np.asarray(LyaEW)
        # yvalues = np.asarray(fluxval)
        # xerr    = None
        # yerr    = np.asarray(fluxerr)
        #
        # if colorcode:
        #     cmap    = plt.cm.get_cmap('rainbow')
        #
        #     if colortype == 'redshift':
        #         cmin    = 2.8
        #         cmax    = 6.2
        #     else:
        #         sys.exit(' Color type '+colortype+' not enabled ')
        #
        #     colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
        #     cmaparr = np.linspace(cmin, cmax, cmax-cmin)
        #     m       = plt.cm.ScalarMappable(cmap=cmap)
        #     m.set_array(cmaparr)
        #     cb      = plt.colorbar(m)
        #
        #     if colortype == 'redshift':
        #         cb.set_label('redshift')
        #
        #     for ii,id in enumerate(ids):
        #
        #         if colortype == 'redshift':
        #             objcol = cmap(colnorm(z_sys[ii]))
        #
        #         if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
        #             plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr,yerr=yerr[ii],
        #                          marker='o',lw=0, markersize=marksize,alpha=1.0,
        #                          markerfacecolor=objcol,ecolor=objcol,
        #                          markeredgecolor='None',zorder=10)
        # else:
        #     plt.errorbar(xvalues,yvalues,xerr=xerr,yerr=yerr,
        #                  marker='o',lw=0, markersize=marksize,alpha=0.5,
        #                  markerfacecolor='gray',ecolor='k',
        #                  markeredgecolor='k',zorder=10)
        #
        # #marking AGN:
        # AGN     = ['104014050','115003085','214002011']
        # AGNcand = ['123048186','123501191','121033078']
        # for ii,id in enumerate(ids):
        #     if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGN):
        #         plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
        #                          marker='*',lw=0, markersize=marksize*2,alpha=1.0,
        #                          markerfacecolor='None',ecolor=objcol,
        #                          markeredgecolor='black',zorder=20)
        #
        #     if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]) & (id in AGNcand):
        #         plt.errorbar(xvalues[ii],yvalues[ii],xerr=None,yerr=None,
        #                          marker='D',lw=0, markersize=marksize,alpha=1.0,
        #                          markerfacecolor='None',ecolor=objcol,
        #                          markeredgecolor='black',zorder=20)
        #
        #
        # if showids:
        #     for ii,id in enumerate(ids):
        #         if np.isfinite(xvalues[ii]) & np.isfinite(yvalues[ii]):
        #             plt.text(xvalues[ii],yvalues[ii],id,color='black',fontsize=Fsize/2.,zorder=30)
        #
        # plt.plot([3,3],[-5000,5000],'--',color='gray',lw=lthick,zorder=5)
        #
        # plt.xlabel('S/N of MUSE-Wide LAE 1D spectra at location of '+key)
        # plt.ylabel('Flux [1e-20cgs] of MUSE-Wide LAE 1D spectra at location of '+key)
        #
        #
        # #--------- RANGES ---------
        # xmin = np.min(xvalues[np.isfinite(xvalues)])
        # xmax = np.max(xvalues[np.isfinite(xvalues)])
        # dx   = xmax-xmin
        #
        # ymin = np.min(yvalues[np.isfinite(yvalues)])
        # ymax = np.max(yvalues[np.isfinite(yvalues)])
        # dy   = ymax-ymin
        #
        # plt.xlim([xmin-dx*0.05,xmax+dx*0.05])
        # plt.ylim([ymin-dy*0.05,ymax+dy*0.05])
        #
        # # if logx:
        # #     plt.xscale('log')
        # # if logy:
        # #     plt.yscale('log')
        #
        # #--------- LEGEND ---------
        # plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
        #              markerfacecolor='k',ecolor='k',markeredgecolor='black',zorder=1,label='MUSE-Wide LAE')
        # plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='*',lw=0, markersize=marksize*2,alpha=1.0,
        #              markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN')
        # plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='D',lw=0, markersize=marksize,alpha=1.0,
        #              markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN candidate')
        #
        # leg = plt.legend(fancybox=True, loc='upper center',prop={'size':Fsize/1.0},ncol=5,numpoints=1,
        #                  bbox_to_anchor=(0.5, 1.1),)  # add the legend
        # leg.get_frame().set_alpha(0.7)
        # #--------------------------
        #
        # if verbose: print('   Saving plot to',plotname
        # plt.savefig(plotname)
        # plt.clf()
        # plt.close('all')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def lineinfofromspec(wavelength,spec_lam,spec_flux,spec_fluxerr,spec_s2n,deltalam=10,verbose=True):
    """
    return info at given wavelength based on spectrum

    """
    if (wavelength > np.min(spec_lam)) & (wavelength < np.max(spec_lam)):

        wavediff     = np.abs(spec_lam-wavelength)
        waveent      = np.where(wavediff == np.min(wavediff))

        if len(waveent) > 1:
            if verbose: print(' - multiple matches for '+str(wavelength)+'; returning info for the first match: '+
                              str(spec_lam[waveent[0]]))
        ent      = waveent[0]
        ent_dlam = np.where( (spec_lam > (spec_lam[ent]-deltalam)) & (spec_lam < (spec_lam[ent]+deltalam)) )

        fluxval       = spec_flux[ent]
        fluxerr       = spec_fluxerr[ent]
        SNval         = spec_s2n[ent]

        fluxval_Dlam  = np.median(spec_flux[ent_dlam])
        fluxstd_Dlam  = np.std(spec_fluxerr[ent_dlam])
        fluxerr_Dlam  = np.median(spec_fluxerr[ent_dlam])
        SNval_Dlam    = np.median(spec_s2n[ent_dlam])

        fluxval_Dlam_max  = np.max(spec_flux[ent_dlam])
        SNval_Dlam_max    = np.max(spec_s2n[ent_dlam])

        deltawave         = np.median(np.diff(spec_lam[ent_dlam]))
        fluxval_Dlam_sum  = np.sum(spec_flux[ent_dlam]) * deltawave
        SNval_Dlam_sum    = fluxval_Dlam_sum/fluxerr_Dlam

    else:
        if verbose: print(' - '+str(wavelength)+' not within spectral range; returning NaNs')
        fluxval       = [np.NaN]
        fluxerr       = [np.NaN]
        SNval         = [np.NaN]

        fluxval_Dlam  = np.NaN
        fluxstd_Dlam  = np.NaN
        fluxerr_Dlam  = np.NaN
        SNval_Dlam    = np.NaN

        fluxval_Dlam_max  = np.NaN
        SNval_Dlam_max    = np.NaN

        fluxval_Dlam_sum  = np.NaN
        SNval_Dlam_sum    = np.NaN

    return fluxval[0], fluxerr[0], SNval[0], \
           fluxval_Dlam, fluxstd_Dlam, fluxerr_Dlam, SNval_Dlam, \
           fluxval_Dlam_max, SNval_Dlam_max, \
           fluxval_Dlam_sum, SNval_Dlam_sum

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_1DspecOverview_forsample(MUSEidlist,outputdir='./',yrangefullflux=[-400,1200],yrangefullSN=[-3,30],
                                  specdir  = '/Volumes/DATABCKUP1/TDOSEextractions/TDOSEext_171019/tdose_spectra/',
                                  tol3DHSTmatch=0.5,showPSFspec=True,clobber=False,verbose=True):
    """
    Wrapper to run mwp.plot_1DspecOverview() for a sample of objects collecting the relevant spectra

    --- INPUT ---
    MUSEidlist      List of MUSE ids of objects to plot
    outputdir       Directory to save figure to
    yrangefullflux  Yrange of full-spectra overview in flux figure
    yrangefullSN    Yrange of full-spectra overview in S/N figure
    specdir         Directory containing TDOSE spectra to plot
    tol3DHSTmatch   Tolerance of match to 3D-HST catalog (and spectra)
    showPSFspec     Plot the spectra extracted via PSF weighting (TU's extraction)
    clobber         Overwrite existing files?
    verbose         Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    MUSEidlist  = [103006046,119031070,208006149]
    MUSEidlist  = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data['id']

    outputdir   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/171108_1DspecOverview/'
    plottedspec = uves.plot_1DspecOverview_forsample(MUSEidlist,outputdir=outputdir)

    """
    Nobj     = len(MUSEidlist)
    if verbose: print(' - Plotting spectra of '+str(Nobj)+' objects in "MUSEidlist"')
    LAEinfo        = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data
    spectraplottet = collections.OrderedDict()

    if type(specdir) == str:
        specdir = [specdir]

    for oo, objID in enumerate(MUSEidlist):
        idstr        = str(objID)
        idstr_short  = str(objID)[:3]+str(objID)[-5:]

        outputfigure = outputdir+'id'+idstr+'_1DspecOverview.pdf'

        objent = np.where(LAEinfo['id'] == objID)[0]
        if len(objent) == 0:
            sys.exit(' object ID '+str(objID)+' not found in LAEinfo file ')

        sep3DHST = LAEinfo['sep_skelton'][objent]

        if (sep3DHST < tol3DHSTmatch) & (sep3DHST != 0.0):
            id3DHST = LAEinfo['id_skelton'][objent]
        else:
            id3DHST  = -99

        # - - - - - - - TDOSE extractions - - - - - - -
        TDOSEspecs = []
        TDOSElabel = []
        for sdir in specdir:
            TDOSEspec    = glob.glob(sdir+'tdose_spectrum_candels*'+idstr+'*.fits')+\
                           glob.glob(sdir+'tdose_spectrum_candels*'+idstr_short+'*.fits')
            if len(TDOSEspec) == 0:
                if verbose: print('----- No TDOSE spectrum found for '+str(objID)+' in \n      '+
                                  sdir+'\n      -> moving on to next object ----- ')
                continue

            labelstrings = ['TDOSE '+specname.split('/')[-1].split('_')[3] for specname in TDOSEspec]
            TDOSElabel   = TDOSElabel + labelstrings
            TDOSEspecs   = TDOSEspecs + TDOSEspec

        TDOSEwave    = ['wave']*len(TDOSEspecs)
        TDOSEflux    = ['flux']*len(TDOSEspecs)
        TDOSEferr    = ['fluxerror']*len(TDOSEspecs)
        TDOSEsky     = [None]*len(TDOSEspecs)
        TDOSEskyW    = [None]*len(TDOSEspecs)
        TDOSEskyF    = [None]*len(TDOSEspecs)
        TDOSEsky[0]  = '/Users/kschmidt/work/MUSE/skyspectra/SKY_SPECTRUM_'+LAEinfo['pointing'][objent][0]+'_av.fits'
        TDOSEskyW[0] = 'lambda'
        TDOSEskyF[0] = 'data'

        # - - - - - - - PSF weighted extraction - - - - - - -
        if showPSFspec:
            PSFextdir = '/Users/kschmidt/work/MUSE/spectra1D/Arche170127/spectra/'
            PSFspec   = glob.glob(PSFextdir+'spectrum_'+idstr+'.fits')+\
                        glob.glob(PSFextdir+'spectrum_'+idstr_short+'.fits')
            if len(PSFspec) > 1:
                sys.exit(' More than one PSF extraction spectrum found for '+idstr+' in '+PSFextdir)
            elif len(PSFspec) == 1:
                PSFlabel = ['PSFext']
                PSFwave  = ['WAVE_AIR']
                PSFflux  = ['FLUX']
                PSFferr  = ['FLUXERR']
                PSFsky   = [None]
                PSFskyW  = [None]
                PSFskyF  = [None]
            else:
                PSFlabel = []
                PSFwave  = []
                PSFflux  = []
                PSFferr  = []
                PSFsky   = []
                PSFskyW  = []
                PSFskyF  = []
        else:
            PSFspec  = []
            PSFlabel = []
            PSFwave  = []
            PSFflux  = []
            PSFferr  = []
            PSFsky   = []
            PSFskyW  = []
            PSFskyF  = []

        # - - - - - - - 3D-HST spectra - - - - - - -
        if id3DHST != -99:
            if idstr.startswith('1'):
                specdic = uves.get_3DHSTspecname([id3DHST[0]],field='goodss',spec1D=True,verbose=verbose)
            elif idstr.startswith('2'):
                specdic = uves.get_3DHSTspecname([id3DHST[0]],field='cosmos',spec1D=True,verbose=verbose)
            else:
                sys.exit(' Invalid MUSE id - does not start with "1" or "2"')

            grismspec  = specdic[str(int(id3DHST[0]))]

            if len(grismspec) > 0:
                grismlabel   = [gs.split('/')[-1].split('.')[0].replace('_','\_') for gs in grismspec]
                grismwave    = ['wave']*len(grismspec)
                grismflux    = ['flux']*len(grismspec)
                grismferr    = ['error']*len(grismspec)
                grismsky     = [None]*len(grismspec)
                grismskyW    = [None]*len(grismspec)
                grismskyF    = [None]*len(grismspec)
                grismsky[0]  = '/Users/kschmidt/work/MUSE/skytable.fits'
                grismskyW[0] = 'lam'
                grismskyF[0] = 'flux'

            else:
                grismlabel = []
                grismwave  = []
                grismflux  = []
                grismferr  = []
                grismsky   = []
                grismskyW  = []
                grismskyF  = []
        else:
            grismspec  = []
            grismlabel = []
            grismwave  = []
            grismflux  = []
            grismferr  = []
            grismsky   = []
            grismskyW  = []
            grismskyF  = []

        # - - - - - - - Assemble input for plot - - - - - - -
        spectra      = TDOSEspecs + PSFspec  + grismspec
        labels       = TDOSElabel + PSFlabel + grismlabel
        wavecols     = TDOSEwave  + PSFwave  + grismwave
        fluxcols     = TDOSEflux  + PSFflux  + grismflux
        fluxerrcols  = TDOSEferr  + PSFferr  + grismferr
        skyspectra   = TDOSEsky   + PSFsky   + grismsky
        wavecols_sky = TDOSEskyW  + PSFskyW  + grismskyW
        fluxcols_sky = TDOSEskyF  + PSFskyF  + grismskyF

        zLya         = LAEinfo['redshift'][objent][0]
        try:
            zsys         = LAEinfo['z_sys_AV17'][objent][0]
            voffset      = LAEinfo['red_peak_shift_AV17_kms'][objent][0]
        except:
            zsys         = LAEinfo['z_sys_V18'][objent][0]
            voffset      = LAEinfo['red_peak_shift_V18_kms'][objent][0]

        spectraplottet[idstr] = spectra
        if verbose:
            idno    = oo+1
            infostr = '----- Plot '+str(objID)+' at z = '+str("%.4f" % zLya)+' indicating voff = '+\
                      str("%.4f" % voffset)+'  ('+str(idno)+'/'+str(Nobj)+') -----                           '

            if (clobber == False) & (len(glob.glob(outputfigure.replace('.pdf','*.pdf'))) != 0):
                infostr = infostr.replace(') -----              ',
                                          ') -----> skip (clobber=False)')

                print(infostr)
            else:
                print(infostr)

                for plotSN in [True,False]:
                    if plotSN:
                        yrangefull = yrangefullSN
                    else:
                        yrangefull = yrangefullflux

                    mwp.plot_1DspecOverview(spectra, labels, wavecols, fluxcols, fluxerrcols, zLya, voffset=voffset,
                                            skyspectra=skyspectra, wavecols_sky=wavecols_sky, fluxcols_sky=fluxcols_sky,
                                            outputfigure=outputfigure, yrangefull=yrangefull, plotSN=plotSN,
                                            verbose=verbose)

    if verbose: print(' - Done...')
    return spectraplottet
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_3DHSTspecname(ids,spec1D=False,field='goodss',verbose=True):
    """

    Return absolute paths for existing 3D-HST 2D fits files. If

    --- INPUT ---
    ids           list of 3D-HST ids to return list of spectr for
    spec1D        if true, paths of the 1D spectra will be returned

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    spectradic = uves.get_3DHSTspecname([22684,21926,9033,7609])

    """
    path3DHST     = '/Volumes/DATABCKUP1/3DHST/'+field.lower()+'_WFC3_V4.1.5/'
    cat_spec      = path3DHST+field.lower()+'_3dhst_v4.1.5_catalogs/'+\
                    field.lower()+'_3dhst.v4.1.5.duplicates_2d.dat'    # list of (duplicate) spectra for each ID

    if field.lower() == 'goodss':
        dat_spec      = np.genfromtxt(cat_spec,comments='#',
                                      names=['id','s1','s2','s3','s4','s5','s6','s7'],
                                      dtype='d,40a,40a,40a,40a,40a,40a,40a')
    elif field.lower() == 'cosmos':
        dat_spec      = np.genfromtxt(cat_spec,comments='#',
                                      names=['id','s1','s2','s3','s4'],
                                      dtype='d,40a,40a,40a,40a')

    else:
        sys.exit(' No 3D-HST directory setup available for the field "'+field+'"')

    infodic = collections.OrderedDict()

    for id in ids:
        objent   = np.where(dat_spec['id'] == float(id))[0][0]
        namelist = [val for val in dat_spec[objent]][1:]
        filelist = []

        for name in namelist:
            if name != '00000':
                if spec1D:
                    namestr  = '/1D/FITS/'+name
                    filename = glob.glob(path3DHST+'/'+name[:-11]+namestr+'.1D.fits')
                    if os.path.isfile(filename[0]):
                        filelist.append(os.path.abspath(filename[0]))
                else:
                    # look for regular spectrum
                    namestr  = '/2D/FITS/'+name
                    filename = glob.glob(path3DHST+'/'+name[:-11]+namestr+'.2D.fits')
                    if os.path.isfile(filename[0]):
                        filelist.append(os.path.abspath(filename[0]))

                    # look for BIG spectrum
                    namestr  = '/BIG/2D/'+name.replace('G141','G141-big')
                    filename = glob.glob(path3DHST+'/'+name[:-11]+namestr+'.2D.fits')
                    if os.path.isfile(filename[0]):
                        filelist.append(os.path.abspath(filename[0]))

        infodic[str(int(id))] = filelist

    return infodic
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def copy_singleobjsourcecats(outputdir='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecats_singleobjects/',
                             verbose=True):
    """

    --- EXAMPLE OF USE ---
    uves.copy_singleobjsourcecats()

    """
    modeldir      = '/Volumes/DATABCKUP1/TDOSEextractions/MW_LAEs_JKgalfitmodels/'

    sourcecats = ['model_acs_814w_candels-cdfs-01_cut_v1.0_id101005016_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-01_cut_v1.0_id101023043_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-01_cut_v1.0_id101024044_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-02_cut_v1.0_id102015088_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-03_cut_v1.0_id103006046_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-03_cut_v1.0_id103050126_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-04_cut_v1.0_id104024069_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-06_cut_v1.0_id106014046_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-06_cut_v1.0_id106035088_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-11_cut_v1.0_id111013028_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-22_cut_v1.0_id122002034_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-22_cut_v1.0_id122002035_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-23_cut_v1.0_id123016117_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-25_cut_v1.0_id125049122_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-28_cut_v1.0_id128038236_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-31_cut_v1.0_id131016105_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-31_cut_v1.0_id131016106_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-35_cut_v1.0_id135010177_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-35_cut_v1.0_id135010178_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-41_cut_v1.0_id141003075_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-41_cut_v1.0_id141036146_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-43_cut_v1.0_id143033113_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-44_cut_v1.0_id144008046_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-45_cut_v1.0_id145022065_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-45_cut_v1.0_id145034089_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-45_cut_v1.0_id145065132_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-46_cut_v1.0_id146053338_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cdfs-46_cut_v1.0_id146069355_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-01_cut_v1.0_id201073224_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-02_cut_v1.0_id202013030_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-02_cut_v1.0_id202044085_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-03_cut_v1.0_id203007099_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-04_cut_v1.0_id204053120_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-06_cut_v1.0_id206014089_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-07_cut_v1.0_id207022169_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-09_cut_v1.0_id209006108_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-11_cut_v1.0_id211015198_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-12_cut_v1.0_id212029067_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-13_cut_v1.0_id213022109_cutout2p0x2p0arcsec_sourcecatalog.*',
                  'model_acs_814w_candels-cosmos-15_cut_v1.0_id215016042_cutout2p0x2p0arcsec_sourcecatalog.*']

    for scat in sourcecats:
        cpout = commands.getoutput('cp '+modeldir+scat+' '+outputdir)
        if cpout != '':
            print(str(cpout))

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_overviewdocument(outdir,outfile,clobber=False,
                         specoverview='/Volumes/DATABCKUP1/TDOSEextractions/171201_TDOSEextraction/overviewplots/idIIII*.pdf',
                         FoVoverview='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FoVoverviews/FoVoverview_IIII.png'):
    """
    Generate LaTeX document summarizing objects (using figures and text) to ease inspections

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    outdir  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/overviewdocument/'
    outfile = 'overviewdocument.tex'
    uves.gen_overviewdocument(outdir,outfile)

    """

    objdata   = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo.fits')[1].data
    ids       = objdata['id']
    ras       = objdata['ra']
    decs      = objdata['dec']
    redshifts = objdata['redshift']
    pointings = objdata['pointing']

    # - - - - - Generate main document - - - - -
    if os.path.isfile(outdir+outfile) & (clobber==False):
        sys.exit('Document '+outdir+outfile+' exists and clobber = False')

    fmain = open(outdir+outfile,'w')
    fmain.write("""
\documentclass[a4paper,10pt]{article}
\\usepackage[latin1]{inputenc}
\\usepackage{float}
\\usepackage[pdftex]{graphicx}
\\usepackage[left=1cm,right=1cm,top=1cm,bottom=2cm]{geometry}
%===========================================================================
\\begin{document}
%===========================================================================
""")

    for ii, id in enumerate(ids[:]):
        pagename = 'page'+str(id)+'.tex'

        FoVfig   = FoVoverview.replace('IIII',str(id))
        specfigs = glob.glob(specoverview.replace('IIII',str(id)))
        fluxfig  = specfigs[0]
        snfig    = specfigs[1]

        fpage = open(outdir+pagename,'w')
        fpage.write("""
\section*{%s (%s)}
\small
\\begin{verbatim}
ID(MUSE-Wide) = %s     z  = %s     (ra,dec) = (%s,%s)
ID(Guo)       = %s     dr = %s     (ra,dec) = (%s,%s)
ID(Skelton)   = %s     dr = %s     (ra,dec) = (%s,%s)
\end{verbatim}
\\normalsize

\\begin{figure}[h]
\\begin{center}
\includegraphics[width=0.45\\textwidth]{%s}
\caption{Candels F814W 5$\\times$5 arcsec field of view. Circles have r=0.5arcsec. Red circles mark MUSE-Wide LAEs. White circles mark MUSE-Wide non-Ly$\\alpha$ EL sources (low-$z$).}
\label{fig:FoV%s}
\end{center}
\end{figure}

\\begin{figure*}
\\begin{center}
\includegraphics[width=0.9\\textwidth]{%s}
\includegraphics[width=0.9\\textwidth]{%s}
\caption{Spectral overview (incl. crossmatch to 3D-HST) with zoom-ins on rest-frame UV line regions. V-offset (gray region) estimated based on Verhamme+18 relations with peak seperation or FWHM.}
\label{fig:spec%s}
\end{center}
\end{figure*}

        """ % (id,pointings[ii],
               str("%11s" % int(id)),str("%.4f" % redshifts[ii]),ras[ii],decs[ii],
               str("%11s" % int(objdata['id_guo'][ii])),str("%.4f" % objdata['sep_guo'][ii]),objdata['ra_guo'][ii],objdata['dec_guo'][ii],
               str("%11s" % int(objdata['id_skelton'][ii])),str("%.4f" % objdata['sep_skelton'][ii]),objdata['ra_skelton'][ii],objdata['dec_skelton'][ii],
               FoVfig,id,fluxfig,snfig,id))
        fpage.close()

        fmain.write('\input{./'+pagename+'}\\newpage\n')

    fmain.write("""
%===========================================================================
\end{document}""")
    fmain.close()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_NEOGALmodels(limits_dictionary,plotnumbers=[99],cutSFmodels=False,smallsyms=False,verbose=True):
    """
    Commands to generate plots of the NEOGAL photo-ionization models with MUSE-Wide included

    --- EXAMPLE OF USE ---
    import rxj2248_BooneBalestraSource as bbs
    bbs.plot_feltregutkinmodels_cmds(plotnumbers=[1,2],cutSFmodels=False,smallsyms=True)

    """

    modeldata  = nm.load_model('combined',filepath='/Users/kschmidt/work/catalogs/NEOGALlines/nebular_emission/')
    modeldata2 = nm.load_model('combined',filepath='/Users/kschmidt/work/catalogs/NEOGALlines/AGN_NLR_nebular_feltre16/')

    if cutSFmodels:
        if verbose: print(' - Performing cut on model SF model grid')
        xid     = 'dummy'
        nh      = 'dummy'
        COratio = 1.00
        Mcutoff = 100
    else:
        if verbose: print(' - Showing all SF model grids, i.e., setting xid, nh, COratio and Mcutoff to dummy values')
        xid     = 'dummy'
        nh      = 'dummy'
        COratio = 'dummy'
        Mcutoff = 'dummy'

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (1 in plotnumbers) or (99 in plotnumbers):
        namebase  = './photomodels_CIVdCIIIvsCIVdHeII'
        line1     = 'CIV1550'
        line2     = 'CIII1908'
        line3     = 'CIV1550'
        line4     = 'HeII1640'
        xrange    = [2e-2,1e3]
        yrange    = [2e-4,1.5e2]
        boxranges = [0.7,1e99,0.5,1e99]

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,
                                    varyparam='Zgas',logx=True,logy=True,logp1=True,
                                    fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,
                                    plotname=namebase+'_Zgas.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,
                                    modeldata2=modeldata2,colormap='winter',boxranges=boxranges,legpos='lower right',
                                    smallsyms=smallsyms)

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,
                                    varyparam='logUs',logx=True,logy=True,logp1=False,
                                    fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,
                                    plotname=namebase+'_logUs.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,
                                    modeldata2=modeldata2,colormap='spring',boxranges=boxranges,legpos='lower right',
                                    smallsyms=smallsyms)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (2 in plotnumbers) or (99 in plotnumbers):
        line1='CIII1908'
        line2='HeII1640'
        line3='CIV1550'
        line4='HeII1640'
        xrange    = [1e-3,1e3]
        yrange    = [2e-4,1.5e2]
        boxranges = [1e-99,1e99,0.5,1e99]

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='Zgas',logx=True,logy=True,logp1=True,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_CIIIHeIIvsCIVdHeII_Zgas.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='winter',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='logUs',logx=True,logy=True,logp1=False,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_CIIIHeIIvsCIVdHeII_logUs.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='spring',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (3 in plotnumbers) or (99 in plotnumbers):
        pass

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (4 in plotnumbers) or (99 in plotnumbers):
        line1='NV1240'
        line2='CIV1550'
        line3='CIV1550'
        line4='HeII1640'
        xrange    = [5e-5,1e1]
        yrange    = [2e-4,3e2]
        boxranges = [2.05,1e99,0.5,1e99]

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='Zgas',logx=True,logy=True,logp1=True,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,
plotname='./photomodels_NVCIVdvsCIVdHeII_Zgas.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='winter',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='logUs',logx=True,logy=True,logp1=False,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_NVCIVdvsCIVdHeII_logUs.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='spring',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if (5 in plotnumbers) or (99 in plotnumbers):
        line1='NV1240'
        line2='HeII1640'
        line3='CIV1550'
        line4='HeII1640'
        xrange    = [1e-6,1e3]
        yrange    = [1e-4,3e2]
        boxranges = [1.02,1e99,0.5,1e99]

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='Zgas',logx=True,logy=True,logp1=True,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_NVHeIIvsCIVdHeII_Zgas.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='winter',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)

        bbs.plot_feltregutkinmodels(modeldata,line1=line1,line2=line2,line3=line3,line4=line4,verbose=verbose,varyparam='logUs',logx=True,logy=True,logp1=False,fixxrange=xrange,fixyrange=yrange,cutSFmodels=cutSFmodels,plotname='./photomodels_NVHeIIvsCIVHeII_logUs.pdf', xid=xid, nh=nh, COratio=COratio, Mcutoff=Mcutoff,modeldata2=modeldata2,colormap='spring',boxranges=boxranges,legpos='lower right',smallsyms=smallsyms)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_singlelinetemplate(outfits='./felis_testing/uves_felis_template_singleline.fits',verbose=True):
    """
    Wrapper to generate spectral template with a single line

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.gen_singlelinetemplate()
    """
    doubletlam  = [1907.0,1909.0]
    rangeDlam   = [np.min(doubletlam)-5.0,np.max(doubletlam)+15.0,0.1]
    tcdic = {}
    tcdic['LINE1'] = ['GAUSS', 1907.0, 0.5/4.5, 0.0, 10.0/4.5, 'CIII]1907A mimicking line']
    #tcdic['CONT']  = ['CONT', 1.0, 0.0, 1908.0,       'Continuum with flux 1.0 at 1908 + slope 0.0']
    valstring = '_Singleline_sig_0p5_flux_10p0'
    tempname = outfits.replace('.fits',valstring+'.fits')
    fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=True)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_felistemplates(outfits='./uves_felis_template.fits',overwrite=False,addLSF=False,verbose=True):
    """
    Wrapper to generate spectral templates for cross-correlation with spectra.

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    outdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/felis_testing/'
    uves.gen_felistemplates(outfits=outdir+'uves_felis_template.fits')

    """
    # - - - - - - - - - - - - - - - - - - LSF setup  - - - - - - - - - - - - - - - - - - -
    MUSELSFfwhm  = 1.0 #[A]
    MUSELSFsigma = MUSELSFfwhm/2.354
    LSFparam     = ['LSF', MUSELSFsigma,  'MUSE GAUSS LSF']

    # - - - - - - - - - - - - - - - - - - Width and raange setup - - - - - - - - - - - - - - - - - -
    dlam          = 0.05                                      # wavelength grid spacing in angstrom/pix
    tempwidth     = 10.0                                      # the wavelength range of template (half the width)
    sigmas        = np.array([ 0.2,  0.4,  0.6,  0.8,  1. ,  1.2]) # line width of emission lines in agnstrom
    sigmas_pix    = sigmas / dlam

    # - - - - - - - - - - - - - - - - - - CIII doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1906.68,1908.73]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxCIII1   = 1.0
    fluxratios  = [0.1,0.4,0.7,1.0,1.3,1.6,1.9] # Osterbrock predicts CIII1/CIII2 < 1.6

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the CIII doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxCIII2 = fluxCIII1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['CIII1']                 = ['GAUSS', doubletlam[0], sig, 0.0, fluxCIII1, 'CIII]1907A']
            tcdic['CIII2']                 = ['GAUSS', doubletlam[1], sig, 0.0, fluxCIII2,  'CIII]1909A']

            valstring = '_CIIIdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - CIV doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1548.195,1550.770]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxCIV1    = 1.0
    fluxratios  = [0.5,1.0,1.5,2.0,2.5,3.0] # Feibelman 1983 predicts CIV1/CIV2=2 from theory (Mainali+17 used CIV1/CIV2=1)

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the CIV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxCIV2 = fluxCIV1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['CIV1']                  = ['GAUSS', doubletlam[0], sig, 0.0, fluxCIV1, 'CIV1548A']
            tcdic['CIV2']                  = ['GAUSS', doubletlam[1], sig, 0.0, fluxCIV2,  'CIV1551A']

            valstring = '_CIVdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - NV doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1238.821,1242.804]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxNV1     = 1.0
    fluxratios  = [0.5,1.0,1.5,2.0,2.5,3.0] # Torres-Peimbert, S. & Pena, M. 1984; emissivity ratio of NV1/NV2~2 like CIV

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the NV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxNV2 = fluxNV1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['NV1']                   = ['GAUSS', doubletlam[0], sig, 0.0, fluxNV1, 'NV1239A']
            tcdic['NV2']                   = ['GAUSS', doubletlam[1], sig, 0.0, fluxNV2, 'NV1243A']

            valstring = '_NVdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - OIII doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1660.809,1666.150]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxOIII1   = 1.0
    fluxratios  = [0.1,0.3,0.5,0.7,0.9,1.1] # Morton1991tab2 OIII1/OIII2~0.5 (can be lower and higher but 1666 strongest, see eg. Mainali+17, Vanzella+16, )

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the NV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxOIII2 = fluxOIII1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['OIII1']  = ['GAUSS', doubletlam[0], sig, 0.0, fluxOIII1, 'OIII1661A']
            tcdic['OIII2']  = ['GAUSS', doubletlam[1], sig, 0.0, fluxOIII2, 'OIII1666A']

            valstring = '_OIIIdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - HeII gauss - - - - - - - - - - - - - - - - - -
    linelam     = 1640.420
    rangeDlam   = [linelam-tempwidth,linelam+tempwidth,dlam]

    Ntemps      = len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the HeII line (varying sigma)')

    for sig in sigmas:
        tcdic = {}
        tcdic['HeII']                  = ['GAUSS', linelam, sig, 0.0, 1.0, 'HeII1640A']

        valstring = '_HeII'+\
                    '_sig_'+str(sig).replace('.','p')

        if addLSF:
            tcdic['LSF']        = LSFparam
            valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

        tempname = outfits.replace('.fits',valstring+'.fits')
        fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - SiIII doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [1882.71,1892.03] # See detection from Berg+19
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxSiIII1  = 1.0
    fluxratios  = [0.1,0.4,0.7,1.0,1.3,1.6,1.9] # Osterbrock predicts SIII1/SIII2 < 1.7 similar to CIII doublet

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the NV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxSiIII2 = fluxSiIII1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['Si3_1']  = ['GAUSS', doubletlam[0], sig, 0.0, fluxSiIII1, 'SiIII1883A']
            tcdic['Si3_2']  = ['GAUSS', doubletlam[1], sig, 0.0, fluxSiIII2, 'SiIII1892A']

            valstring = '_SiIIIdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)


    # - - - - - - - - - - - - - - - - - - CII gauss - - - - - - - - - - - - - - - - - -
    linelam     = 1335.6627
    rangeDlam   = [linelam-tempwidth,linelam+tempwidth,dlam]

    Ntemps      = len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the CII line (varying sigma)')

    for sig in sigmas:
        tcdic = {}
        tcdic['CII']                  = ['GAUSS', linelam, sig, 0.0, 1.0, 'CII1336A']

        valstring = '_CII'+\
                    '_sig_'+str(sig).replace('.','p')

        if addLSF:
            tcdic['LSF']        = LSFparam
            valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

        tempname = outfits.replace('.fits',valstring+'.fits')
        fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - CII] gauss - - - - - - - - - - - - - - - - - -
    linelam     = 2326.113
    rangeDlam   = [linelam-tempwidth,linelam+tempwidth,dlam]

    Ntemps      = len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the CII] line (varying sigma)')

    for sig in sigmas:
        tcdic = {}
        tcdic['CIIb']                  = ['GAUSS', linelam, sig, 0.0, 1.0, 'CII]2326A']

        valstring = '_CIIb'+\
                    '_sig_'+str(sig).replace('.','p')

        if addLSF:
            tcdic['LSF']        = LSFparam
            valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

        tempname = outfits.replace('.fits',valstring+'.fits')
        fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

    # - - - - - - - - - - - - - - - - - - MgII doublet - - - - - - - - - - - - - - - - - -
    doubletlam  = [2795.528,2802.705]
    rangeDlam   = [np.min(doubletlam)-tempwidth,np.max(doubletlam)+tempwidth,dlam]
    fluxMgII1   = 1.0
    fluxratios  = [0.1,0.4,0.7,1.0,1.3,1.6,1.9] # ???

    Ntemps      = len(fluxratios)*len(sigmas)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the NV doublet (varying sigma and flux ratio)')

    for fr in fluxratios:
        fluxMgII2 = fluxMgII1 / fr
        for sig in sigmas:
            tcdic = {}
            tcdic['MgII1']  = ['GAUSS', doubletlam[0], sig, 0.0, fluxMgII1, 'MgII2796A']
            tcdic['MgII2']  = ['GAUSS', doubletlam[1], sig, 0.0, fluxMgII2, 'MgII2803A']

            valstring = '_MgIIdoublet'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_fluxratio_'+str(fr).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)


    # - - - - - - - - - - - - - - - - - - Width and raange setup - - - - - - - - - - - - - - - - - -
    #FWHM observed for MW LAEs <~10 which corresponds to 10/2.35 / (1+3) <~ 1.06 Angstrom rest-frame
    dlam          = 0.05                                       # wavelength grid spacing in angstrom/pix
    tempwidth     = 20.0                                       # the wavelength range of template (half the width)
    sigmas        = np.array([0.32,0.64,1.28,2.56,5.12,10.24]) # line width of emission lines in agnstrom (rest-frame)
    sigmas_pix    = sigmas/dlam
    # - - - - - - - - - - - - - - - - - - Lya skew gauss - - - - - - - - - - - - - - - - - -
    linelam     = 1215.6737
    rangeDlam   = [linelam-tempwidth,linelam+tempwidth,dlam]
    Lyaskew     = [0.0,3.0,6.0,9.0,12.0]

    Ntemps      = len(sigmas)*len(Lyaskew)
    if verbose: print(' - generating '+str(Ntemps)+' templates for the Lya line (varying sigma and skew)')

    for sig in sigmas:
        for skew in Lyaskew:
            tcdic = {}
            tcdic['Lya']                  = ['GAUSS', linelam, sig, skew, 1.0, 'Lya1216A']

            valstring = '_Lya'+\
                        '_sig_'+str(sig).replace('.','p')+\
                        '_skew_'+str(skew).replace('.','p')

            if addLSF:
                tcdic['LSF']        = LSFparam
                valstring = valstring+'_LSF_'+str(LSFparam[1]).replace('.','p')

            tempname = outfits.replace('.fits',valstring+'.fits')
            fbt.build_template(rangeDlam,tcdic,tempfile=tempname,overwrite=overwrite)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_felismockspec(outfits='./uves_felis_mock_MUSEspectrum.fits',redshift=3.5,
                      zoomxplot=None,verbose=True):
    """
    Wrapper to generate a set of mock MUSE spectra to test FELIS on

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    outdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/felis_testing/'
    uves.gen_felismockspec(outfits=outdir+'uves_felis_mock_MUSEspectrum.fits',redshift=3.5,zoomxplot=np.array([1880,1940])*(1+3.5))

    """
    if verbose: print(' - Building mockspectra at redshift '+str(redshift)+' using FELIS tools')
    tcdic = {}
    #tcdic['CONT']                   = ['CONT',  1.0, 0.0, 0.0,          'Flat continuum at 1.0']

    voffsetCIV = -200 #km/s
    lam_obsCIV1, lam_offsetCIV1, dlamCIV1 = kbs.velocityoffset2dwave(redshift,voffsetCIV,1548.195,verbose=verbose)
    tcdic['CIV1']  = ['GAUSS', lam_offsetCIV1, 0.5, 0.0, 10.0, 'CIV1548A']

    lam_obsCIV2, lam_offsetCIV2, dlamCIV2 = kbs.velocityoffset2dwave(redshift,voffsetCIV,1550.770,verbose=verbose)
    tcdic['CIV2']  = ['GAUSS', lam_offsetCIV2, 0.5, 0.0, 5.0,  'CIV1551A']

    tcdic['CIII1'] = ['GAUSS', 1907.0 * (1+redshift), 0.5, 0.0, 10.0, 'CIII]1907A']

    tcdic['CIII2'] = ['GAUSS', 1909.0 * (1+redshift), 0.5, 0.0, 5.0,  'CIII]1909A']

    voffsetLYA = -500 #km/s
    lam_obsLYA, lam_offsetLYA, dlamLYA = kbs.velocityoffset2dwave(redshift,voffsetLYA,1216.0,verbose=verbose)
    tcdic['LYA']   = ['GAUSS', lam_offsetLYA, 20.0, 10.0, 100.0, 'Lya1216']

    noisesigmas = [0.05,0.5,1.0,3.0]
    for sigma in noisesigmas:
        mockspec = outfits.replace('.fits','_noisesigma'+str(sigma).replace('.','p')+'.fits')
        noise    = ['GAUSS', 0.0, sigma]
        fbt.build_template([4800,9300,0.25],tcdic,tempfile=mockspec,noise=noise,overwrite=True,zoomxplot=zoomxplot)
        if verbose: print(' - Wrote output spectrum to '+mockspec)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_felismockspec_fromsetupfile(specsetup,basename='./uves_felis_mock_spectrum_fromsetup.fits',
                                    plotspectra=False,overwrite=False,noisesetup='errspec',
                                    verbose=True,verbose_buildtemp=False):
    """
    Wrapper to generate a set of mock spectra to test FELIS on.
    The setup of each of the mock spectra are defined in the spec setup file

    Note; by setting noisesetup=None templates can be generated for the FELIS fitting using a similar setup file.

    --- INPUT ---
    specsetup           Setup file containing the components and spectra to generate
    basename            Main name (and dir) of mock fits spectra to generate
    plotspectra         To plot the generated spectra set this to true
    overwrite           Overwrite existing files?
    verbose             Toggle verbosity
    verbose_buildtemp   Toggle verbosity of the FELIS function building the template

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    basename   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra/uves_mock_spectrum_fromsetup.fits'
    specsetup  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_setup.txt'
    uves.gen_felismockspec_fromsetupfile(specsetup,basename=basename,verbose_buildtemp=True,overwrite=True,plotspectra=True)

    """
    if verbose: print(' - Building mockspectra using FELIS tools')
    templatedat = np.genfromtxt(specsetup,names=True,skip_header=7,comments='#',
                                dtype='80a,80a,80a,80a,80a,80a,80a,80a,80a,d,d,80a,80a')
    # ----- load error spectrum to use for noise simulations -----
    if noisesetup.lower() == 'errspec':
        skyspec     = None # should be noise spectrum '/Users/kschmidt/work/MUSE/skyspectra/SKY_SPECTRUM_candels-cdfs-36_av.fits'
        errspec     = '/Users/kschmidt/work/MUSE/spectra_noise/median_eff_noise_spectrum_70fields190819.fits'
        noisewave   = afits.open(errspec)[1].data['wave']
        noiseflux   = afits.open(errspec)[1].data['flux'] * 5.5 # 5.5 corresponds to r=0.6'' (30 pixel) aperture
                                                                # spectrum as total noise on such spectrum would
                                                                # be pix_noise x 30/sqrt(30)
        noise       = ['SPECTRUM', noisewave, noiseflux]
    elif noisesetup.lower() == 'fixedvalue':
        noisesigma  = 0.2
        noisemean   = 0.5
        noise       = ['GAUSS', noisemean, noisesigma]
    elif noisesetup.lower() == 'none':
        noise       = None
        noisesigma  = None

    for tt, tempname in enumerate(templatedat['namekey']):
        tempdic = {}
        linewaves  = np.asarray(templatedat['linewaves'][tt][1:-1].split(',')).astype(float)
        linesigmas = np.asarray(templatedat['sigmas'][tt][1:-1].split(',')).astype(float)
        lineskews  = np.asarray(templatedat['skew'][tt][1:-1].split(',')).astype(float)
        linefluxes = np.asarray(templatedat['scaling'][tt][1:-1].split(',')).astype(float)
        redshifts  = np.asarray(templatedat['redshift'][tt][1:-1].split(',')).astype(float)
        fratios    = np.asarray(templatedat['fratios'][tt][1:-1].split(',')).astype(float)

        for linesigma in linesigmas:
            for lineskew in lineskews:
                for lineflux in linefluxes:
                    for zval in redshifts:
                        for fratio in fratios:
                            tempdic['line1'] = [templatedat['type'][tt], linewaves[0] * (1+zval),
                                                linesigma, lineskew,
                                                lineflux, templatedat['headerinfo'][tt]+'_1']
                            if len(linewaves) == 2:
                                tempdic['line2'] = [templatedat['type'][tt], linewaves[1] * (1+zval),
                                                    linesigma, lineskew,
                                                    lineflux / fratio, templatedat['headerinfo'][tt]+'_2']
                                Ftotspec         = lineflux + lineflux / fratio
                            else:
                                Ftotspec         = lineflux

                            wavecen  = np.mean(linewaves)* (1+zval)
                            wavemin  = wavecen-templatedat['waverange'][tt]/2.* (1+zval)
                            wavemax  = wavecen+templatedat['waverange'][tt]/2.* (1+zval)

                            outstr   = '_'+tempname+\
                                       '_noisestd'+str(noisesigma).replace('.','p')+\
                                       '_sigma'+str("%.2f" % linesigma).replace('.','p')+\
                                       '_skew'+str("%.2f" % lineskew).replace('.','p')+\
                                       '_Ftot'+str("%.2f" % Ftotspec).replace('.','p')+\
                                       '_Fratio'+str("%.2f" % fratio).replace('.','p')+\
                                       '_z'+str("%.2f" % zval).replace('.','p')+\
                                       '.fits'
                            if noisesetup.lower() == 'errspec':
                                outstr = outstr.replace('_noisestd'+str(noisesigma).replace('.','p'),'_noisespec')
                            mockspec = basename.replace('.fits',outstr)
                            try:
                                fbt.build_template([wavemin,wavemax,templatedat['dwave'][tt]],
                                                   tempdic,tempfile=mockspec,
                                                   noise=noise,overwrite=overwrite,
                                                   plottemplate=plotspectra,zoomxplot=[wavemin,wavemax],
                                                   verbose=verbose_buildtemp,
                                                   waveunits=templatedat['waveunits'][tt],
                                                   fluxunits=templatedat['fluxunits'][tt])
                            except:
                                print('\n\n ERROR: fbt.build_template failed... stopping to enable invesitgations')
                                pdb.set_trace()

                            if verbose: print(' - Genreated spectrum:   '+mockspec)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def build_mockspeck_setup_parametertable(setupfile,skip_header=7,noisestr='_noisespec',basename='',verbose=True):
    """
    Function to write (and load) table with parameter sets of the individual spectra generated from setupfile with
    uves.gen_felismockspec_fromsetupfile(). Essentially just expanding the parameter lists.

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    basename   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra/uves_mock_spectrum_fromsetup.fits'
    specsetup  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_setup.txt'
    paramtable = uves.build_mockspeck_setup_parametertable(specsetup,basename=basename)

    """
    templatedat = np.genfromtxt(setupfile,names=True,skip_header=skip_header,
                                comments='#',dtype='80a,80a,80a,80a,80a,80a,80a,80a,80a,d,d,80a,80a')
    outputfile  = setupfile.replace('.txt','_parametertable.txt')

    fout = open(outputfile,'w')
    fout.write('# Parameter table of spectra generated with uves.gen_felismockspec_fromsetupfile() based on the setup\n')
    fout.write('# '+setupfile+'\n')
    fout.write('# \n')
    fout.write('#  linesigma     lineskew     lineflux     Ftotspec     redshift       Fratio       dwave              waveunits    fluxunits            specname \n')
    for tt, tempname in enumerate(templatedat['namekey']):
        linewaves  = np.asarray(templatedat['linewaves'][tt][1:-1].split(',')).astype(float)
        linesigmas = np.asarray(templatedat['sigmas'][tt][1:-1].split(',')).astype(float)
        lineskews  = np.asarray(templatedat['skew'][tt][1:-1].split(',')).astype(float)
        linefluxes = np.asarray(templatedat['scaling'][tt][1:-1].split(',')).astype(float)
        redshifts  = np.asarray(templatedat['redshift'][tt][1:-1].split(',')).astype(float)
        fratios    = np.asarray(templatedat['fratios'][tt][1:-1].split(',')).astype(float)
        dwave      = templatedat['dwave'][tt]
        fluxunits  = templatedat['fluxunits'][tt]
        waveunits  = templatedat['waveunits'][tt]

        for linesigma in linesigmas:
            for lineskew in lineskews:
                for lineflux in linefluxes:
                    for zval in redshifts:
                        for fratio in fratios:
                            if len(linewaves) == 2:
                                Ftotspec         = lineflux + lineflux/fratio
                            else:
                                Ftotspec         = lineflux

                            specext    = '_'+tempname+\
                                         noisestr+\
                                         '_sigma'+str("%.2f" % linesigma).replace('.','p')+\
                                         '_skew'+str("%.2f" % lineskew).replace('.','p')+\
                                         '_Ftot'+str("%.2f" % Ftotspec).replace('.','p')+\
                                         '_Fratio'+str("%.2f" % fratio).replace('.','p')+\
                                         '_z'+str("%.2f" % zval).replace('.','p')+\
                                         '.fits'
                            specname  = basename.replace('.fits',specext)

                            paramlist = str("%12.4f" % linesigma)+' '+\
                                        str("%12.4f" % lineskew)+' '+\
                                        str("%12.4f" % lineflux)+' '+\
                                        str("%12.4f" % Ftotspec)+' '+\
                                        str("%12.4f" % zval)+' '+\
                                        str("%12.4f" % fratio)+' '+\
                                        str("%12.4f" % dwave)+' '+\
                                        str("%20s" % waveunits)+' '+\
                                        str("%20s" % fluxunits)
                            fout.write(paramlist+'     '+specname+'\n')
    fout.close()

    paramtable = np.genfromtxt(outputfile,names=True,comments='#',skip_header=3,dtype='d,d,d,d,d,d,d,20a,20a,200a')
    return paramtable

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def pre190911_gen_mocspecFELISresults_summary(summaryfile,picklefiles,overwrite=False,verbose=True):
    """
    Generate a summary of the template characteristics FELIS determined to match the mock spectra
    the best, i.e. with the highest S/N.

    - - - - - - - - - - - - - - - - - - - - - -  NB - - - - - - - - - - - - - - - - - - - - - - -
    - - -  After correcting the FELIS normalization this function was depreciated on 190911 - - -
    - - -  Instead the summarizing can now be done with the new version of the function     - - -

    --- INPUT ---
    summaryfile        Path and name to summary file to generate.
    picklefiles        List of FELIS pickle files to summarize.
    overwrite          Overwrite the summary file if it already exists?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    FELISoutputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults/'
    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_all.txt'
    picklefiles    = glob.glob(FELISoutputdir+'*.pkl')
    summarydat     = uves.gen_mocspecFELISresults_summary(summaryfile,picklefiles)

    """
    if verbose: print(' - Generating a summary of the best-fit template in:\n   '+summaryfile)
    if os.path.isfile(summaryfile) & (not overwrite):
        sys.exit(' Summary file '+summaryfile+' already exists and overwrite=False ')

    fout = open(summaryfile,'w')
    fout.write('# Summary of '+str(len(picklefiles))+' FELIS pickle files provided \n')
    fout.write('# File contains the characteristics of the templates with max S/N from the FELIS template fits \n')
    fout.write('# The summary was generated with uves.compate_mockspec_to_FELISresults() on '+kbs.DandTstr2()+' \n')
    fout.write('# \n')
    fout.write('# Columns are:\n')
    fout.write('# z_spec                     Instrinspic redshift of matched mock spectrum \n')
    fout.write('# z_temp_S2Nmax              Estimated redshift from template match\n')
    fout.write('# sigma_spec_pix             Input sigma in pixels for mock spectrum (mean for multiple lines)\n')
    fout.write('# sigma_spec_ang_rf          Input sigma in rest-frame angstroms for mock spectrum (mean for multiple lines)\n')
    fout.write('# sigma_temp_pix             Input sigma in pixels for maxS/N template (mean for multiple lines)\n')
    fout.write('# sigma_temp_ang_rf          Input sigma in rest-frame angstroms for maxS/N template (mean for multiple lines)\n')
    fout.write('# Fratio_spec                Flux ratio of doublets in mock spectrum (line_lowwave/line_highwave) \n')
    fout.write('# Fratio_temp                Flux ratio of doublets in template      (line_lowwave/line_highwave) \n')
    fout.write('# Ftot_spec_intr             Intrinsic total flux of mock spectrum \n')
    fout.write('# Ftot_spec_trapz            Integreated total flux of mock spectrum after noise addition \n')
    fout.write('# Ftot_spec_trapz_err        Uncertainty on Ftot_spec_trapz (mock spectrum flux errors propogated) \n')
    fout.write('# Ftot_temp_trapz            Integreated total flux of normalized template scaled by fluxscale_S2Nmax\n')
    fout.write('# Ftot_temp_trapz_err        Uncertainty on Ftot_temp_trapz (mock spectrum flux errors propogated) \n')
    fout.write('# Ftot_temp_trapz_fsclaeerr  Uncertainty on Ftot_temp_trapz (using fluxscaleerr_S2Nmax for all pixels) \n')
    fout.write('# Ftot_temp_sum              Summed total flux of normalized template scaled by fluxscale_S2Nmax\n')
    fout.write('# Ftot_temp_sum_err          Uncertainty on Ftot_sum_trapz (mock spectrum flux errors propogated) \n')
    fout.write('# Ftot_temp_sum_fsclaeerr    Uncertainty on Ftot_sum_trapz (using fluxscaleerr_S2Nmax for all pixels) \n')
    fout.write('# vshift_spec                Known intrinsic velocity shift of mock spectrum \n')
    fout.write('# vshift_CCmatch             Estimated velocity shift from template match [ c*(z_spec-z_temp_S2Nmax)/(1+z_temp_S2Nmax) ]\n')
    fout.write('# fluxscale_S2Nmax           Flux scale applied to normalized template to obtain maxS/N match \n')
    fout.write('# fluxscaleerr_S2Nmax        Uncertainty on fluxscale_S2Nmax [sqrt(fluxscale_variance)]\n')
    fout.write('# S2Nmax                     The S/N value of the (scaled) template match to the mock spectrum \n')
    fout.write('# Ngoodent                   The number of good pixels used in the cross correlation \n')
    fout.write('# chi2                       Chi^2 value between the mock spectrum and the template match \n')
    fout.write('# lineS2N                    Estimated S/N of spectral feature within [lineS2Nwavemin,lineS2Nwavemin] \n')
    fout.write('# lineS2Nwavemin             Lower integration limit for S/N estimate \n')
    fout.write('# lineS2Nwavemax             Upper integration limit for S/N estimate \n')
    fout.write('# lineS2N_rf                 Estimated S/N (rest-frame) of spectral feature within [lineS2Nwavemin_rf,lineS2Nwavemin_rf] \n')
    fout.write('# lineS2Nwavemin_rf          Lower integration limit for rest-frame S/N estimate \n')
    fout.write('# lineS2Nwavemax_rf          Upper integration limit for rest-frame S/N estimate \n')
    fout.write('# Ftot                       Total flux of spectral feature (sum(f)*dwave) used to estimate line S/N \n')
    fout.write('# Ftot_sigma                 Squaroot of the variance/sqrt(Npix) of Ftot \n')
    fout.write('# spectrum                   The mock spectrum the templates were matched to \n')
    fout.write('# template                   The maxS/N template \n')
    fout.write('# \n')
    fout.write('# z_spec z_temp_S2Nmax    sigma_spec_pix sigma_spec_ang_rf sigma_temp_pix sigma_temp_ang_rf   '
               ' Fratio_spec Fratio_temp     '
               'Ftot_spec_intr Ftot_spec_trapz Ftot_spec_trapz_err '
               'Ftot_temp_trapz Ftot_temp_trapz_err Ftot_temp_trapz_fsclaeerr     '
               'Ftot_temp_sum Ftot_temp_sum_err Ftot_temp_sum_fsclaeerr '
               'vshift_spec vshift_CCmatch     fluxscale_S2Nmax fluxscaleerr_S2Nmax    '
               'S2Nmax Ngoodent chi2    '
               'lineS2N lineS2Nwavemin lineS2Nwavemax lineS2N_rf lineS2Nwavemin_rf lineS2Nwavemax_rf     '
               'Ftot Ftot_sigma     spectrum template \n')

    for pp, picklefile in enumerate(picklefiles):
        if verbose:
            infostr = ' - Summarizing picklefile  '+str("%.5d" % (pp+1))+' / '+str("%.5d" % len(picklefiles))+'     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        loaddic       = felis.load_picklefile(picklefile)

        Nsigma_integration = 3.0

        for specname in loaddic.keys():
            keydic = loaddic[specname]

            # load info about max S/N template
            template, vshift_intr, vshift_match, fluxscale_S2Nmax, fluxscaleerr_S2Nmax, \
            S2Nmax, Ngoodent, chi2, z_spec, zS2Nmax =  \
                felis.getresult4maxS2N(loaddic,specname)

            # load matched spec and move to restframe
            s_wave   , s_flux   , s_df   , s_s2n    = felis.load_spectrum(specname,verbose=False)
            s_wave_rf, s_flux_rf, s_df_rf, s_s2n_rf = s_wave / (1+z_spec), s_flux * (1+z_spec), s_df * (1+z_spec), s_s2n

            # interpolate max S/N template to spec grid
            min_template_level = 1e-4
            t_wave_init, t_flux_init, t_df_init, t_s2n_init = felis.load_spectrum(template,verbose=False)
            func       = scipy.interpolate.interp1d(t_wave_init,t_flux_init,kind='linear',fill_value="extrapolate")
            t_flux     = func(s_wave_rf)
            t_flux[t_flux < min_template_level] = 0.0

            # Normalize template flux to 1
            if len(t_flux[t_flux != 0]) == 0:
                if verbose: print(' WARNING All interpolated template pixels are 0.0')
            else:
                temp_sum = np.sum(t_flux)
                t_flux   = t_flux / temp_sum

            # extract info on template and mockspec from fits headers
            spec_hdr        = afits.open(specname)[1].header
            spec_sigma_ang  = np.array([])
            spec_flux       = np.array([])
            spec_line_wave  = np.array([])
            for hdrkey in spec_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: spec_line_wave = np.append(spec_line_wave,spec_hdr[hdrkey])
                    if '_2' in hdrkey: spec_sigma_ang = np.append(spec_sigma_ang,spec_hdr[hdrkey])
                    if '_4' in hdrkey: spec_flux      = np.append(spec_flux,spec_hdr[hdrkey])

            spec_sigma_ang_rf  = np.mean(spec_sigma_ang) / (1.0+z_spec)
            spec_sigma_pix     = spec_sigma_ang_rf       / np.median(np.diff(s_wave_rf))
            Ftot_spec_intr     = np.sum(spec_flux)
            if len(spec_flux) == 2:
                Fratio_spec = spec_flux[np.where(spec_line_wave == np.min(spec_line_wave))] / \
                              spec_flux[np.where(spec_line_wave == np.max(spec_line_wave))]
            else:
                Fratio_spec = 0.0


            lineS2Nwavemin = np.min(spec_line_wave)-Nsigma_integration*np.median(spec_sigma_ang)
            lineS2Nwavemax = np.max(spec_line_wave)+Nsigma_integration*np.median(spec_sigma_ang)
            waverange      = [lineS2Nwavemin,lineS2Nwavemax]
            goodent        = np.where((s_wave >= waverange[0]) & (s_wave <= waverange[1]))

            lineS2Nwavemin_rf = np.min(spec_line_wave/(1.0+z_spec))-Nsigma_integration*spec_sigma_ang_rf
            lineS2Nwavemax_rf = np.max(spec_line_wave/(1.0+z_spec))+Nsigma_integration*spec_sigma_ang_rf
            waverange_rf      = [lineS2Nwavemin_rf,lineS2Nwavemax_rf]
            goodent_rf        = np.where((s_wave_rf >= waverange_rf[0]) & (s_wave_rf <= waverange_rf[1]))

            # Ftot_trapz = np.trapz(fluxscale_S2Nmax * t_flux,s_wave_rf)
            datarr               = unumpy.uarray(fluxscale_S2Nmax * t_flux[goodent_rf], s_df_rf[goodent_rf])
            Ftot_trapz           = np.trapz(datarr,s_wave_rf[goodent_rf])
            Ftot_sum             = np.sum(datarr) * np.median(np.diff(s_wave_rf[goodent_rf]))

            datarr_fscaleerr     = unumpy.uarray(fluxscale_S2Nmax * t_flux[goodent_rf], fluxscaleerr_S2Nmax + t_flux[goodent_rf]*0.0)
            Ftot_trapz_fscaleerr = np.trapz(datarr_fscaleerr,s_wave_rf[goodent_rf])
            Ftot_sum_fscaleerr   = np.sum(datarr) * np.median(np.diff(s_wave_rf[goodent_rf]))

            datarr_spec        = unumpy.uarray(s_flux_rf[goodent_rf], s_df_rf[goodent_rf])
            Ftot_trapz_spec    = np.trapz(datarr_spec,s_wave_rf[goodent_rf])

            temp_hdr        = afits.open(template)[1].header
            temp_sigma_ang  = np.asarray([])
            temp_flux       = np.asarray([])
            temp_line_wave  = np.asarray([])
            for hdrkey in temp_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: temp_line_wave = np.append(temp_line_wave,temp_hdr[hdrkey])
                    if '_2' in hdrkey: temp_sigma_ang = np.append(temp_sigma_ang,temp_hdr[hdrkey])
                    if '_4' in hdrkey: temp_flux      = np.append(temp_flux,temp_hdr[hdrkey])

            temp_sigma_ang_rf = np.mean(temp_sigma_ang) / (1.0+0.0)
            temp_sigma_pix    = np.mean(temp_sigma_ang) / np.median(np.diff(t_wave_init))
            if len(temp_flux) == 2:
                Fratio_temp = temp_flux[np.where(temp_line_wave == np.min(temp_line_wave))] / \
                              temp_flux[np.where(temp_line_wave == np.max(temp_line_wave))]
            else:
                Fratio_temp = 0.0

            #------------ Estimating S/N ------------
            Ftot, vartot, Npixgood, lineS2N = uves.calc_1Dspec_S2N(s_wave,s_flux,s_df**2.0,
                                                                   waverange,verbose=False)
            Ftot_sigma = np.sqrt(vartot)

            Ftot_rf, vartot_rf, Npixgood_rf, lineS2N_rf = uves.calc_1Dspec_S2N(s_wave_rf,s_flux_rf,s_df_rf**2.0,
                                                                               waverange_rf,verbose=False)

            if (Ftot-Ftot_rf) > 1.0:
                print(' - Ftot-Ftot_rf is less than 1e-20cgs; stopping to enable investigation')
                pdb.set_trace()

            #------------ Writing to output file ------------
            outstr = str("%7.4f" % z_spec)+'  '+\
                     str("%7.4f" % zS2Nmax)+'      '+\
                     str("%7.4f" % np.mean(spec_sigma_pix))+'  '+\
                     str("%7.4f" % spec_sigma_ang_rf)+'  '+\
                     str("%7.4f" % np.mean(temp_sigma_pix))+'  '+\
                     str("%7.4f" % temp_sigma_ang_rf)+'      '+\
                     str("%7.2f" % Fratio_spec)+'  '+\
                     str("%7.2f" % Fratio_temp)+'      '+\
                     str("%12.4f" % Ftot_spec_intr)+'  '+\
                     str("%12.4f" % Ftot_trapz_spec.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_trapz_spec.std_dev)+'  '+\
                     str("%12.4f" % Ftot_trapz.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_trapz.std_dev)+'  '+\
                     str("%12.4f" % Ftot_trapz_fscaleerr.std_dev)+'           '+\
                     str("%12.4f" % Ftot_sum.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_sum.std_dev)+'  '+\
                     str("%12.4f" % Ftot_sum_fscaleerr.std_dev)+'           '+\
                     str("%12.4f" % vshift_intr)+'  '+\
                     str("%12.4f" % vshift_match)+'      '+\
                     str("%12.4f" % fluxscale_S2Nmax)+'  '+\
                     str("%12.4f" % fluxscaleerr_S2Nmax)+'  '+\
                     str("%12.4f" % S2Nmax)+'  '+\
                     str("%12.4f" % Ngoodent)+'  '+\
                     str("%12.4f" % chi2)+'  '+\
                     str("%12.4f" % lineS2N)+'  '+\
                     str("%12.4f" % lineS2Nwavemin)+'  '+\
                     str("%12.4f" % lineS2Nwavemax)+'  '+\
                     str("%12.4f" % lineS2N_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemin_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemax_rf)+'  '+\
                     str("%12.4f" % Ftot)+'  '+\
                     str("%12.4f" % Ftot_sigma)+'  '+\
                     specname+'  '+\
                     template+'  '
            fout.write(outstr+'\n')
    if verbose: print('\n   ...done')
    fout.close()

    fmt = 'd,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=39,dtype=fmt,comments='#',names=True)
    return summarydat
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def pre190911_plot_mocspecFELISresults_summary(summaryfile,plotbasename,colortype='lineS2N_rf',histaxes=False,Nbins=50,
                                     overwrite=False,verbose=True):
    """
    plotting and evaluating the output from uves.gen_mocspecFELISresults_summary()

    - - - - - - - - - - - - - - - - - - - - - -  NB - - - - - - - - - - - - - - - - - - - - - - -
    - - -  After correcting the FELIS normalization this function was depreciated on 190911 - - -
    - - -  Instead the plotting can now be done with the new version of the function        - - -


    --- INPUT ---
    summaryfile        Path and name to summary file to evaluate
    plotbasename       The based name for the plots to generate (incl. output directory)
    overwrite          Overwrite the plots if they already exist?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary.txt'
    plotbasename   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_plots/190815test_'
    uves.plot_mocspecFELISresults_summary(summaryfile,plotbasename)

    """
    if verbose: print(' - Loading and plotting the content of \n   '+summaryfile)
    fmt = 'd,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=39,dtype=fmt,comments='#',names=True)
    specnumber = np.arange(len(summarydat))+1.0

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'S2NvsS2N'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['lineS2N_rf'])
    yvalues  = np.asarray(summarydat['S2Nmax'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Rest-frame emission line S/N'
    ylabel   = 'Template match S/N'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,colortype='Ftot',
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[1,1000],yrange=[1,1000],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'LineSigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['sigma_spec_ang_rf'])
    yvalues  = np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Mock spectrum $\sigma_\\textrm{Gauss, restframe}$ [\AA]'
    ylabel   = 'Best-fit template $\sigma_\\textrm{Gauss, restframe}$ [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ftot_intrinsic'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_intr'])
    yvalues  = np.asarray(summarydat['fluxscale_S2Nmax'])
    xerr     = [None]*len(xvalues)
    yerr     = summarydat['fluxscaleerr_S2Nmax']
    xlabel   = 'Intrinsic (pre-noise) flux in mock spectrum [1e-20 erg/s/cm$^2$]'
    ylabel   = '$\\alpha$ FELIS template flux estimate [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colortype=colortype,colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ftot_observed'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_trapz'])
    yvalues  = np.asarray(summarydat['fluxscale_S2Nmax'])
    xerr     = summarydat['Ftot_spec_trapz_err']
    yerr     = summarydat['fluxscaleerr_S2Nmax']
    xlabel   = 'Observed (post-noise) flux in mock spectrum [1e-20 erg/s/cm$^2$]'
    ylabel   = '$\\alpha$ FELIS template flux estimate [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colortype=colortype,colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ftot_intrinsic_sum'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_intr'])
    yvalues  = np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = [None]*len(xvalues)
    yerr     = summarydat['Ftot_temp_sum_err']
    xlabel   = 'Total flux in mock spectrum (intrinsic)\\\\(no noise) [1e-20 erg/s/cm$^2$]'
    ylabel   = 'Total flux in best-fit template (sum)\\\\(mock spec noise) [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ftot_observed_sum'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot'])
    yvalues  = np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = summarydat['Ftot_sigma']
    yerr     = summarydat['Ftot_temp_sum_fsclaeerr']
    xlabel   = 'Total flux in mock spectrum (sum)\\\\("observed"; with noise) [1e-20 erg/s/cm$^2$]'
    ylabel   = 'Total flux in best-fit template (sum)\\\\(integrated; flux scale "noise") [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Redshift'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['z_spec'])
    yvalues  = np.asarray(summarydat['z_temp_S2Nmax'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Intrinsic redshift mock spectrum'
    ylabel   = 'Redshift of best-fit template'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='onetoone',
                                                   colortype='vshift',colorcode=True,cdatvec = summarydat['vshift_CCmatch'],
                                                   overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dFtot_vs_S2N'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['S2Nmax'])
    yvalues  = np.asarray(summarydat['Ftot_spec_intr']) - np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = [None]*len(xvalues)
    yerr     = summarydat['Ftot_temp_sum_err']
    xlabel   = 'S/N of template cross match to mock spectrum'
    ylabel   = '$\Delta$Total flux; intrinsic mock spec - best-fit template [1e-20 erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   # yrange=[-3,3],colortype='redshift',
                                                   yrange=None,colortype='redshift',cdatvec = summarydat['z_spec'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dsigma_vs_S2N'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['S2Nmax'])
    yvalues  = np.asarray(summarydat['sigma_spec_ang_rf']) - np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)
    xlabel   = 'S/N of template cross match to mock spectrum'
    ylabel   = '$\Delta\sigma_\\textrm{Gauss, restframe}$; intrinsic mock spec - best-fit template [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   # yrange=[-0.05,0.05],colortype='redshift',
                                                   yrange=None,colortype='redshift',cdatvec = summarydat['z_spec'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dsigma_vs_sigmaspec'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['sigma_spec_ang_rf'])
    yvalues  = np.asarray(summarydat['sigma_spec_ang_rf']) - np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)
    xlabel   = 'Mock spec intrinsic $\sigma_\\textrm{Gauss, restframe}$ [\AA]'
    ylabel   = '$\Delta\sigma_\\textrm{Gauss, restframe}$; intrinsic mock spec - best-fit template [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   # yrange=[-0.05,0.05],colortype=colortype,
                                                   yrange=None,colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dFtot_vs_specno'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = specnumber
    yvalues  = np.asarray(summarydat['Ftot_spec_intr']) - np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
    ylabel   = '$\Delta$Ftot; mock spec - temp match [1e-20erg/s/cm$^2$]'


    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',colortype='Sigma',cdatvec = summarydat['sigma_spec_ang_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dFtot_vs_Ftot'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_intr'])
    yvalues  = np.asarray(summarydat['Ftot_spec_intr']) - np.asarray(summarydat['Ftot_temp_sum'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Ftot mock spec [1e-20erg/s/cm$^2$]'
    ylabel   = '$\Delta$Ftot; mock spec - temp match [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',colortype='Sigma',cdatvec = summarydat['sigma_spec_ang_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_Ftot_vs_Ftot'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['Ftot_spec_intr'])
    yvalues  = (np.asarray(summarydat['Ftot_temp_sum'])/np.asarray(summarydat['Ftot_spec_intr'])) -1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Ftot mock spec [1e-20erg/s/cm$^2$]'
    ylabel   = '(Ftot temp match / Ftot mock spec) - 1 '

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',colortype='Sigma',cdatvec = summarydat['sigma_spec_ang_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # nameext  = 'Ratio_Ftot_vs_lineS2N'
    # plotname = plotbasename+nameext+'.pdf'
    # xvalues  = np.asarray(summarydat['lineS2N_rf'])
    # yvalues  = (np.asarray(summarydat['Ftot_temp_trapz'])/np.asarray(summarydat['Ftot_spec_intr'])) -1.0
    # xerr     = [None]*len(xvalues)
    # yerr     = [None]*len(xvalues)
    # xlabel   = 'Line S/N'
    # ylabel   = '(Ftot temp match / Ftot mock spec) - 1 '
    #
    # uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
    #                                                histaxes=histaxes,Nbins=Nbins,
    #                                                linetype='horizontal',colortype='Ftot_spec_intr',
    #                                                colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_Ftot_vs_lineS2N_sum_temp'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['lineS2N_rf'])
    yvalues  = (np.asarray(summarydat['Ftot_temp_sum'])/np.asarray(summarydat['Ftot_spec_intr'])) -1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Line S/N'
    ylabel   = '(Ftot sum tempalte / Ftot intrinsic) - 1 '

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,yrange=[-0.7,0.7],
                                                   linetype='horizontal',colortype='Ftot_spec_intr',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_Ftot_vs_lineS2N_sum_spec'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['lineS2N_rf'])
    yvalues  = (np.asarray(summarydat['Ftot'])/np.asarray(summarydat['Ftot_spec_intr'])) -1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Line S/N'
    ylabel   = '(Ftot sum mock spec w. noise / Ftot mock spec intrinsic) - 1 '

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,yrange=[-0.7,0.7],
                                                   linetype='horizontal',colortype='Ftot_spec_intr',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dsigma_vs_specno'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = specnumber
    yvalues  = np.asarray(summarydat['sigma_spec_ang_rf']) - np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
    ylabel   = '$\Delta\sigma_\\textrm{rest}$; mock spec - temp match [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dsigma_vs_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['sigma_spec_ang_rf'])
    yvalues  = np.asarray(summarydat['sigma_spec_ang_rf']) - np.asarray(summarydat['sigma_temp_ang_rf'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '$\sigma_\\textrm{rest}$ mock spec'
    ylabel   = '$\Delta\sigma_\\textrm{rest}$; mock spec - temp match [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_sigma_vs_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = np.asarray(summarydat['sigma_spec_ang_rf'])
    yvalues  = (np.asarray(summarydat['sigma_temp_ang_rf'])/np.asarray(summarydat['sigma_spec_ang_rf'])) -1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '$\sigma_\\textrm{rest}$ mock spec'
    ylabel   = '($\sigma_\\textrm{rest}$ temp match / $\sigma_\\textrm{rest}$ mock spec) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',
                                                   colortype='s2n',cdatvec = summarydat['lineS2N_rf'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'dz_vs_specno'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = specnumber
    yvalues  = np.asarray(summarydat['z_spec'])-np.asarray(summarydat['z_temp_S2Nmax'])
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
    ylabel   = '$\Delta z$; mock spec - temp match'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='horizontal',colortype='redshift',cdatvec = summarydat['z_spec'],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    #-------------------------------------------------------------------------------------------------------------------
    #-------------------------------------------------------------------------------------------------------------------
    goodFratio = np.where(summarydat['Fratio_spec'] > 0)
    if len(goodFratio[0]) > 0:
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'FluxRatio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])
        yvalues  = np.asarray(summarydat['Fratio_temp'][goodFratio])
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Flux ratio mock spectrum doublet lines'
        ylabel   = 'Flux ratio best-fit template doublet lines'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='onetoone',
                                                       colortype='s2n',cdatvec = summarydat['lineS2N_rf'][goodFratio],
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'dFluxRatio_vs_specno'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = specnumber[goodFratio]
        yvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])-np.asarray(summarydat['Fratio_temp'][goodFratio])
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
        ylabel   = '$\Delta$Flux ratio; mock spec- temp match'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'dFluxRatio_vs_Fluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])
        yvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])-np.asarray(summarydat['Fratio_temp'][goodFratio])
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Flux ratio mock spec'
        ylabel   = '$\Delta$Flux ratio; mock spec - temp match'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_Fluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = np.asarray(summarydat['Fratio_spec'][goodFratio])
        yvalues  = (np.asarray(summarydat['Fratio_temp'][goodFratio])/np.asarray(summarydat['Fratio_spec'][goodFratio])) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Flux ratio mock spec '
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_specno'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = specnumber[goodFratio]
        yvalues  = (np.asarray(summarydat['Fratio_temp'][goodFratio])/np.asarray(summarydat['Fratio_spec'][goodFratio])) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_specno'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = specnumber[goodFratio]
        yvalues  = (np.asarray(summarydat['Fratio_temp'][goodFratio])/np.asarray(summarydat['Fratio_spec'][goodFratio])) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Spectrum number - according to summary file \n'+summaryfile.split('/')[-1].replace('_','\_')
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_lineS2N'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['lineS2N_rf'][goodFratio]
        yvalues  = (summarydat['Fratio_temp'][goodFratio]/summarydat['Fratio_spec'][goodFratio]) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = 'Line S/N'
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]
        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='horizontal',colortype='Sigma',
                                                       cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_FluxRatio_vs_Ratio_sigma'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = (summarydat['sigma_temp_ang_rf'][goodFratio]/summarydat['sigma_spec_ang_rf'][goodFratio]) -1.0
        yvalues  = (summarydat['Fratio_temp'][goodFratio]/summarydat['Fratio_spec'][goodFratio]) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = '($\sigma_\\textrm{rest}$ temp match / $\sigma_\\textrm{rest}$ mock spec) - 1'
        ylabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        cdatvec  = summarydat['lineS2N_rf'][goodFratio]
        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='plus',
                                                       colortype='s2n',cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)


        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'Ratio_Ftot_vs_Ratio_FluxRatio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = (summarydat['Fratio_temp'][goodFratio]/summarydat['Fratio_spec'][goodFratio]) - 1.0
        yvalues  = (summarydat['Ftot_temp_sum'][goodFratio]/summarydat['Ftot_spec_intr'][goodFratio]) - 1.0
        xerr     = [None]*len(xvalues)
        yerr     = [None]*len(xvalues)
        xlabel   = '(Flux ratio temp match / Flux ratio mock spec) - 1'
        ylabel   = '(Ftot temp match / Ftot mock spec) - 1 '
        cdatvec  = summarydat['sigma_spec_ang_rf'][goodFratio]
        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       linetype='plus',colortype='Sigma',
                                                       cdatvec=cdatvec,
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'Ratio_Ftot_vs_Ratio_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = (summarydat['sigma_temp_ang_rf']/summarydat['sigma_spec_ang_rf']) - 1.0
    yvalues  = (summarydat['Ftot_temp_sum']/summarydat['Ftot_spec_intr']) - 1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '($\sigma_\\textrm{rest}$ temp match / $\sigma_\\textrm{rest}$ mock spec) - 1'
    ylabel   = '(Ftot temp match / Ftot mock spec) - 1 '
    cdatvec  = summarydat['lineS2N_rf']
    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   linetype='plus',colortype='s2n',
                                                   cdatvec=cdatvec,
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def match_mockspectra_to_templates(outputdir,CCwavewindow=25.0,plot_allCCresults=False,noisefree=False,
                                   spec2match='all',verbose=True):
    """
    Wrapper around match_mockspectrum_to_templates() to match templates to all mockspectra.


    --- INPUT ---
    outputdir          Directory to store picklefiles with cross-correlation results to
    CCwavewindow       Window around line to perform cross-correlations over (rest frame)
    plot_allCCresults  To plot all CC results set this to True. Plots will be stored in outputdir
    noisefree          To matcht the noise-free version of the mock spectra set to True
    spec2match         To only match a a subsample of spectra provide their parameter tabel line index here
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    outputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults/'
    uves.match_mockspectra_to_templates(outputdir)

    """
    if verbose: print(' - Decide which templates to fit to what mock spectra (through a dictionary)')
    mockVStemp_lines = {}
    mockVStemp_lines['Lya']             = ['Lya']
    mockVStemp_lines['CIIIdoublet']     = ['CIII']
    mockVStemp_lines['CIVdoublet']      = ['CIV']
    mockVStemp_lines['NVdoublet']       = ['NV']
    mockVStemp_lines['HeII']            = ['HeII']
    mockVStemp_lines['OIII1663doublet'] = ['OIII']
    mockVStemp_lines['MgIIdoublet']     = ['MgII']

    mockVStemp_lines['testsinglet'] = ['HeII']
    mockVStemp_lines['testdoublet'] = ['CIII']

    waverest     = {'Lya':1215.67, 'CIII':1908.0, 'CIV':1550.0, 'NV':1241.0, 'HeII':1640.0, 'OIII':1663.0, 'MgII':2800.}

    if verbose: print(' - Defining files to perform matches between (hardcoded)')
    parentdir    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/'
    # templatedir  = parentdir+'felis_templates_190816/'
    templatedir  = parentdir+'felis_templates_fromsetup/'
    paramfile    = parentdir+'mockspectra_setup_parametertable.txt'
    paramtable   = np.genfromtxt(paramfile,names=True,comments='#',skip_header=3,dtype='d,d,d,d,d,d,d,20a,20a,200a')

    if verbose: print(' - Crosscorrelating templates to spectra using FELIS')
    for ss, mockspec in enumerate(paramtable['specname']):
        if spec2match != 'all':
            if ss not in spec2match:
                continue
            else:
                print('------ spec2match: following spectrum in list so matching:')
                print('                   '+mockspec)

        if noisefree:
            mockspec = mockspec.replace('noisespec','noisestdNone')
        mockline  = mockspec.split('fromsetup_')[-1].split('_')[0]
        templines = mockVStemp_lines[mockline]

        for templine in templines:
            picklefile = outputdir+mockspec.split('/')[-1].replace('.fits',
                                                                   '_CCresults_template'+templine+
                                                                   '_matchto_spectrum'+mockline+'.pkl')
            templates  = glob.glob(templatedir+'uves_felis_template_*'+templine+'*.fits')

            if not plot_allCCresults:
                plotdir  = None

            windowcen  = CCwavewindow * (1+paramtable['redshift'][ss])
            ccdic      = felis.match_templates2specs(templates,[mockspec],[paramtable['redshift'][ss]],
                                                     picklefile,wavewindow=[windowcen],
                                                     plotdir=outputdir,wavecen_restframe=[waverest[templine]],
                                                     vshift=None,min_template_level=1e-4,
                                                     plot_allCCresults=plot_allCCresults,
                                                     subtract_spec_median=False)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_mocspecFELISresults_summary(summaryfile,picklefiles,overwrite=False,verbose=True):
    """
    Generate a summary of the template characteristics FELIS determined to match the mock spectra
    the best, i.e. with the highest S/N.

    --- INPUT ---
    summaryfile        Path and name to summary file to generate.
    picklefiles        List of FELIS pickle files to summarize.
    overwrite          Overwrite the summary file if it already exists?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    FELISoutputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults/'
    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_all.txt'
    picklefiles    = glob.glob(FELISoutputdir+'*.pkl')
    summarydat     = uves.gen_mocspecFELISresults_summary(summaryfile,picklefiles)

    """
    if verbose: print(' - Generating a summary of the best-fit template in:\n   '+summaryfile)
    if os.path.isfile(summaryfile) & (not overwrite):
        sys.exit(' Summary file '+summaryfile+' already exists and overwrite=False ')

    fout = open(summaryfile,'w')
    fout.write('# Summary of '+str(len(picklefiles))+' FELIS pickle files provided \n')
    fout.write('# File contains the characteristics of the templates with max S/N from the FELIS template fits \n')
    fout.write('# The summary was generated with uves.compate_mockspec_to_FELISresults() on '+kbs.DandTstr2()+' \n')
    fout.write('# \n')
    fout.write('# Columns are:\n')
    fout.write('# z_spec                     Instrinspic redshift of matched mock spectrum \n')
    fout.write('# z_temp_S2Nmax              Estimated redshift from template match\n')
    fout.write('# sigma_spec_ang_obs         Observed line width in angstroms for mock spectrum \n')
    fout.write('# sigma_spec_ang_rf          Rest-frame line width in angstroms for mock spectrum \n')
    fout.write('# sigma_temp_ang_rf          Rest-frame line width in angstroms for maxS/N template \n')
    fout.write('# Fratio_spec                Flux ratio of doublets in mock spectrum (line_lowwave/line_highwave) \n')
    fout.write('# Fratio_temp                Flux ratio of doublets in template      (line_lowwave/line_highwave) \n')
    fout.write('# Ftot_spec_intr             Intrinsic (input) total flux of mock spectrum \n')
    fout.write('# Ftot_spec_trapz            Integreated (trapz) total flux of noisy mock spectrum \n')
    fout.write('# Ftot_spec_trapz_err        Uncertainty on Ftot_spec_trapz (mock spectrum flux errors propogated) \n')
    fout.write('# Ftot_spec_sum              Integreated (sum*dwave) total flux of noisy mock spectrum \n')
    fout.write('# Ftot_spec_sum_err          Integreated (sum*dwave) total flux of noisy mock spectrum \n')
    fout.write('# Ftot_FELIS_S2Nmax          Estimated total flux from FELIS template match for maxS/N match \n')
    fout.write('# Ftot_FELIS_S2Nmax_err      Uncertainty on FELISflux_S2Nmax [sqrt(Ftot_FELIS_S2Nmax_variance)]\n')
    fout.write('# FELIS_S2Nmax               The S/N value of the (scaled) template match to the mock spectrum \n')
    fout.write('# Ngoodent                   The number of good pixels used in the cross correlation \n')
    fout.write('# chi2                       Chi^2 value between the mock spectrum and the template match \n')
    fout.write('# vshift_spec                Known intrinsic velocity shift of mock spectrum \n')
    fout.write('# vshift_CCmatch             Estimated velocity shift from template match '
               ' [ c*(z_spec-z_temp_S2Nmax)/(1+z_temp_S2Nmax) ]\n')
    fout.write('# lineS2N                    Estimated S/N of spectral feature within [lineS2Nwavemin,lineS2Nwavemin] \n')
    fout.write('# lineS2Nwavemin             Lower integration limit for S/N estimate \n')
    fout.write('# lineS2Nwavemax             Upper integration limit for S/N estimate \n')
    fout.write('# lineS2N_rf                 Estimated S/N (rest-frame) of spectral feature within [lineS2Nwavemin_rf,lineS2Nwavemin_rf] \n')
    fout.write('# lineS2Nwavemin_rf          Lower integration limit for rest-frame S/N estimate \n')
    fout.write('# lineS2Nwavemax_rf          Upper integration limit for rest-frame S/N estimate \n')
    fout.write('# Ftot_lineS2N               Total flux of spectral feature (sum(f)*dwave) used to estimate line S/N \n')
    fout.write('# Ftot_lineS2N_sigma         Square root of the variance/sqrt(Npix) of Ftot \n')
    fout.write('# spectrum                   The mock spectrum the templates were matched to \n')
    fout.write('# template                   The maxS/N template \n')
    fout.write('# \n')
    fout.write('# z_spec z_temp_S2Nmax sigma_spec_ang_obs sigma_spec_ang_rf sigma_temp_ang_rf Fratio_spec Fratio_temp Ftot_spec_intr Ftot_spec_trapz Ftot_spec_trapz_err Ftot_spec_sum Ftot_spec_sum_err Ftot_FELIS_S2Nmax Ftot_FELIS_S2Nmax_err FELIS_S2Nmax Ngoodent chi2 vshift_spec vshift_CCmatch lineS2N lineS2Nwavemin lineS2Nwavemax lineS2N_rf lineS2Nwavemin_rf lineS2Nwavemax_rf Ftot_lineS2N Ftot_lineS2N_sigma spectrum template \n')

    for pp, picklefile in enumerate(picklefiles):
        if verbose:
            infostr = ' - Summarizing picklefile  '+str("%.5d" % (pp+1))+' / '+str("%.5d" % len(picklefiles))+'     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        pkldic  = felis.load_picklefile(picklefile)

        Nsigma_integration = 3.0

        for specname in pkldic.keys():
            tempdic = pkldic[specname]

            #------ load info about max S/N template ------
            template, vshift_intr, vshift_match, Ftot_FELIS_S2Nmax, Ftot_FELIS_S2Nmax_err, \
            FELIS_S2Nmax, Ngoodent, chi2, z_spec, zS2Nmax =  \
                felis.getresult4maxS2N(pkldic,specname)

            #------ load matched spec and move to restframe ------
            s_wave   , s_flux   , s_df   , s_s2n    = felis.load_spectrum(specname,verbose=False)
            s_wave_rf, s_flux_rf, s_df_rf, s_s2n_rf = s_wave / (1+z_spec), s_flux * (1+z_spec), s_df * (1+z_spec), s_s2n

            #------ extract info on mock spectrum from fits headers ------
            spec_hdr        = afits.open(specname)[1].header
            spec_sigma_ang  = np.array([])
            spec_flux       = np.array([])
            spec_line_wave  = np.array([])
            for hdrkey in spec_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: spec_line_wave = np.append(spec_line_wave,spec_hdr[hdrkey])
                    if '_2' in hdrkey: spec_sigma_ang = np.append(spec_sigma_ang,spec_hdr[hdrkey])
                    if '_4' in hdrkey: spec_flux      = np.append(spec_flux,spec_hdr[hdrkey])

            spec_sigma_ang_obs = np.mean(spec_sigma_ang)
            spec_sigma_ang_rf  = spec_sigma_ang_obs / (1.0+z_spec)
            Ftot_spec_intr     = np.sum(spec_flux)
            if len(spec_flux) == 2:
                Fratio_spec = spec_flux[np.where(spec_line_wave == np.min(spec_line_wave))] / \
                              spec_flux[np.where(spec_line_wave == np.max(spec_line_wave))]
            else:
                Fratio_spec = 0.0

            #------ extract info on template from fits headers ------
            temp_hdr        = afits.open(template)[1].header
            temp_sigma_ang  = np.array([])
            temp_flux       = np.array([])
            temp_line_wave  = np.array([])
            for hdrkey in temp_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: temp_line_wave = np.append(temp_line_wave,temp_hdr[hdrkey])
                    if '_2' in hdrkey: temp_sigma_ang = np.append(temp_sigma_ang,temp_hdr[hdrkey])
                    if '_4' in hdrkey: temp_flux      = np.append(temp_flux,temp_hdr[hdrkey])

            temp_sigma_ang_rf  = np.mean(temp_sigma_ang)
            if len(temp_flux) == 2:
                Fratio_temp = temp_flux[np.where(temp_line_wave == np.min(temp_line_wave))] / \
                              temp_flux[np.where(temp_line_wave == np.max(temp_line_wave))]
            else:
                Fratio_temp = 0.0

            #------ integrate mock spectrum to obtain observed total fluxes (rest-frame) ------
            lineS2Nwavemin = np.min(spec_line_wave)-Nsigma_integration*spec_sigma_ang_obs
            lineS2Nwavemax = np.max(spec_line_wave)+Nsigma_integration*spec_sigma_ang_obs
            waverange      = [lineS2Nwavemin,lineS2Nwavemax]
            goodent        = np.where((s_wave >= waverange[0]) & (s_wave <= waverange[1]))

            lineS2Nwavemin_rf = np.min(spec_line_wave/(1.0+z_spec))-Nsigma_integration*spec_sigma_ang_rf
            lineS2Nwavemax_rf = np.max(spec_line_wave/(1.0+z_spec))+Nsigma_integration*spec_sigma_ang_rf
            waverange_rf      = [lineS2Nwavemin_rf,lineS2Nwavemax_rf]
            goodent_rf        = np.where((s_wave_rf >= waverange_rf[0]) & (s_wave_rf <= waverange_rf[1]))

            datarr_spec       = unumpy.uarray(s_flux_rf[goodent_rf], s_df_rf[goodent_rf])
            Ftot_trapz_spec   = np.trapz(datarr_spec,s_wave_rf[goodent_rf])
            Ftot_sum_spec     = np.sum(datarr_spec) * np.median(np.diff(s_wave_rf[goodent_rf]))

            #------ estimate signal to noise of emission feature ------
            Ftot_lineS2N, Ftot_lineS2N_var, Npixgood, lineS2N = uves.calc_1Dspec_S2N(s_wave,s_flux,s_df**2.0,
                                                                   waverange,verbose=False)
            Ftot_lineS2N_sigma = np.sqrt(Ftot_lineS2N_var)

            Ftot_rf, vartot_rf, Npixgood_rf, lineS2N_rf = uves.calc_1Dspec_S2N(s_wave_rf,s_flux_rf,s_df_rf**2.0,
                                                                               waverange_rf,verbose=False)

            if np.abs(Ftot_lineS2N-Ftot_rf) > 1.0:
                print(' - Ftot-Ftot_rf is larger than 1e-20cgs; stopping to enable investigation')
                pdb.set_trace()

            if np.abs(lineS2N-lineS2N_rf) > 0.1:
                print(' - linsS2N-lineS2N_ref is larger than 10%; stopping to enable investigation')
                pdb.set_trace()


            #------------ Writing to output file ------------
            outstr = str("%7.4f" % z_spec)+'  '+\
                     str("%7.4f" % zS2Nmax)+'      '+\
                     str("%7.4f" % spec_sigma_ang_obs)+'  '+\
                     str("%7.4f" % spec_sigma_ang_rf)+'  '+\
                     str("%7.4f" % temp_sigma_ang_rf)+'      '+\
                     str("%7.2f" % Fratio_spec)+'  '+\
                     str("%7.2f" % Fratio_temp)+'      '+\
                     str("%12.4f" % Ftot_spec_intr)+'  '+\
                     str("%12.4f" % Ftot_trapz_spec.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_trapz_spec.std_dev)+'  '+\
                     str("%12.4f" % Ftot_sum_spec.nominal_value)+'  '+\
                     str("%12.4f" % Ftot_sum_spec.std_dev)+'  '+\
                     str("%12.4f" % Ftot_FELIS_S2Nmax)+'  '+\
                     str("%12.4f" % Ftot_FELIS_S2Nmax_err)+'  '+\
                     str("%12.4f" % FELIS_S2Nmax)+'  '+\
                     str("%12.4f" % Ngoodent)+'  '+\
                     str("%12.4f" % chi2)+'  '+\
                     str("%12.4f" % vshift_intr)+'  '+\
                     str("%12.4f" % vshift_match)+'      '+\
                     str("%12.4f" % lineS2N)+'  '+\
                     str("%12.4f" % lineS2Nwavemin)+'  '+\
                     str("%12.4f" % lineS2Nwavemax)+'  '+\
                     str("%12.4f" % lineS2N_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemin_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemax_rf)+'  '+\
                     str("%12.4f" % Ftot_lineS2N)+'  '+\
                     str("%12.4f" % Ftot_lineS2N_sigma)+'  '+\
                     specname+'  '+\
                     template+'  '
            fout.write(outstr+'\n')
    if verbose: print('\n   ...done')
    fout.close()

    fmt = 'd,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=34,dtype=fmt,comments='#',names=True)
    return summarydat

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_mocspecFELISresults_summary(summaryfile,plotbasename,colortype='lineS2N_rf',histaxes=False,Nbins=50,
                                     overwrite=False,verbose=True):
    """
    plotting and evaluating the output from uves.gen_mocspecFELISresults_summary()

    --- INPUT ---
    summaryfile        Path and name to summary file to evaluate
    plotbasename       The based name for the plots to generate (incl. output directory)
    overwrite          Overwrite the plots if they already exist?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary.txt'
    plotbasename   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_plots/190815test_'
    uves.plot_mocspecFELISresults_summary(summaryfile,plotbasename)

    """
    if verbose: print(' - Loading and plotting the content of \n   '+summaryfile)
    fmt = 'd,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=34,dtype=fmt,comments='#',names=True)
    specnumber = np.arange(len(summarydat))+1.0


    line         = summaryfile.split('cgs_')[-1].split('19')[0].lower()

    sigmaerrval  = {'ciii':0.1, 'civ':0.1, 'siiii':0.1, 'nv':0.1, 'mgii':0.1, 'oiii':0.1, 'heii':0.1, 'lya':0.3, 'all':0.1}
    fratioerrval = {'ciii':0.1, 'civ':0.2, 'siiii':0.1, 'nv':0.2, 'mgii':0.2, 'oiii':0.1, 'all':0.2}


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_z_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['z_spec']
    yvalues  = summarydat['z_temp_S2Nmax']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '$z$(mock spectrum)'
    ylabel   = '$z$(FELIS)'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[.1,600],yrange=[.1,600],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_S2N_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['lineS2N_rf']
    yvalues  = summarydat['FELIS_S2Nmax']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Rest-frame emission line S/N'
    ylabel   = 'FELIS template match S/N'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='Ftot_spec_intr',cdatvec=summarydat['Ftot_spec_intr'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[.1,600],yrange=[.1,600],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVStrapz'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_spec_trapz']
    yerr     = summarydat['Ftot_spec_trapz_err']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'Trapz int mock spectrum line flux [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVStrapz_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_spec_trapz']
    yerr     = summarydat['Ftot_spec_trapz_err']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'Trapz int mock spectrum line flux [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=summarydat['sigma_spec_ang_rf'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVSsum'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_spec_sum']
    yerr     = summarydat['Ftot_spec_sum_err']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'Sum*dwave mock spectrum line flux [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVSline'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_lineS2N']
    yerr     = summarydat['Ftot_lineS2N_sigma']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'Trapz int +/- 3 sigma mock spectrum line flux [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_intrVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['Ftot_FELIS_S2Nmax']
    yerr     = summarydat['Ftot_FELIS_S2Nmax_err']
    xlabel   = 'Intrinsic mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'FELIS line flux estimate [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_trapzVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_trapz']
    xerr     = summarydat['Ftot_spec_trapz_err']
    yvalues  = summarydat['Ftot_FELIS_S2Nmax']
    yerr     = summarydat['Ftot_FELIS_S2Nmax_err']

    xlabel   = 'Trapz int mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'FELIS line flux estimate [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_trapzVSfelis_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_trapz']
    xerr     = summarydat['Ftot_spec_trapz_err']
    yvalues  = summarydat['Ftot_FELIS_S2Nmax']
    yerr     = summarydat['Ftot_FELIS_S2Nmax_err']

    xlabel   = 'Trapz int mock spectrum line flux [1e-20erg/s/cm$^2$]'
    ylabel   = 'FELIS line flux estimate [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=summarydat['sigma_spec_ang_rf'],
                                                   linetype='onetoone',
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_sigma_intrVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['sigma_spec_ang_rf']
    xerr     = [None]*len(xvalues)
    yvalues  = summarydat['sigma_temp_ang_rf']
    yerr     = [None]*len(yvalues)

    xlabel   = '$\sigma$(mock spectrum) [\AA]'
    ylabel   = '$\sigma$(FELIS) [\AA]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='onetoone',
                                                   xlog=False,ylog=False,xrange=[0.0,2.7],yrange=[0.0,2.7],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_FtotVSFtot'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    yvalues  = summarydat['Ftot_spec_trapz']/summarydat['Ftot_FELIS_S2Nmax']-1.0
    xerr     = [None]*len(xvalues)
    yerr     = np.sqrt( (summarydat['Ftot_spec_trapz_err']   / summarydat['Ftot_spec_trapz'])**2 +
                        (summarydat['Ftot_FELIS_S2Nmax_err'] / summarydat['Ftot_FELIS_S2Nmax'])**2 ) * np.abs(yvalues)
    xlabel   = 'F(Intrinsic) [1e-20erg/s/cm$^2$]'
    ylabel   = 'F(mock spectrum)/F(FELIS) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_FtotVSFtot_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['Ftot_spec_intr']
    yvalues  = summarydat['Ftot_spec_trapz']/summarydat['Ftot_FELIS_S2Nmax']-1.0
    xerr     = [None]*len(xvalues)
    yerr     = np.sqrt( (summarydat['Ftot_spec_trapz_err']   / summarydat['Ftot_spec_trapz'])**2 +
                        (summarydat['Ftot_FELIS_S2Nmax_err'] / summarydat['Ftot_FELIS_S2Nmax'])**2 ) * np.abs(yvalues)
    xlabel   = 'F(Intrinsic) [1e-20erg/s/cm$^2$]'
    ylabel   = 'F(mock spectrum)/F(FELIS) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=summarydat['sigma_spec_ang_rf'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_sigmaVSsigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['sigma_spec_ang_rf']
    yvalues  = summarydat['sigma_spec_ang_rf']/summarydat['sigma_temp_ang_rf']-1.0
    xerr     = [None]*len(xvalues)
    yerr     = np.sqrt( (summarydat['sigma_temp_ang_rf']*0.0+sigmaerrval[line] / summarydat['sigma_temp_ang_rf'])**2 +
                        (summarydat['sigma_spec_ang_rf']*0.0+0.0 / summarydat['sigma_spec_ang_rf'])**2 ) * np.abs(yvalues)

    xlabel   = '$\sigma$(mock spectrum) [\AA]'
    ylabel   = '$\sigma$(mock spectrum)/$\sigma$(FELIS) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)


    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_zVSz'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['z_spec']
    yvalues  = summarydat['z_spec']/summarydat['z_temp_S2Nmax']-1.0
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)

    xlabel   = '$z$(mock spectrum)'
    ylabel   = '$z$(mock spectrum)/$z$(FELIS) - 1'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_zVSvshift'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = summarydat['z_spec']
    yvalues  = summarydat['vshift_CCmatch']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)

    xlabel   = '$z$(mock spectrum)'
    ylabel   = '$\Delta v$/[km/s] = $c$[$z$(mock spectrum) - $z$(FELIS)] / [1+ $z$(FELIS)]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    #-------------------------------------------------------------------------------------------------------------------
    #-------------------------------------------------------------------------------------------------------------------
    goodFratio = np.where(summarydat['Fratio_spec'] > 0)
    if len(goodFratio[0]) > 0:
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'onetoone_Fratio_intrVSfelis'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['Fratio_spec'][goodFratio]
        xerr     = [None]*len(xvalues)
        yvalues  = summarydat['Fratio_temp'][goodFratio]
        yerr     = [fratioerrval[line]]*len(yvalues)

        xlabel   = 'Doublet flux ratio mock spec'
        ylabel   = 'Doublet flux ratio FELIS match'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='onetoone',
                                                       xlog=False,ylog=False,xrange=[0.0,3.3],yrange=[0.0,3.3],
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'horizontal_fluxratioVSfluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['Fratio_spec'][goodFratio]
        yvalues  = summarydat['Fratio_spec'][goodFratio]/summarydat['Fratio_temp'][goodFratio]-1.0
        xerr     = [None]*len(xvalues)
        yerr     = np.sqrt( (summarydat['Fratio_temp'][goodFratio]*0.0+fratioerrval[line] / summarydat['Fratio_temp'][goodFratio])**2 +
                            (summarydat['Fratio_spec'][goodFratio]*0.0+0.0 / summarydat['Fratio_spec'][goodFratio])**2 ) * np.abs(yvalues)

        xlabel   = 'Doublet flux ratio (FR) of mock spectrum'
        ylabel   = 'FR(mock spectrum)/FR(FELIS) - 1'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='horizontal',
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'horizontal_sigmaVSfluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['sigma_spec_ang_rf'][goodFratio]
        yvalues  = summarydat['Fratio_spec'][goodFratio]/summarydat['Fratio_temp'][goodFratio]-1.0
        xerr     = [None]*len(xvalues)
        yerr     = np.sqrt( (summarydat['Fratio_temp'][goodFratio]*0.0+fratioerrval[line] / summarydat['Fratio_temp'][goodFratio])**2 +
                            (summarydat['Fratio_spec'][goodFratio]*0.0+0.0 / summarydat['Fratio_spec'][goodFratio])**2 ) * np.abs(yvalues)

        xlabel   = '$\sigma$(mock spectrum) [\AA]'
        ylabel   = 'FR(mock spectrum)/FR(FELIS) - 1'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='horizontal',
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'horizontal_sigmafelisVSfluxratio'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = summarydat['sigma_temp_ang_rf'][goodFratio]
        yvalues  = summarydat['Fratio_spec'][goodFratio]/summarydat['Fratio_temp'][goodFratio]-1.0
        xerr     = [None]*len(xvalues)
        yerr     = np.sqrt( (summarydat['Fratio_temp'][goodFratio]*0.0+fratioerrval[line] / summarydat['Fratio_temp'][goodFratio])**2 +
                            (summarydat['Fratio_spec'][goodFratio]*0.0+0.0 / summarydat['Fratio_spec'][goodFratio])**2 ) * np.abs(yvalues)

        xlabel   = '$\sigma$(FELIS) [\AA]'
        ylabel   = 'FR(mock spectrum)/FR(FELIS) - 1'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='horizontal',
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                              yrange=None,xrange=None,linetype='onetoone',ylog=False,xlog=False,
                                              colortype=None,colorcode=True,cdatvec=None,point_text=None,ids=None,
                                              overwrite=False,verbose=True,title=None,
                                              photoionizationplotparam=None,
                                              histaxes=False,Nbins=50):
    """

    """
    if verbose: print(' - Setting up and generating plot')
    if os.path.isfile(plotname) & (not overwrite):
        if verbose: print('\n - WARNING: the plot '+plotname+' exists and overwrite=False so moving on \n')
    else:
        if histaxes:
            fig = plt.figure(1, figsize=(6, 6))
            # partially based on https://matplotlib.org/examples/pylab_examples/scatter_hist.html
            # definitions for the axes
            left, width = 0.15, 0.60
            bottom, height = 0.15, 0.60
            bottom_h = left_h = left + width + 0.01

            fig.subplots_adjust(wspace=0.1, hspace=0.1,left=left, right=left+width, bottom=bottom, top=bottom+height)
            rect_histx = [left, bottom_h, width, 0.2]
            rect_histy = [left_h, bottom, 0.2, height]
        else:
            fig = plt.figure(2, figsize=(6, 5))
            fig.subplots_adjust(wspace=0.1, hspace=0.1,left=0.15, right=0.97, bottom=0.15, top=0.95)

        Fsize    = 14
        lthick   = 2
        marksize = 6
        plt.rc('text', usetex=True)
        plt.rc('font', family='serif',size=Fsize)
        plt.rc('xtick', labelsize=Fsize)
        plt.rc('ytick', labelsize=Fsize)
        plt.clf()
        plt.ioff()

        if colorcode:
            cmap    = plt.cm.get_cmap('viridis_r') # 'autumn_r'

            if cdatvec is None:
                cdatvec = summarydat[colortype]

            if colortype.lower() == 'redshift':
                clabel  = '$z$'
                cmin    = 0.5 # 0.0, 1.4
                cmax    = 7.5 # 10.2, 6.2
                cextend = 'neither'
            elif colortype.lower() == 's2nfelis':
                clabel  = 'S/N(FELIS)'
                cmin    = 3.0
                cmax    = 10.0
                cextend = 'both'
            elif colortype.lower() == 's2n':
                clabel  = 'S/N'
                cmin    = 3.0
                cmax    = 10.0
                cextend = 'both'
            elif colortype.lower() == 's2n_ciii':
                clabel  = 'CIII S/N(FELIS)'
                cmin    = 3.0
                cmax    = 10.0
                cextend = 'both'
            elif colortype.lower() == 'vshift':
                clabel  = 'Velocity shift (spec vs. template match) [km/s]'
                cmin    = 0.0
                cmax    = 200.0
                cextend = 'both'
            elif colortype.lower() == 'ew_0':
                clabel  = 'EW$_0$(Ly$\\alpha$) [\AA]'
                cmin    = np.min(cdatvec[np.isfinite(cdatvec)])
                cmax    = np.max(cdatvec[np.isfinite(cdatvec)])
                cextend = 'neither'
            elif colortype.lower() == 'sigma':
                clabel  = '$\sigma$ [\AA]'
                cmin    = np.min(cdatvec[np.isfinite(cdatvec)])
                cmax    = np.max(cdatvec[np.isfinite(cdatvec)])
                cextend = 'neither'
            elif colortype in summarydat.dtype.names:
                # if colortype == 'Fratio_spec': pdb.set_trace()
                clabel  = colortype.replace('_','\_')
                cmin    = np.min(cdatvec[np.isfinite(cdatvec)])
                cmax    = np.max(cdatvec[np.isfinite(cdatvec)])
                cextend = 'neither'
            else:
                sys.exit(' Color type '+colortype+' not enabled ')

            colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
            cmaparr = np.linspace(cmin, cmax, num=50)
            m       = plt.cm.ScalarMappable(cmap=cmap)
            m.set_array(cmaparr)

            if not histaxes:
                colshrink = 1.0
                colaspect = 30
                if photoionizationplotparam is None:
                    colanchor = (0.0,0.5)
                else:
                    colbarscale = 2.1
                    colanchor   = (-1.1,0.0)
                    colshrink   = colshrink/colbarscale
                    colaspect   = colaspect/colbarscale

                cb      = plt.colorbar(m,extend=cextend,orientation='vertical',
                                       pad=0.01,aspect=colaspect,shrink=colshrink,anchor=colanchor,use_gridspec=False)
                cb.set_label(clabel)

            colvec   = []
            for ii,xval in enumerate(xvalues):
                colvec.append(cmap(colnorm(cdatvec[ii])))
            facecol  = colvec
            alphaval = 1.0
        else:
            colvec   = ['k']*len(xvalues)
            facecol  = ['gray']*len(xvalues)
            alphaval = 0.5

        #--------- RANGES ---------
        if not xrange:
            xmin   = np.min(xvalues[np.isfinite(xvalues)])
            xmax   = np.max(xvalues[np.isfinite(xvalues)])
            dx     = xmax-xmin
            xrange = [xmin-dx*0.05,xmax+dx*0.05]
        plt.xlim(xrange)
        xminsys, xmaxsys = plt.xlim() # use to get automatically expanded axes if xmin = xmax

        if not yrange:
            ymin   = np.min(yvalues[np.isfinite(yvalues)])
            ymax   = np.max(yvalues[np.isfinite(yvalues)])
            dy     = ymax-ymin
            yrange = [ymin-dy*0.05,ymax+dy*0.05]
        plt.ylim(yrange)
        yminsys, ymaxsys = plt.ylim() # use to get automatically expanded axes if xmin = xmax

        #--------- X and Y limits ---------
        y_uplimarr = (np.asarray(yerr).astype(int) == +99)
        y_lolimarr = (np.asarray(yerr).astype(int) == -99)
        x_uplimarr = (np.asarray(xerr).astype(int) == +99)
        x_lolimarr = (np.asarray(xerr).astype(int) == -99)
        for ii,xval in enumerate(xvalues): # loop necessary for coloring and upper/lower limits markers
            # checking for upper/lower limits
            if ids is not None:
                if (ids[ii] < 6e8): # CDFS and COSMOS
                    markersym   = 'o'
                elif (ids[ii] < 7e8) & (ids[ii] > 6e8): # UDF
                    markersym   = 'D'
                elif (ids[ii] < 9e8) & (ids[ii] > 7e8): # UDF10
                    markersym   = 'X'
                elif (ids[ii] > 1e10): # Literature objects
                    markersym   = lce.get_reference(ids[ii],verbose=False)[4]
            else:
                markersym   = 'o'
            ms          = marksize
            limsizefrac = 0.05

            if y_uplimarr[ii]:
                if ylog:
                    dlog     = np.abs(np.diff(np.log10(plt.ylim()))) * limsizefrac
                    yerr[ii] = np.abs(yvalues[ii] - 10.**(np.log10(yvalues[ii])-dlog))
                else:
                    yerr[ii] = np.abs(np.diff(plt.ylim())) * limsizefrac
            if y_lolimarr[ii]:
                if ylog:
                    dlog     = np.abs(np.diff(np.log10(plt.ylim()))) * limsizefrac
                    yerr[ii] = np.abs(yvalues[ii] - 10.**(np.log10(yvalues[ii])+dlog))
                else:
                    yerr[ii] = np.abs(np.diff(plt.ylim())) * limsizefrac
            if x_uplimarr[ii]:
                if xlog:
                    dlog     = np.abs(np.diff(np.log10(plt.xlim()))) * limsizefrac
                    xerr[ii] = np.abs(xvalues[ii] - 10.**(np.log10(xvalues[ii])-dlog))
                else:
                    xerr[ii] = np.abs(np.diff(plt.xlim())) * limsizefrac
            if x_lolimarr[ii]:
                if xlog:
                    dlog     = np.abs(np.diff(np.log10(plt.xlim()))) * limsizefrac
                    xerr[ii] = np.abs(xvalues[ii] - 10.**(np.log10(xvalues[ii])+dlog))
                else:
                    xerr[ii] = np.abs(np.diff(plt.xlim())) * limsizefrac

            # drawLaTeXarrows = False
            # if drawLaTeXarrows:
            #     markerscale = 3.0
            #     if (int(xerr[ii]) == -99) & (int(yerr[ii]) == -99):
            #         markersym ='$\\nearrow$'
            #         ms        = marksize * markerscale
            #         xerr[ii]  = None
            #         yerr[ii]  = None
            #     elif (int(xerr[ii]) == +99) & (int(yerr[ii]) == +99):
            #         markersym ='$\swarrow$'
            #         ms        = marksize * markerscale
            #         xerr[ii]  = None
            #         yerr[ii]  = None
            #     elif (int(xerr[ii]) == -99) & (int(yerr[ii]) == +99):
            #         markersym ='$\\nwarrow$'
            #         ms        = marksize * markerscale
            #         xerr[ii]  = None
            #         yerr[ii]  = None
            #     elif (int(xerr[ii]) == +99) & (int(yerr[ii]) == -99):
            #         markersym ='$\searrow$'
            #         ms        = marksize * markerscale
            #         xerr[ii]  = None
            #         yerr[ii]  = None
            #     elif (int(xerr[ii]) == -99) & (int(yerr[ii]) not in [-99,0,+99]):
            #         markersym ='$\rightarrow$'
            #         ms        = marksize * markerscale
            #         xerr[ii]  = None
            #     elif (int(xerr[ii]) == +99) & (int(yerr[ii]) not in [-99,0,+99]):
            #         markersym ='$\leftarrow$'
            #         ms        = marksize * markerscale
            #         xerr[ii]  = None
            #     elif (int(xerr[ii]) not in [-99,0,+99]) & (int(yerr[ii]) == -99):
            #         markersym ='$\uparrow$'
            #         ms        = marksize * markerscale
            #         yerr[ii]  = None
            #     elif (int(xerr[ii]) not in [-99,0,+99]) & (int(yerr[ii]) == +99):
            #         markersym ='$\downarrow$'
            #         ms        = marksize * markerscale
            #         yerr[ii]  = None
            #     elif (int(xerr[ii]) == 0) or (int(yerr[ii]) == 0):
            #         xvalues[ii] = None
            #         yvalues[ii] = None


            plt.errorbar(xvalues[ii],yvalues[ii],xerr=xerr[ii],yerr=yerr[ii],capthick=0.5,
                         uplims=y_uplimarr[ii],lolims=y_lolimarr[ii],xuplims=x_uplimarr[ii],xlolims=x_lolimarr[ii],
                         marker=markersym,lw=lthick/2., markersize=ms,alpha=alphaval,
                         markerfacecolor=facecol[ii],ecolor=colvec[ii],
                         markeredgecolor=colvec[ii],zorder=20)

        if linetype == 'horizontal':
            plt.plot([-1e5,1e5],[0,0],'--',color='black',lw=lthick,zorder=10)
        elif linetype == 'onetoone':
            plt.plot([-1,1e5],[-1,1e5],'--',color='black',lw=lthick,zorder=10)
        elif linetype == 'plus':
            plt.plot([-1e5,1e5],[0,0],'--',color='black',lw=lthick,zorder=10)
            plt.plot([0,0],[-1e5,1e5],'--',color='black',lw=lthick,zorder=10)
        else:
            sys.exit(' Unknown value of linetype = "'+linetype+'"')

        #--------- PHOTOIONIZATION GRIDS ---------
        if photoionizationplotparam is not None:
            titleaddition = uves.add_photoionization_models_to_lineratioplot(photoionizationplotparam)

        if (title is not None) & (histaxes == False):
            plt.title(title+titleaddition,fontsize=Fsize-4)

        for ii,xval in enumerate(xvalues): # loop necessary for coloring
            if point_text is not None:
                plt.text(xvalues[ii]*1.03,yvalues[ii]*1.03,
                         point_text[ii],color='white',fontsize=Fsize*0.2,zorder=30,
                         bbox=dict(boxstyle="round",edgecolor='k',facecolor=colvec[ii],linewidth=lthick*0.2))

        plt.xlabel(xlabel)
        plt.ylabel(ylabel)

        if ylog:
            plt.yscale('log')
        if xlog:
            plt.xscale('log')

        if histaxes:
            axHistx = plt.axes(rect_histx)
            if (title is not None):
                plt.title(title+titleaddition,fontsize=Fsize-4)

            axHisty = plt.axes(rect_histy)

            axHistx.xaxis.set_major_formatter(NullFormatter())
            axHisty.yaxis.set_major_formatter(NullFormatter())

            binwidth_x = np.diff([xminsys,xmaxsys])/Nbins
            bindefs    = np.arange(xminsys, xmaxsys+binwidth_x, binwidth_x)
            if xlog:
                bindefs = np.logspace(np.log10(bindefs[0]),np.log10(bindefs[-1]),len(bindefs))
                axHistx.set_xscale('log')

            axHistx.hist(xvalues, bins=bindefs,histtype='step',color='k')
            axHistx.set_xticks([])
            axHistx.set_xlim([xminsys,xmaxsys])

            binwidth_y = np.diff([yminsys,ymaxsys])/Nbins
            bindefs    = np.arange(yminsys, ymaxsys+binwidth_y, binwidth_y)
            if ylog:
                bindefs = np.logspace(np.log10(bindefs[0]),np.log10(bindefs[-1]),len(bindefs))
                axHisty.set_yscale('log')

            axHisty.hist(yvalues, bins=bindefs,histtype='step',color='k', orientation='horizontal')
            axHisty.set_yticks([])
            axHisty.set_ylim([yminsys,ymaxsys])

            if colorcode:
                cb      = plt.colorbar(m,extend=cextend,orientation='vertical',
                                       pad=0.01,aspect=10,shrink=0.35,anchor=(-15.0,1.58),use_gridspec=False)
                cb.set_label(clabel)
        else:
            pass

        #--------- LEGEND ---------
        # plt.errorbar(-5000,-5000,xerr=None,yerr=1,marker='o',lw=0, markersize=marksize,alpha=1.0,
        #              markerfacecolor='k',ecolor='k',markeredgecolor='black',zorder=1,label='MUSE-Wide LAE')
        # plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='*',lw=0, markersize=marksize*2,alpha=1.0,
        #              markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN')
        # plt.errorbar(-5000,-5000,xerr=None,yerr=None,marker='D',lw=0, markersize=marksize,alpha=1.0,
        #              markerfacecolor='None',ecolor='None',markeredgecolor='black',zorder=1,label='AGN candidate')
        #
        # leg = plt.legend(fancybox=True, loc='upper center',prop={'size':Fsize/1.0},ncol=5,numpoints=1,
        #                  bbox_to_anchor=(0.5, 1.1),)  # add the legend
        # leg.get_frame().set_alpha(0.7)
        #--------------------------

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def add_photoionization_models_to_lineratioplot(piplotparam,verbose=True):
    """
    Wrapper to add NEOGAL photoionization model grids to flux ratio plots generated with
    uves.plot_mocspecFELISresults_summary_plotcmds() - see e.g. uves.plot_lineratios_fromsummaryfiles_wrapper()

    plotting based on rxj2248_BooneBalestraSource.plot_feltregutkinmodels()
    which is based on NEOGALmodels.plot_lineratios()

    --- INPUT ---
    piplotparam            The photoionization plot parameters.

    --- EXAMPLE OF RUN ---

    """
    modeldataSF  = nm.load_model('combined',filepath='/Users/kschmidt/work/catalogs/NEOGALlines/nebular_emission/')
    modeldataAGN = nm.load_model('combined',filepath='/Users/kschmidt/work/catalogs/NEOGALlines/AGN_NLR_nebular_feltre16/')

    varyparam, cutSFmodels, markersize, SFmarker, AGNmarker, linestrings, doubletratios, histaxes = piplotparam
    # varyparam options: 'Zgas','logUs','xid','nh','COratio','Mcutoff'
    logcolors = ['Zgas']

    if cutSFmodels:
        if verbose: print(' - Performing cut on model SF model grid')
        xid     = 'dummy'
        nh      = 'dummy'
        COratio = 1.00
        Mcutoff = 100
    else:
        if verbose: print(' - Showing all SF model grids, i.e., setting xid, nh, COratio and Mcutoff to dummy values')
        xid     = 'dummy'
        nh      = 'dummy'
        COratio = 'dummy'
        Mcutoff = 'dummy'

    # - - - - - - - - - - - - - - - - - - - - - - - -
    legenddic = {}
    legenddic['Zgas']     = r'Z$_\textrm{gas}$'
    legenddic['logUs']    = r'log U'
    legenddic['xid']      = r'$\xi_\textrm{d}$'
    legenddic['nh']       = r'n$_\textrm{H}$  [cm$^3$]'
    legenddic['COCOsol']  = r'C/O / [C/O]$_\odot$'
    legenddic['mup']      = r'M$_\textrm{cut IMF}$ / [M$_\odot]$'
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if cutSFmodels:
        goodentSF  = np.where( (modeldataSF['mup'] == Mcutoff) &
                                #(modeldata['xid'] == xid) &
                                #(modeldata['nh'] == nh) &
                                (modeldataSF['COCOsol'] == COratio) )[0]
        modeldataSF  = modeldataSF[goodentSF]
        infostrSFcut = '(Mcutoff(SF)='+str(Mcutoff)+', COratio(SF)='+str(COratio)+') '#+\
                       #' Showing Zgas=all, zid=all, nh=all, logU=all '
    else:
        infostrSFcut = ''
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    NgoodentSF  = len(modeldataSF)

    if NgoodentSF > 1:
        if verbose: print(' - Getting data for '+str(NgoodentSF)+' data points satisfying (SFR)model selection ')
        varydatSF  = modeldataSF[varyparam]
        if varyparam in logcolors:
            varydatSF  = np.log10(modeldataSF[varyparam])

        linedataSF = []
        for ll, linestr in enumerate(linestrings):
            if linestr == 'CIV1550':
                linedataSF.append(modeldataSF['CIV1548']+modeldataSF['CIV1551'])
            elif linestr == 'CIII1907':
                linedataSF.append(modeldataSF['CIII1908']/(1.+1./doubletratios[ll]))
            elif linestr == 'CIII1910':
                ciii1907 = modeldataSF['CIII1908']/(1.+1./doubletratios[ll])
                linedataSF.append(ciii1907/doubletratios[ll])
            elif linestr == 'OIII1663':
                linedataSF.append(modeldataSF['OIII1661']+modeldataSF['OIII1666'])
            elif linestr == 'SiIII1892':
                linedataSF.append(modeldataSF['SiIII1888']-modeldataSF['SiIII1883'])
            else:
                linedataSF.append(modeldataSF[linestr])

        # --------- Line Ratios ---------
        ratioSF_x   = linedataSF[0]/linedataSF[1]
        ratioSF_y   = linedataSF[2]/linedataSF[3]

    else:
        print(' WARNING: uves.add_photoionization_models_to_lineratioplot >>>'
              ' Less than 2 (SFR)model grid points to plot; no data added to plot')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    NgoodentAGN  = len(modeldataAGN)

    if NgoodentAGN > 1:
        if verbose: print(' - Getting data for '+str(NgoodentAGN)+' data points satisfying (AGN)model selection ')
        varydatAGN  = modeldataAGN[varyparam]
        if varyparam in logcolors:
            varydatAGN = np.log10(modeldataAGN[varyparam])

        linedataAGN = []
        for ll, linestr in enumerate(linestrings):
            if linestr == 'CIV1550':
                linedataAGN.append(modeldataAGN['CIV1548']+modeldataAGN['CIV1551'])
            elif linestr == 'OIII1663':
                linedataAGN.append(modeldataAGN['OIII1661']+modeldataAGN['OIII1666'])
            elif linestr == 'CIII1908':
                linedataAGN.append(modeldataAGN['CIII1907']+modeldataAGN['CIII1910'])
            elif linestr == 'SiIII1892':
                linedataAGN.append(modeldataAGN['SiIII1888']-modeldataAGN['SiIII1883'])
            else:
                linedataAGN.append(modeldataAGN[linestr])

        # --------- Line Ratios ---------
        ratioAGN_x   = linedataAGN[0]/linedataAGN[1]
        ratioAGN_y   = linedataAGN[2]/linedataAGN[3]
    else:
        print(' WARNING: uves.add_photoionization_models_to_lineratioplot >>>'
              ' Less than 2 (AGN)model grid points to plot; no data added to plot')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    edgecol  = 'None'

    cmap    = plt.cm.get_cmap('Reds') #'plasma', 'Greys' 'copper_r'
    cmin    = np.min(np.append(varydatSF,varydatAGN))
    cmax    = np.max(np.append(varydatSF,varydatAGN))
    colnorm = matplotlib.colors.Normalize(vmin=cmin,vmax=cmax)
    cmaparr = np.linspace(cmin, cmax, 30) #cmax-cmin)
    mm      = plt.cm.ScalarMappable(cmap=cmap)
    mm.set_array(cmaparr)

    cmapAGN    = plt.cm.get_cmap('Blues') # 'copper_r' 'plasma', 'Reds_r' 'spring'
    cminAGN    = np.min(np.append(varydatSF,varydatAGN))
    cmaxAGN    = np.max(np.append(varydatSF,varydatAGN))
    colnormAGN = matplotlib.colors.Normalize(vmin=cminAGN,vmax=cmaxAGN)
    cmaparrAGN = np.linspace(cminAGN, cmaxAGN, 30) #cmax-cmin)
    mmAGN      = plt.cm.ScalarMappable(cmap=cmapAGN)
    mmAGN.set_array(cmaparrAGN)

    if varyparam == 'Zgas':
        # colortickvals   = [1e-4, 2e-4, 5e-4, 1e-3, 2e-3, 0.003048, 4e-3, 6e-3, 8e-3, 0.01, 0.01524, 0.02, 0.03, 0.04, 0.07] # 0.014, 0.017,
        colortickvals   = [1e-4, 3e-4, 7e-4, 1e-4, 0.003048, 0.007, 0.01524, 0.03, 0.07]
        colorlabels     = [ str(ct) for ct in colortickvals]
        colorlabels[4]  =  '0.2Z$_\odot$' # = 0.003048
        colorlabels[6] =  'Z$_\odot$'     # = 0.01524
        colortickvals   = np.log10(np.asarray(colortickvals))
        cbarlegend      = legenddic[varyparam]
    elif varyparam == 'logUs':
        colortickvals = [-5.0,-4.5,-4.0, -3.5, -3.0, -2.5, -2.0, -1.5, -1.0]
        colorlabels   = [ str(ct) for ct in colortickvals]
        cbarlegend    = legenddic[varyparam]
    else:
        ncolticks     = 10.
        colortickvals = np.arange(cmin,cmax,np.abs(cmax-cmin)/ncolticks)
        colorlabels   = [ str(ct) for ct in colortickvals]

        if varyparam in logcolors:
            cbarlegend = 'log10('+legenddic[varyparam]+')'
        else:
            cbarlegend = legenddic[varyparam]

    colshrink   = 1.0
    colaspect   = 30
    colbarscale = 2.1
    colanchor   = (0.0,1.0)
    colshrink   = colshrink/colbarscale
    colaspect   = colaspect/colbarscale
    cextend     = 'neither'

    cb1      = plt.colorbar(mm,extend=cextend,orientation='vertical',ticks=colortickvals,
                            pad=0.01,aspect=colaspect,shrink=colshrink,anchor=colanchor,use_gridspec=False)
    cb1.ax.set_yticklabels(colorlabels,rotation=0)
    cb1.set_label(cbarlegend)     #Zgas is unitless as it is a mass ratio (see Gutkin et al. 2016 Eq. 10)

    for vdSF in np.unique(varydatSF):
        SFcol    = cmap(colnorm(vdSF))
        SFcolent = np.where(varydatSF == vdSF)

        plt.scatter(ratioSF_x[SFcolent],ratioSF_y[SFcolent],s=markersize,
                    marker=SFmarker,lw=0.2, facecolor='None',edgecolor=SFcol, zorder=5)

    for vdAGN in np.unique(varydatAGN):
        AGNcol    = cmapAGN(colnorm(vdAGN)) # 'gray'
        AGNcolent = np.where(varydatAGN == vdAGN)

        plt.scatter(ratioAGN_x[AGNcolent],ratioAGN_y[AGNcolent],s=markersize,
                    marker=AGNmarker,lw=0.2, facecolor='None',edgecolor=AGNcol, zorder=5)

    titleaddition = infostrSFcut
    return titleaddition
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def match_tdosespectra_to_templates(spectra,outputdir,outkeystr='FELISmatch_RENAME',
                                    subtract_spec_median=True,
                                    lines2find=['CIII','CIV','HeII','NV','OIII','SiIII','MgII'],
                                    CCwavewindow=10.0,plot_allCCresults=False,
                                    overwrite=False,verbose_FELIS=False,verbose=True):
    """
    Wrapper around felis.match_templates2specs() to match FELIS templates to a sample of TDOSE spectra.

    --- INPUT ---
    spectra                List of spectra to search for emission features via the FELIS template matches.
    outputdir              Directory to contiain the output (plots and *pkl files).
    outkeystr              String used in naming output.
    subtract_spec_median   Subtract the median during the template match to approximate the continuum in the
                           matched region of the spectrum.
    lines2find             List of lines to look for; determines what templates to match to each spectrum.
    CCwavewindow           Rest-frame width (central wavelengths +/- CCwavewindow) to match templates in.
    plot_allCCresults      Plot all template matches; timeconsuming so default is False. Can always be done afterwards.
    overwrite              Overwrite the output pickle file if it already exists?
    verbose_FELIS          Set to true to get vebosity of FELIS matching
    verbose                Set to true to get vebpsity of progress of the matching by the wrapper.

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    specdir   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/spectra_aperture/'
    spectra   = glob.glob(specdir+'tdose_spectrum*aperture_07209*.fits')
    outputdir = ' /Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/'
    uves.match_tdosespectra_to_templates(spectra,outputdir,outkeystr='FELISmatch2udf10_07209starUVESobj190913')

    """
    templatedir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/felis_templates_fromsetup/'
    uvesobjinfo = afits.open('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits')[1].data
    MUSEwaves   = np.array([4790,9310])
    waverest    = {'lya':1215.67, 'ciii':1907.7, 'civ':1549.5, 'nv':1240.8,
                   'heii':1640.4, 'oiii':1663.5, 'mgii':2799.1, 'siiii':1887.4}
    matchno     = 0
    if verbose: print('\n - Will match the '+str(len(spectra))+' spectra to templates of the lines '+str(lines2find))
    for ss, spectrum in enumerate(spectra):
        obj_id       = int(spectrum.split('_')[-1].split('.fit')[0])
        obj_ent      = np.where(uvesobjinfo['id'] == obj_id)[0]
        if len(obj_ent) != 1:
            sys.exit('ERROR - There are '+str(len(obj_ent))+' matches in the UVES info file to object '+str(obj_id))

        obj_zLya      = uvesobjinfo['redshift'][obj_ent]
        MUSEwaves_rf  = MUSEwaves / (1.0 + obj_zLya)

        for templine in lines2find:
            Nmatch      = len(spectra)*len(lines2find)
            matchno     = matchno+1
            if verbose:
                infostr = '   FELIS match '+str("%.5d" % (matchno))+' / '+str("%.5d" % Nmatch)+'     '
                sys.stdout.write("%s\r" % infostr)
                sys.stdout.flush()

            linewave_rf  = waverest[templine.lower()]
            if (MUSEwaves_rf[0]+CCwavewindow < linewave_rf) & (linewave_rf < MUSEwaves_rf[1]-CCwavewindow):
                templates  = glob.glob(templatedir+'uves_felis_template_fromsetup_'+templine+'*.fits')
                if len(templates) == 0:
                    print('\n WARNING: No templates found for "lines2find"='+str(templine))
                else:
                    picklefile = outputdir+spectrum.split('/')[-1].replace('.fits','_CCresults_template'+
                                                                           templine+'_'+outkeystr+'.pkl')

                    wavewindow = CCwavewindow * (1+obj_zLya) # turn CCwavewindow into observed frame
                    ccdic      = felis.match_templates2specs(templates,[spectrum],[obj_zLya],
                                                             picklefile,wavewindow=[wavewindow],
                                                             plotdir=outputdir,
                                                             wavecen_restframe=[linewave_rf],
                                                             vshift=None,min_template_level=1e-4,
                                                             plot_allCCresults=plot_allCCresults,
                                                             subtract_spec_median=subtract_spec_median,
                                                             overwrite=overwrite,
                                                             verbose=verbose_FELIS)
            else:
                pass
    if verbose: print('\n   done...\n')


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def gen_tdosespecFELISresults_summary(summaryfile,picklefiles,overwrite=False,verbose=True):
    """
    Generate a summary of the template characteristics FELIS determined to match the tdose spectra
    the best, i.e. with the highest S/N.

    --- INPUT ---
    summaryfile        Path and name of summary file to generate.
    picklefiles        List of FELIS pickle files to summarize.
    overwrite          Overwrite the summary file if it already exists?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    FELISoutputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults/'
    summaryfile    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra_CCresults_summary_all.txt'
    picklefiles    = glob.glob(FELISoutputdir+'*.pkl')
    summarydat     = uves.gen_mocspecFELISresults_summary(summaryfile,picklefiles)

    """
    if verbose: print(' - Generating a summary of the best-fit template in:\n   '+summaryfile)
    if os.path.isfile(summaryfile) & (not overwrite):
        sys.exit(' Summary file '+summaryfile+' already exists and overwrite=False ')

    fout = open(summaryfile,'w')
    fout.write('# Summary of '+str(len(picklefiles))+' FELIS pickle files provided \n')
    fout.write('# File contains the characteristics of the templates with max S/N from the FELIS template fits \n')
    fout.write('# The summary was generated with uves.gen_tdosespecFELISresults_summary() on '+kbs.DandTstr2()+' \n')
    fout.write('# \n')
    fout.write('# Columns are:\n')
    fout.write('# id                         ID of object matched \n')
    fout.write('# z_spec                     Instrinspic redshift of matched mock spectrum \n')
    fout.write('# z_temp_S2Nmax              Estimated redshift from template match\n')
    fout.write('# sigma_temp_ang_rf          Rest-frame line width in angstroms for maxS/N template \n')
    fout.write('# Fratio_temp                Flux ratio of doublets in template      (line_lowwave/line_highwave) \n')
    fout.write('# Ftot_FELIS_S2Nmax          Estimated total flux from FELIS template match for maxS/N match \n')
    fout.write('# Ftot_FELIS_S2Nmax_err      Uncertainty on FELISflux_S2Nmax [sqrt(Ftot_FELIS_S2Nmax_variance)]\n')
    fout.write('# FELIS_S2Nmax               The S/N value of the (scaled) template match to the mock spectrum \n')
    fout.write('# Ngoodent                   The number of good pixels used in the cross correlation \n')
    fout.write('# chi2                       Chi^2 value between the mock spectrum and the template match \n')
    fout.write('# vshift_spec                Known intrinsic velocity shift of mock spectrum \n')
    fout.write('# vshift_CCmatch             Estimated velocity shift from template match '
               ' [ c*(z_spec-z_temp_S2Nmax)/(1+z_temp_S2Nmax) ]\n')
    fout.write('# lineS2N_rf                 Estimated S/N (rest-frame) of spectral feature within [lineS2Nwavemin_rf,lineS2Nwavemin_rf] \n')
    fout.write('# lineS2Nwavemin_rf          Lower integration limit for rest-frame S/N estimate \n')
    fout.write('# lineS2Nwavemax_rf          Upper integration limit for rest-frame S/N estimate \n')
    fout.write('# Ftot_lineS2N_rf            Total flux of spectral feature (sum(f)*dwave) used to estimate line S/N \n')
    fout.write('# Ftot_lineS2N_sigma_rf      Square root of the variance/sqrt(Npix) of Ftot \n')
    fout.write('# spectrum                   The mock spectrum the templates were matched to \n')
    fout.write('# template                   The maxS/N template \n')
    fout.write('# \n')
    fout.write('# id z_spec z_temp_S2Nmax sigma_temp_ang_rf Fratio_temp Ftot_FELIS_S2Nmax Ftot_FELIS_S2Nmax_err FELIS_S2Nmax Ngoodent chi2 vshift_spec vshift_CCmatch lineS2N_rf lineS2Nwavemin_rf lineS2Nwavemax_rf Ftot_lineS2N_rf Ftot_lineS2N_sigma_rf spectrum template \n')

    for pp, picklefile in enumerate(picklefiles):
        if verbose:
            infostr = ' - Summarizing picklefile  '+str("%.5d" % (pp+1))+' / '+str("%.5d" % len(picklefiles))+'     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        pkldic  = felis.load_picklefile(picklefile)

        Nsigma_integration = 3.0

        for specname in pkldic.keys():
            tempdic = pkldic[specname]

            #------ load info about max S/N template ------
            template, vshift_intr, vshift_match, Ftot_FELIS_S2Nmax, Ftot_FELIS_S2Nmax_err, \
            FELIS_S2Nmax, Ngoodent, chi2, z_spec, zS2Nmax =  \
                felis.getresult4maxS2N(pkldic,specname)

            #------ load matched spec and move to restframe ------
            s_wave   , s_flux   , s_df   , s_s2n    = felis.load_spectrum(specname,verbose=False)
            s_wave_rf, s_flux_rf, s_df_rf, s_s2n_rf = s_wave / (1+z_spec), s_flux * (1+z_spec), s_df * (1+z_spec), s_s2n

            #------ extract info on mock spectrum from fits headers ------
            spec_hdr        = afits.open(specname)[1].header
            spec_sigma_ang  = np.array([])
            spec_flux       = np.array([])
            spec_line_wave  = np.array([])
            for hdrkey in spec_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: spec_line_wave = np.append(spec_line_wave,spec_hdr[hdrkey])
                    if '_2' in hdrkey: spec_sigma_ang = np.append(spec_sigma_ang,spec_hdr[hdrkey])
                    if '_4' in hdrkey: spec_flux      = np.append(spec_flux,spec_hdr[hdrkey])

            spec_sigma_ang_obs = np.mean(spec_sigma_ang)
            spec_sigma_ang_rf  = spec_sigma_ang_obs / (1.0+z_spec)
            Ftot_spec_intr     = np.sum(spec_flux)
            if len(spec_flux) == 2:
                Fratio_spec = spec_flux[np.where(spec_line_wave == np.min(spec_line_wave))] / \
                              spec_flux[np.where(spec_line_wave == np.max(spec_line_wave))]
            else:
                Fratio_spec = 0.0

            #------ extract info on template from fits headers ------
            temp_hdr        = afits.open(template)[1].header
            temp_sigma_ang  = np.array([])
            temp_flux       = np.array([])
            temp_line_wave  = np.array([])
            for hdrkey in temp_hdr.keys():
                if ('noise' not in hdrkey.lower()) & ('err' not in hdrkey.lower()):
                    if '_1' in hdrkey: temp_line_wave = np.append(temp_line_wave,temp_hdr[hdrkey])
                    if '_2' in hdrkey: temp_sigma_ang = np.append(temp_sigma_ang,temp_hdr[hdrkey])
                    if '_4' in hdrkey: temp_flux      = np.append(temp_flux,temp_hdr[hdrkey])

            temp_sigma_ang_rf  = np.mean(temp_sigma_ang)
            if len(temp_flux) == 2:
                Fratio_temp = temp_flux[np.where(temp_line_wave == np.min(temp_line_wave))] / \
                              temp_flux[np.where(temp_line_wave == np.max(temp_line_wave))]
            else:
                Fratio_temp = 0.0

            #------ estimate signal to noise by integrating observed spectrum in restfram ------
            lineS2Nwavemin_rf = np.min(temp_line_wave)-Nsigma_integration*temp_sigma_ang_rf
            lineS2Nwavemax_rf = np.max(temp_line_wave)+Nsigma_integration*temp_sigma_ang_rf
            waverange_rf      = [lineS2Nwavemin_rf,lineS2Nwavemax_rf]
            Ftot_lineS2N_rf, Ftot_lineS2N_var_rf, Npixgood_rf, lineS2N_rf = \
                uves.calc_1Dspec_S2N(s_wave_rf,s_flux_rf,s_df_rf**2.0,waverange_rf,verbose=False)
            Ftot_lineS2N_sigma_rf = np.sqrt(Ftot_lineS2N_var_rf)

            #------------ Writing to output file ------------
            outstr = specname.split('_')[-1].split('.fit')[0]+'  '+\
                     str("%7.8f" % z_spec)+'  '+\
                     str("%7.8f" % zS2Nmax)+'      '+\
                     str("%7.4f" % temp_sigma_ang_rf)+'      '+\
                     str("%7.2f" % Fratio_temp)+'      '+\
                     str("%12.4f" % Ftot_FELIS_S2Nmax)+'  '+\
                     str("%12.4f" % Ftot_FELIS_S2Nmax_err)+'  '+\
                     str("%12.4f" % FELIS_S2Nmax)+'  '+\
                     str("%12.4f" % Ngoodent)+'  '+\
                     str("%12.4f" % chi2)+'  '+\
                     str("%12.4f" % vshift_intr)+'  '+\
                     str("%12.4f" % vshift_match)+'      '+\
                     str("%12.4f" % lineS2N_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemin_rf)+'  '+\
                     str("%12.4f" % lineS2Nwavemax_rf)+'  '+\
                     str("%12.4f" % Ftot_lineS2N_rf)+'  '+\
                     str("%12.4f" % Ftot_lineS2N_sigma_rf)+'  '+\
                     specname+'  '+\
                     template+'  '
            fout.write(outstr+'\n')
    if verbose: print('\n   ...done')
    fout.close()

    fmt = '12a,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
    summarydat = np.genfromtxt(summaryfile,skip_header=25,dtype=fmt,comments='#',names=True)
    return summarydat


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_tdosespecFELISresults_summary(summaryfile,plotbasename,colortype='lineS2N_rf',obj2show='all',
                                       histaxes=True,Nbins=50,S2Ncut=[0.0,1000.0],point_text=None,
                                       overwrite=False,verbose=True):
    """
    plotting and evaluating the output from uves.gen_tdosespecFELISresults_summary()

    --- INPUT ---
    summaryfile        Path and name to summary file to evaluate
    plotbasename       The based name for the plots to generate (incl. output directory)
    colortype          The type of color bar to show
    obj2show           To only show a sumbsample of objects from the summary file provide the ids here.
    overwrite          Overwrite the plots if they already exist?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    outdir         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/CCresults_summary/'
    summaryfile    = outdir+'CCresults_summary_templateCIII_FELISmatch2udf10_07209starUVESobj190913.txt'
    plotbasename   = outdir+'plottest_'
    uves.plot_mocspecFELISresults_summary(summaryfile,plotbasename)

    """
    if verbose: print(' - Loading and plotting the content of \n   '+summaryfile)
    fmt = '12a,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
    summarydat  = np.genfromtxt(summaryfile,skip_header=25,dtype=fmt,comments='#',names=True)
    Nspecin     = len(summarydat['spectrum'])

    if obj2show is not 'all':
        showent = np.array([])
        for objid in obj2show:
            objent = np.where( summarydat['id'].astype(int) == objid)[0]
            if len(objent) > 0:
                showent = np.append(showent,objent)
    else:
        showent = np.arange(len(summarydat))

    if verbose: print(' - Plotting FELIS matches in summary file\n   '+summaryfile+'\n   where the following holds:')
    if verbose: print('    S/N(FELIS)          = ['+str(S2Ncut[0])+','+str(S2Ncut[1])+']    (both ends included)')
    selectionAll  = np.where( (summarydat['FELIS_S2Nmax'] >= S2Ncut[0]) & (summarydat['FELIS_S2Nmax'] <= S2Ncut[1]) )[0]

    selection     = []
    for selent in selectionAll:
        if selent in showent:
            selection.append(selent)

    Nselspec    = len(selection)
    if Nselspec > 0:
        selecteddat = summarydat[selection]
        if verbose: print(' - '+str(Nselspec)+'/'+str(Nspecin)+' matched spectra in summary satisfies the cuts\n')
    else:
        if verbose: print(' WARNING No FELIS matches found in summary file satisfying cuts; returning...')
        return

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_z_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['z_spec']
    yvalues  = selecteddat['z_temp_S2Nmax']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = '$z$(spectrum)'
    ylabel   = '$z$(FELIS)'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=selecteddat['FELIS_S2Nmax'],
                                                   linetype='onetoone',point_text=point_text,
                                                   xlog=False,ylog=False,xrange=[1,6.5],yrange=[1,6.5],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_S2N_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['lineS2N_rf']
    yvalues  = selecteddat['FELIS_S2Nmax']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(xvalues)
    xlabel   = 'Integrated spectrum flux S/N (+/-3$\sigma$)'
    ylabel   = 'S/N(FELIS)'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=selecteddat['sigma_temp_ang_rf'],
                                                   linetype='onetoone',point_text=point_text,
                                                   xlog=True,ylog=True,xrange=[1.,200],yrange=[1.,200],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_lineVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['Ftot_lineS2N_rf']
    xerr     = selecteddat['Ftot_lineS2N_sigma_rf']
    yvalues  = selecteddat['Ftot_FELIS_S2Nmax']
    yerr     = selecteddat['Ftot_FELIS_S2Nmax_err']

    xlabel   = 'Integrated spectrum flux (+/-3$\sigma$) [1e-20erg/s/cm$^2$]'
    ylabel   = 'F(FELIS) [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=selecteddat['FELIS_S2Nmax'],
                                                   linetype='onetoone',point_text=point_text,
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_Ftot_lineVSfelis_sigma'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['Ftot_lineS2N_rf']
    xerr     = selecteddat['Ftot_lineS2N_sigma_rf']
    yvalues  = selecteddat['Ftot_FELIS_S2Nmax']
    yerr     = selecteddat['Ftot_FELIS_S2Nmax_err']

    xlabel   = 'Integrated spectrum flux (+/-3$\sigma$) [1e-20erg/s/cm$^2$]'
    ylabel   = 'F(FELIS) [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='sigma',cdatvec=selecteddat['sigma_temp_ang_rf'],
                                                   linetype='onetoone',point_text=point_text,
                                                   xlog=True,ylog=True,xrange=[10,2e4],yrange=[10,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)




    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_sigmaVSfelisflux'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['sigma_temp_ang_rf']
    xerr     = [None]*len(xvalues)
    yvalues  = selecteddat['Ftot_FELIS_S2Nmax']
    yerr     = selecteddat['Ftot_FELIS_S2Nmax_err']

    xlabel   = '$\sigma$(FELIS) [\AA]'
    ylabel   = 'F(FELIS) [1e-20erg/s/cm$^2$]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=selecteddat['FELIS_S2Nmax'],
                                                   linetype='onetoone',point_text=point_text,
                                                   xlog=False,ylog=True,xrange=[0.0,2.7],yrange=[10.0,2e4],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'horizontal_zVSvshift'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['z_spec']
    yvalues  = selecteddat['vshift_CCmatch']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)

    xlabel   = '$z$(spectrum)'
    ylabel   = '$\Delta v$/[km/s] = $c$[$z$(spectrum)-$z$(FELIS)] / [1+$z$(FELIS)]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',point_text=point_text,
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext  = 'onetoone_vshift_literatureVSfelis'
    plotname = plotbasename+nameext+'.pdf'
    xvalues  = selecteddat['vshift_spec']
    yvalues  = selecteddat['vshift_CCmatch']
    xerr     = [None]*len(xvalues)
    yerr     = [None]*len(yvalues)

    xlabel   = '$\Delta v$(Literature)/[km/s]'
    ylabel   = '$\Delta v$/[km/s] = $c$[$z$(spectrum)-$z$(FELIS)] / [1+$z$(FELIS)]'

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,summarydat,
                                                   histaxes=histaxes,Nbins=Nbins,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'],
                                                   linetype='horizontal',point_text=point_text,
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    #-------------------------------------------------------------------------------------------------------------------
    #-------------------------------------------------------------------------------------------------------------------
    goodFratio = np.where(selecteddat['Fratio_temp'] > 0)
    if len(goodFratio[0]) > 0:
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        nameext  = 'onetoone_FratioVSs2n'
        plotname = plotbasename+nameext+'.pdf'
        xvalues  = selecteddat['Fratio_temp'][goodFratio]
        xerr     = [None]*len(xvalues)
        yvalues  = selecteddat['Ftot_FELIS_S2Nmax'][goodFratio]
        yerr     = selecteddat['Ftot_FELIS_S2Nmax_err'][goodFratio]

        xlabel   = 'FR(FELIS)'
        ylabel   = 'F(FELIS) [1e-20erg/s/cm$^2$]'

        uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,selecteddat,
                                                       histaxes=histaxes,Nbins=Nbins,
                                                       colortype='s2nfelis',cdatvec=selecteddat['FELIS_S2Nmax'][goodFratio],
                                                       linetype='onetoone',point_text=point_text,
                                                       xlog=False,ylog=True,xrange=[0.0,3.3],yrange=[10.0,2e4],
                                                       colorcode=True,overwrite=overwrite,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def calc_1Dspec_S2N(wavelengths,fluxes,variances,waverange,verbose=True):
    """
    Estimating the signal to noise ratio of a defined region in a 1D spectrum.
    Signal and noise is obtained by trapexoidal integration of the flux propogating errors.

    --- INPUT ---
    wavelengths      Wavelength vector of 1D spec
    fluxes           Flux values of pixels in 1D spec
    variance         Variances for fluxes in 1D spec
    waverange        Wavelenght range to estimate S/N over
    verbose          Toggle verbosity

    --- EXAMPLE OF USE ---
    import astropy.io.fits as afits
    import uvEmissionlineSearch as uves
    import glob

    specs = glob.glob('/Users/kschmidt/work/MUSE/uvEmissionlineSearch/mockspectra/uves_mock_spectrum_fromsetup_CIIIdoublet_noisespec_sigma0p50_skew0p00_Ftot85p71_Fratio1p40_z*fits')

    for spec in specs:
        redshift    = float(spec.split('io1p40_z')[-1].split('.fit')[0].replace('p','.'))
        wavelengths = afits.open(spec)[1].data['wave']
        fluxes      = afits.open(spec)[1].data['flux']
        variances   = afits.open(spec)[1].data['fluxerror']**2.0
        dwave_rest  = 5.0
        waverange   = [(1908.0-dwave_rest/2.)*(1.0+redshift),(1908.0+dwave_rest/2.)*(1.0+redshift)]

        print(' --- Calc for '+spec.split('/')[-1]+';\n --- waverange='+str(waverange))
        Ftot, vartot, Npix, S2N = uves.calc_1Dspec_S2N(wavelengths,fluxes,variances,waverange)

    """
    if verbose: print(' - Estimating S/N of 1D spectral range '+str(waverange))
    goodent = np.where((wavelengths >= waverange[0]) & (wavelengths <= waverange[1]) & np.isfinite(fluxes) & (variances != 0))

    if len(goodent[0]) == 0.0:
        if verbose: print(' - No good (finite) pixels in wavelength range '+str(waverange))
        Ftot, vartot, Npix, S2N = 0.0, 0.0, 0.0, 0.0
    else:
        Npix   = len(goodent[0])
        if Npix == 1:
            dwave  = np.median(np.diff(wavelengths))
            Ftot   = fluxes[goodent] * dwave
            vartot = variances[goodent] * dwave**2
            S2N    = Ftot/np.sqrt(vartot)
        else:
            datarr = unumpy.uarray(fluxes[goodent], np.sqrt(variances[goodent]))
            Ftot   = np.trapz(datarr,wavelengths[goodent])
            S2N    = Ftot.nominal_value/Ftot.std_dev
            Ftot, vartot = Ftot.nominal_value, Ftot.std_dev**2

    if verbose: print(' - Returning values  Ftot(trapz), vartot, Npix, S/N = '+
                      str(Ftot)+', '+str(vartot)+', '+str(Npix)+', '+str(S2N)+'')
    return Ftot, vartot, Npix, S2N

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def match_MUSEWideLAEs(templatedir,zrange=[1.516,3.874],datestr='dateofrun',line='CIII',
                       wave_restframe=1908.0,generateplots=False,specificobj=None,
                       lamwidth_restframe='dvoffset',runonallspecs=False,subtract_spec_median=True,verbose=True):
    """
    Wrapper around felis.match_templates2specs()

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    #list of IDs of test objects
    specificobj = [214002011,123048186,115003085]

    tempdir  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/felis_testing/'

    picklefileCIII = uves.match_MUSEWideLAEs(tempdir,zrange=[1.516,3.874],line='CIII',wave_restframe=1908.0,generateplots=False)
    picklefileCIV  = uves.match_MUSEWideLAEs(tempdir,zrange=[2.100,4.996],line='CIV',wave_restframe=1549.0,generateplots=False)

    ccdicCIII      = uves.load_picklefile(picklefileCIII)
    ccdicCIV       = uves.load_picklefile(picklefileCIV)


    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Grabbing TDOSE spectra and loading object info ')
    #specdir    = '/Volumes/DATABCKUP1/TDOSEextractions/171201_TDOSEextraction/Modelimg/tdose_spectra/'
    specdir    = '/Volumes/DATABCKUP1/TDOSEextractions/180824_TDOSEextraction_LAEs60fields/modelimg/tdose_spectra/'
    if runonallspecs:
        specs_all  = glob.glob(specdir+'tdose_spectrum_candels-*.fits')
    else:
        specs_all  = [specdir+'tdose_spectrum_candels-cdfs-04_modelimg_0104014050-0104014050.fits',
                      specdir+'tdose_spectrum_candels-cdfs-15_modelimg_0115003085-0115003085.fits',
                      specdir+'tdose_spectrum_candels-cdfs-06_modelimg_0106004019-0106004019.fits',
                      specdir+'tdose_spectrum_candels-cdfs-25_modelimg_0125042115-0125042115.fits']

    uvlinesdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/'
    z_all      = afits.open(uvlinesdir+'LAEinfo.fits')[1].data['redshift']
    id_all     = afits.open(uvlinesdir+'LAEinfo.fits')[1].data['id']
    try:
        vshift_all = afits.open(uvlinesdir+'LAEinfo.fits')[1].data['red_peak_shift_AV17_kms']
    except:
        vshift_all = afits.open(uvlinesdir+'LAEinfo.fits')[1].data['red_peak_shift_V18_kms']

    specs     = []
    objzs     = []
    vshift    = []

    for spec in specs_all:
        specid  = int(spec.split('_')[-1].split('-')[0])
        goodent = np.where(id_all == specid)
        if len(goodent) != 1:
            sys.exit(' ERROR: found '+str(len(goodent))+' matches to id = '+str(specid))

        zobj = z_all[goodent][0]
        if (zobj > zrange[0]) & (zobj < zrange[1]):

            if specificobj is not None:
                if specid not in specificobj: # skipping objects not in "specificobj" list
                    continue

            specs.append(spec)
            objzs.append(zobj)
            vshift.append(vshift_all[goodent][0])
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Grabbing templates ')
    #temps    = glob.glob(templatedir+'uves_felis_template_'+line+'doublet_sig_*_flux'+line+'1_1p0_flux*.fits')
    temps    = glob.glob(templatedir+'uves_felis_template_'+line+'*_sig_*.fits')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if lamwidth_restframe == 'dvoffset':
        if verbose: print(' - Getting wavelength range width (obs frame) corresponding to systemic velocity offset from AV15')
        lamwidth  = []
        wave_rest = [wave_restframe]*len(specs)
        for ss, spec in enumerate(specs):
            lam_obs, lam_offset, dlam = kbs.velocityoffset2dwave(objzs[ss],vshift[ss],wave_rest[ss])
            if dlam > 2.0:
                lamwidth.append(dlam*5.0)
            else:
                lamwidth.append(60.0)
    else:
        if verbose: print(' - Convert fixed rest-frame wavelength width to obs frame widths')
        lamwidth           = []
        wave_rest = [wave_restframe]*len(specs)
        for ss, spec in enumerate(specs):
            waveobs_low  = (wave_rest[ss]-lamwidth_restframe) * (1.0 + objzs[ss-1])
            waveobs_high = (wave_rest[ss]+lamwidth_restframe) * (1.0 + objzs[ss-1])
            lamwidth.append( (waveobs_high - waveobs_low) / 2. )

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Crosscorrelating templates to spectra using FELIS')
    picklefile = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/MUSEWideLAEs_CCresults'+datestr+'_'+line+'_RENAME_.pkl'
    if generateplots:
        plotdir            = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/MUSEwideLAE_FELISplots/'
        plot_allCCresults  = True
    else:
        plotdir            = None
        plot_allCCresults  = False
    ccdic      = felis.match_templates2specs(temps,specs,objzs,picklefile,wavewindow=lamwidth,plotdir=plotdir,
                                             wavecen_restframe=wave_rest,vshift=vshift,min_template_level=1e-4,
                                             plot_allCCresults=plot_allCCresults,subtract_spec_median=subtract_spec_median)
    return picklefile
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_FELISmatchOutput_OLD(picklefile,line='CIII',verbose=True,
                          plotdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/MUSEwideLAE_FELISplots/'):
    """
    Producing analytic plots based on a pickled output from match_templates2specs()

    --- EXAMPLE OF USE ---
    uves.plot_FELISmatchOutput('MUSEWideLAEs_CCresults180325_CIII_9templaterun.pkl',line='CIII')
    uves.plot_FELISmatchOutput('MUSEWideLAEs_CCresults180325_CIV_9templaterun.pkl',line='CIV')

    """
    CCdic   = felis.load_picklefile(picklefile)

    Nspecs  = len(CCdic.keys())
    if verbose: print(' - Loaded pickle file and found cross-correlation results for '+str(Nspecs)+' spectra')

    cr_arrmax        = []
    cn_arrmax        = []
    besttemp_fratios = []
    besttemp_sigmas  = []
    besttemp_zmax    = []
    v_offsetCC       = []
    v_offsetAH       = []

    NaNcount     = 0
    for ss, spec in enumerate(CCdic.keys()):
        cr_arr = CCdic[spec]['ccresultsarray']
        cr_arr = cr_arr[np.isfinite(cr_arr)]

        if len(cr_arr) == 0:
            if verbose: print(' WARNING No finite values in cross-correlation array for \n   '+spec)
            NaNcount = NaNcount + 1.0
            continue
        else:
            cr_arr = CCdic[spec]['ccresultsarray'] # need to re-define to get 2D
            cn_arr = CCdic[spec]['ccnormarray']    # need to re-define to get 2D

            try:
                cr_maxent = np.where(cr_arr == np.max(cr_arr))
                cn_maxent = np.where(cn_arr == np.max(cn_arr))

                if cn_arr[cn_maxent][0] < 0.6:
                    continue
                else:
                    cr_arrmax.append(cr_arr[cr_maxent][0])
                    cn_arrmax.append(cn_arr[cn_maxent][0])
            except:
                print('---->problems... cr array has no proper max (even though NaN arrays are igored)')
                pdb.set_trace()

            cr_besttemp  = cr_maxent[0][0]
            cn_besttemp  = cn_maxent[0][0]

            if cr_besttemp != cn_besttemp:
                print('---->problems... best temp do not match ')
                print('     '+spec)
                print('     Bestent: cr '+str(cr_maxent)+'  and cn '+str(cn_maxent)+'\n')
                #pdb.set_trace()

            besttemp = CCdic[spec]['templatevec'][cn_besttemp]

            besttempt_hdr = afits.open(besttemp)[1].header

            besttemp_fratios.append(besttempt_hdr['F'+line+'1_4']/besttempt_hdr['F'+line+'2_4'])
            besttemp_sigmas.append(besttempt_hdr['F'+line+'1_2'])

            zSysCC = CCdic[spec]['zCCmaxvec'][cn_besttemp]
            zLya    = CCdic[spec]['zLya']
            cc      = 299792.458 # km/s
            v_off   = ( (zLya - zSysCC) / (zSysCC + 1.0) ) * cc

            besttemp_zmax.append(zSysCC)
            v_offsetCC.append(v_off)
            v_offsetAH.append(CCdic[spec]['vshift'])

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_CCnormmax_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(cn_arrmax,color="r",bins=np.arange(-1,1,0.05),histtype="step",lw=1,label=r'')

    plt.xlabel(' Maximum value of normalized cross-correlation for '+str(Nspecs-NaNcount)+' spectra ('+str(NaNcount)+
               ' spectra with all-NaN cross correlation solutions)')
    # plt.ylabel(' S/N ')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_Fratio_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(besttemp_fratios,color="r",bins=30,histtype="step",lw=1,label=r'')

    if line == 'CIII':
        plt.xlabel(' Best matched template line flux ratio (CIII1907/CIII1909) ')
    elif line == 'CIV':
        plt.xlabel(' Best matched template line flux ratio (CIV1548/CIV1551) ')
    # plt.ylabel(' S/N ')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_linesigma_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(besttemp_sigmas,color="r",bins=30,histtype="step",lw=1,label=r'')

    plt.xlabel(' Best matched template line width (Gauss sigma) of '+line+' components [A]')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_voffset_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(v_offsetCC,color="r",bins=np.arange(-1000,1000,10.0),histtype="step",lw=1,label=r'Cross-Corr. prediction')
    hist = plt.hist(v_offsetAH,color="k",bins=np.arange(-1000,1000,10.0),histtype="step",lw=1,label=r'Verhamme prediction')

    plt.xlabel(' Velocity shift [km/s] ')

    leg = plt.legend(fancybox=True, loc='upper left',prop={'size':Fsize},ncol=1,numpoints=1)
    leg.get_frame().set_alpha(0.7)

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_FELISmatchOutput(picklefile,line='CIII',verbose=True,S2Ncut=3,  # only consider CC detections with S/N>S2Ncut
                          plotdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/MUSEwideLAE_FELISplots/',
                          zspecISzLya=False):
    """
    Producing analytic plots based on a pickled output from match_templates2specs()

    --- EXAMPLE OF USE ---
    uves.plot_FELISmatchOutput('MUSEWideLAEs_CCresults180325_CIII_9templaterun.pkl',line='CIII')
    uves.plot_FELISmatchOutput('MUSEWideLAEs_CCresults180325_CIV_9templaterun.pkl',line='CIV')

    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Ensure compatibility with FELIS output dictionaries from before 180912
    zkey = 'zspec'
    if zspecISzLya: zkey = 'zLya'
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    CCdic   = felis.load_picklefile(picklefile)

    Nspecs  = len(CCdic.keys())
    if verbose: print(' - Loaded pickle file and found cross-correlation results for '+str(Nspecs)+' spectra')

    spec_vec         = []
    max_S2N_vec      = []
    flux_vec         = []
    variance_vec     = []
    besttemp_fratios = []
    besttemp_sigmas  = []
    besttemp_zmax    = []
    v_offsetCC       = []
    v_offsetAH       = []

    for ss, spec in enumerate(CCdic.keys()):
        maxS2N   = np.max(CCdic[spec]['S2NCCmaxvec'])

        if maxS2N > S2Ncut:
            best_ent = np.where(CCdic[spec]['S2NCCmaxvec'] == maxS2N)[0]
            if len(best_ent) > 1:
                print('------> WARNING: More than one pixel with maximum S/N = '+str(maxS2N)+' -> choosing "first" template')
                best_ent = best_ent[0]
            besttemp = CCdic[spec]['templatevec'][best_ent][0]

            cc_best_S2N      = CCdic[spec]['ccresultsarr_S2N'][best_ent][0]
            cc_best_flux     = CCdic[spec]['ccresultsarray_flux'][best_ent][0]
            cc_best_variance = CCdic[spec]['ccresultsarray_variance'][best_ent][0]

            SNmax_ent        = np.where(cc_best_S2N == maxS2N)[0]

            if len(SNmax_ent) == 0:
                print('------> WARNING: No match to S/N in S/N vector. skipping data for key:')
                print('       '+spec)
            else:
                if len(np.atleast_1d(cc_best_flux)) == 1:
                    print('WARNING: CC flux vector only contains 1 value for '+spec)
                    continue
                else:
                    best_flux        = cc_best_flux[SNmax_ent]
                    best_variance    = cc_best_variance[SNmax_ent]

                besttempt_hdr = afits.open(besttemp)[1].header
                if 'fluxratio' in besttemp:
                    besttemp_fratios.append(besttempt_hdr['F'+line+'1_4']/besttempt_hdr['F'+line+'2_4'])
                    besttemp_sigmas.append(besttempt_hdr['F'+line+'1_2'])
                else:
                    besttemp_sigmas.append(besttempt_hdr['F'+line+'_2'])

                zSysCC  = CCdic[spec]['zCCmaxvec'][best_ent]
                zLya    = CCdic[spec][zkey]
                cc      = 299792.458 # km/s
                v_off   = ( (zLya - zSysCC) / (zSysCC + 1.0) ) * cc

                spec_vec.append(spec)
                max_S2N_vec.append(maxS2N)
                flux_vec.append(best_flux[0])
                variance_vec.append(best_variance[0])
                besttemp_zmax.append(zSysCC[0])
                v_offsetCC.append(v_off[0])
                v_offsetAH.append(CCdic[spec]['vshift'])

    if len(max_S2N_vec) == 0:
        sys.exit(' No detections passing the S/N cut of '+str(S2Ncut))

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if 'fluxratio' in besttemp:
        plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_Fratio_hist.pdf')
        if verbose: print(' - Setting up and generating plot')
        fig = plt.figure(figsize=(5, 5))
        fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
        Fsize    = 12
        lthick   = 2
        marksize = 4
        plt.rc('text', usetex=True)
        plt.rc('font', family='serif',size=Fsize)
        plt.rc('xtick', labelsize=Fsize)
        plt.rc('ytick', labelsize=Fsize)
        plt.clf()
        plt.ioff()

        hist = plt.hist(besttemp_fratios,color="r",bins=30,histtype="step",lw=1,label=r'')

        if line == 'CIII':
            lineratiostring = '(CIII1907/CIII1909)'
        elif line == 'CIV':
            lineratiostring = '(CIV1548/CIV1551)'
        elif line == 'OIII':
            lineratiostring = '(OIII1661/OIII1666)'
        elif line == 'NV':
            lineratiostring = '(NV1239/NV1243)'

        plt.xlabel(' Template line flux ratio '+lineratiostring)

        if verbose: print('   Saving plot to '+plotname)
        plt.savefig(plotname)
        plt.clf()
        plt.close('all')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_linesigma_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(besttemp_sigmas,color="r",bins=30,histtype="step",lw=1,label=r'')

    plt.xlabel(' Template line width (Gauss sigma) of '+line+' components [A]')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_voffset_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(v_offsetCC,color="r",bins=np.arange(-1000,1000,10.0),histtype="step",lw=1,label=r'Cross-Corr. prediction')
    hist = plt.hist(v_offsetAH,color="k",bins=np.arange(-1000,1000,10.0),histtype="step",lw=1,label=r'Verhamme prediction')

    plt.xlabel(' Velocity shift wrt. Ly$\\alpha$ [km/s] ')

    leg = plt.legend(fancybox=True, loc='upper left',prop={'size':Fsize},ncol=1,numpoints=1)
    leg.get_frame().set_alpha(0.7)

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_S2Nmax_hist.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    hist = plt.hist(max_S2N_vec,color="r",bins=30,histtype="step",lw=1,label=r'')

    plt.xlabel(' S/N ($>$'+str(S2Ncut)+' only)')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    plotname = plotdir+picklefile.split('/')[-1].replace('.pkl','_FluxmaxVSS2Nmax.pdf')
    if verbose: print(' - Setting up and generating plot')
    fig = plt.figure(figsize=(5, 5))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.15, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    yerrbar = np.sqrt(variance_vec)
    plt.errorbar(max_S2N_vec,flux_vec, yerr=yerrbar,fmt='o', markerfacecolor='red', markeredgecolor='black',
                 ecolor='r', capthick=2)

    plt.xlabel(' S/N ($>$'+str(S2Ncut)+' only)')

    if line == 'CIII':
        tempindicator = 'CIII1907 + CIII1909'
    elif line == 'CIV':
        tempindicator = 'CIV1548 + CIV1551'
    elif line == 'OIII':
        tempindicator = 'OIII1661 + OIII1666'
    elif line == 'NV':
        tempindicator = 'NV1239 + NV1243'
    elif line == 'HEII':
        tempindicator = 'HeII1640'

    plt.ylabel(' $F_\\textrm{tot}$/[1e-20cgs] scaling for ('+tempindicator+')')

    if verbose: print('   Saving plot to '+plotname)
    plt.savefig(plotname)
    plt.clf()
    plt.close('all')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def check_neighbors(ids=[214063213],
                    sourcecatdir='/Volumes/DATABCKUP1/TDOSEextractions/180822_TDOSEextraction_LAEs60fields/tdose_sourcecats/',
                    modeldir='/Volumes/DATABCKUP1/TDOSEextractions/MW_LAEs_JKgalfitmodels/'):
    """

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.check_neighbors()

    """

    for id in ids:

        if str(id).startswith('2'):
            field = 'cosmos'
        else:
            field = 'cdfs'

        fieldno = str(id)[1:3]

        sc_generated = sourcecatdir+'tdose_sourcecat_LAEs_candels-'+field+'-'+str(fieldno)+'_id'+\
                       str(id)+'_cutout2p0x2p0arcsec.fits'
        sc_JKmodel   = modeldir+'model_acs_814w_candels-'+field+'-'+str(fieldno)+'_cut_v1.0_id'+\
                       str(id)+'_cutout2p0x2p0arcsec_sourcecatalog.fits'

        sc_gen = afits.open(sc_generated)[1].data
        sc_mod = afits.open(sc_JKmodel)[1].data

        print(' - - - - - - - - - - '+str(id)+' - - - - - - - - - - - ')
        print(" - SOURCE CATALOG GENERATED FROM CROSSMATCH TO MASTER SOURCE CAT")
        print('   '+str(sc_gen['PARENT_ID']))
        print('   '+str(sc_gen['ID']))
        print(" - SOURCE CATALOG CONTENT BASED ON JOSIE'S MODEL")
        print('   '+str(sc_mod['PARENT_ID']))
        print('   '+str(sc_mod['ID']))
        print(' ')
        try:
            print('   diff(PARENT_ID): '+str(sc_gen['PARENT_ID']-sc_mod['PARENT_ID']))
        except:
            print('   WARNING: mismatch in PARENT_ID source cats')
        try:
            print('   diff(ID): '+str(sc_gen['ID']-sc_mod['ID']))
        except:
            print('   WARNING: mismatch in ID source cats')
        print(' ')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def calc_lineratios_fromsummaryfiles(summaryfiles,lineindicators,outputfile, Nsigmalimits=3, vetfelis_output=None, verbose=True):
    """
    Function to calculate the flux and line ratios for a set of summary files
    containing the results from FELIS template matches to TDOSE spectra.

    Based (partially) on uves.calculatelineratios() below.

    --- INPUT ---
    summaryfiles     A list of summaryfiles to generate flux ratio output for
    lineindicators   List of strings indicating the content of the summary files (i.e. the lines that were
                     searched for with the FELIS template match). These are used to name output columns.
    outputfile       The ascii file to write results to.
    verbose          Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    outfile        = outputdir+'fluxratios190919_'+outkeystr+'.txt'
    summaryfiles   = glob.glob(outputdir+'CCresults_summary/CCresults_summary_template*_'+outkeystr+'.txt')
    lineindicators = [sf.split('template')[-1].split('_')[0] for sf in summaryfiles]

    fluxratiodat   = uves.calc_lineratios_fromsummaryfiles(summaryfiles,lineindicators,outfile)

    """
    if len(summaryfiles) != len(lineindicators):
        sys.exit('\nThe '+str(len(summaryfiles))+' provided do not match the '+str(len(lineindicators))+' provided \n')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Loading content of the '+str(lineindicators)+' summary files provided')
    dic_summarydat = {}
    fmt = '12a,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
    for ss, sfile in enumerate(summaryfiles):
        summarydat  = np.genfromtxt(sfile,skip_header=25,dtype=fmt,comments='#',names=True)
        dic_summarydat[lineindicators[ss]] = summarydat

    spectra   = []
    for ll in lineindicators:
        spectra = spectra+list(dic_summarydat[ll]['spectrum'])
    spectra = np.unique(np.array(spectra))

    pointings = []
    ids       = []
    for spec in spectra:
        pointings.append(spec.split('/tdose_spectrum_')[-1].split('-full')[0])
        ids.append(int(spec.split('_')[-1].split('.fit')[0]))
    pointings = np.asarray(pointings)
    ids       = np.asarray(ids)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Initializing the output file: \n   '+outputfile)
    fout = open(outputfile,'w')
    fout.write('# Flux and line ratios estimated based on FELIS template match results summarized in:\n')
    fout.write('# '+str(summaryfiles)+'\n')
    if vetfelis_output is None:
        fout.write('# \n')
        fout.write('# No limits are stored in file - s2n values are provided instead to determine limits in post-processing. \n')
        fout.write('# See for instance uves.plot_lineratios_fromsummaryfiles_wrapper() \n')
    else:
        fout.write('# Using FELIS vetting info from '+vetfelis_output+'\n')
        fout.write('# Limits are provided according to FELIS vetting, i.e., "untrustworthy" lines and non-detections '
                   'are quoted as '+str(Nsigmalimits)+'sigma upper limits. '
                   'Note that all other error bars are also '+str(Nsigmalimits)+'sigma errors. \n')
        fout.write('# The s2n values above this threshold are also provided for post-processing. See for instance uves.plot_lineratios_fromsummaryfiles_wrapper() \n')
    fout.write('# \n')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Determine columns to fill in output')
    fluxratiodic = collections.OrderedDict()
    fluxratiodic['id'] = np.array([])
    fluxratiodic['pointing'] = pointings
    for ll, numerator_line in enumerate(lineindicators):
        fluxratiodic['f_'+numerator_line]       = np.array([])
        fluxratiodic['ferr_'+numerator_line]    = np.array([])
        fluxratiodic['s2n_'+numerator_line]     = np.array([])
        fluxratiodic['sigma_'+numerator_line]   = np.array([])
        fluxratiodic['vshift_'+numerator_line]  = np.array([])

        if len(dic_summarydat[numerator_line]['id']) == 0:
            continue
        elif dic_summarydat[numerator_line]['Fratio_temp'][0] != 0:
            fluxratiodic['f_'+numerator_line+'1']      = np.array([])
            fluxratiodic['ferr_'+numerator_line+'1']   = np.array([])
            fluxratiodic['f_'+numerator_line+'2']      = np.array([])
            fluxratiodic['ferr_'+numerator_line+'2']   = np.array([])
            fluxratiodic['FR_'+numerator_line+'1'+numerator_line+'2']     = np.array([])
            fluxratiodic['FRerr_'+numerator_line+'1'+numerator_line+'2']  = np.array([])
            fluxratiodic['FRs2n_'+numerator_line+'1'+numerator_line+'2']  = np.array([])

        for kk, denominator_line in enumerate(lineindicators):
            if numerator_line == denominator_line:
                continue
            elif len(dic_summarydat[denominator_line]['id']) == 0:
                continue
            else:
                fluxratiodic['FR_'+numerator_line+denominator_line]     = np.array([])
                fluxratiodic['FRerr_'+numerator_line+denominator_line]  = np.array([])
                fluxratiodic['FRs2n_'+numerator_line+denominator_line]  = np.array([])

                if (dic_summarydat[numerator_line]['Fratio_temp'][0] != 0):
                    fluxratiodic['FR_'+numerator_line+'1'+denominator_line]     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'1'+denominator_line]  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'1'+denominator_line]  = np.array([])
                    fluxratiodic['FR_'+numerator_line+'2'+denominator_line]     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'2'+denominator_line]  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'2'+denominator_line]  = np.array([])
                if (dic_summarydat[denominator_line]['Fratio_temp'][0] != 0):
                    fluxratiodic['FR_'+numerator_line+denominator_line+'1']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+denominator_line+'1']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+denominator_line+'1']  = np.array([])
                    fluxratiodic['FR_'+numerator_line+denominator_line+'2']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+denominator_line+'2']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+denominator_line+'2']  = np.array([])
                if (dic_summarydat[numerator_line]['Fratio_temp'][0] != 0) & \
                        (dic_summarydat[denominator_line]['Fratio_temp'][0] != 0):
                    fluxratiodic['FR_'+numerator_line+'1'+denominator_line+'1']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'1'+denominator_line+'1']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'1'+denominator_line+'1']  = np.array([])
                    fluxratiodic['FR_'+numerator_line+'1'+denominator_line+'2']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'1'+denominator_line+'2']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'1'+denominator_line+'2']  = np.array([])
                    fluxratiodic['FR_'+numerator_line+'2'+denominator_line+'1']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'2'+denominator_line+'1']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'2'+denominator_line+'1']  = np.array([])
                    fluxratiodic['FR_'+numerator_line+'2'+denominator_line+'2']     = np.array([])
                    fluxratiodic['FRerr_'+numerator_line+'2'+denominator_line+'2']  = np.array([])
                    fluxratiodic['FRs2n_'+numerator_line+'2'+denominator_line+'2']  = np.array([])

    Ncols      = len(fluxratiodic.keys())
    # a simple dictionary containing the column locations in the output array (indexes)
    colents    = {}
    for oo, colname in enumerate(fluxratiodic.keys()):
        colents[colname] = oo
    if verbose: print('   The output file will contain '+str(Ncols)+' columns ')
    fout.write('# This file contains the following '+str(Ncols)+' columns:\n')
    fout.write('# '+' '.join(fluxratiodic.keys())+'  \n')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if vetfelis_output is not None:
        if verbose: print(' - FELIS vetting results provided so loading these - only vetted objects stored in output.')
        dat_vetfelis  = np.genfromtxt(vetfelis_output,  dtype=None,comments='#',names=True,skip_header=12)
        Nobj_fvet     = len(np.unique(dat_vetfelis['id']))
        if verbose: print('   Found '+str(Nobj_fvet)+' objects in the FELIS vetting output to be stored to line ratios output ')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Filling the columns with data ')
    fluxratioarray = np.zeros([len(ids),Ncols])*np.nan
    for ii, id in enumerate(ids):
        if verbose:
            infostr = '   Filling output for object '+str(id)+'   (id '+str(ii+1)+'/'+str(len(ids))+')'
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        fluxratioarray[ii,0] = float(id)

        if vetfelis_output is not None:
            ent_vet_felis = np.where((dat_vetfelis['id'] == id) & (dat_vetfelis['pointing'] == pointings[ii]))[0]

            if len(ent_vet_felis) > 1:
                sys.exit('\n WARNING: object '+str(id)+' in '+pointings[ii]+
                         ' exisits multiple times in FELIS vetting output; sort this out befor calculating lineratios...')
            elif len(ent_vet_felis) == 0:
                if verbose: print('\n           Object '+str(id)+' in '+pointings[ii]+' not found in FELIS vetting output')
                # continue
                obj_vetfelis = dat_vetfelis[0]#*0.0 (101009024, 'cdfs-01', 99, 99, 99, 99, 99, 99, -99)
                obj_vetfelis['id']       = id
                obj_vetfelis['pointing'] = pointings[ii]
                for col in obj_vetfelis.dtype.names[2:]:
                    if obj_vetfelis[col] != -99:
                        obj_vetfelis[col] = 9999 # no inspection exists; obj_vetfelis made by hand
            else:
                obj_vetfelis = dat_vetfelis[ent_vet_felis]

        for ll, numerator_line in enumerate(lineindicators):
            numerator_dat = dic_summarydat[numerator_line]
            ent_num       = np.where((numerator_dat['id'].astype(int) == id) & (numerator_dat['spectrum'] == spectra[ii]))[0]
            if len(ent_num) == 0:
                # if verbose: print('       object '+str(id)+' in '+pointings[ii]+' not found in '+
                #                   numerator_line+' summary (numerator)')
                continue

            f_num    = numerator_dat['Ftot_FELIS_S2Nmax'][ent_num]
            ferr_num = numerator_dat['Ftot_FELIS_S2Nmax_err'][ent_num]

            fluxratioarray[ii,colents['f_'+numerator_line]]      = f_num
            fluxratioarray[ii,colents['ferr_'+numerator_line]]   = ferr_num
            fluxratioarray[ii,colents['s2n_'+numerator_line]]    = numerator_dat['FELIS_S2Nmax'][ent_num]
            fluxratioarray[ii,colents['sigma_'+numerator_line]]  = numerator_dat['sigma_temp_ang_rf'][ent_num]
            fluxratioarray[ii,colents['vshift_'+numerator_line]] = numerator_dat['vshift_CCmatch'][ent_num]

            trust_numerator = 'yes'

            if vetfelis_output is not None:
                ferr_num = ferr_num * Nsigmalimits

                if (obj_vetfelis['trust'+numerator_line] == 0) or \
                        (obj_vetfelis['trust'+numerator_line] == 99) or \
                        (obj_vetfelis['trust'+numerator_line] == 9999) or \
                        (fluxratioarray[ii,colents['s2n_'+numerator_line]] < Nsigmalimits):

                    if (obj_vetfelis['trust'+numerator_line] == 9999) & \
                            (fluxratioarray[ii,colents['s2n_'+numerator_line]] > Nsigmalimits):
                        if verbose: print('\033[91m        ... and '+numerator_line+' has S/N > '+
                                          str(Nsigmalimits)+'; make sure to include it in the vetting resykts as it will be set to '+
                                              str(Nsigmalimits)+'sigma limits here ...\033[0m')

                    fluxratioarray[ii,colents['f_'+numerator_line]]      = ferr_num
                    fluxratioarray[ii,colents['ferr_'+numerator_line]]   = 99
                    if ferr_num != 0.0:
                        fluxratioarray[ii,colents['s2n_'+numerator_line]] = Nsigmalimits
                    fluxratioarray[ii,colents['sigma_'+numerator_line]]  = 99
                    fluxratioarray[ii,colents['vshift_'+numerator_line]] = 99

                    trust_numerator = 'None'

            # if (id == 102014087) & (pointings[ii] == 'cdfs-08') & (numerator_line == 'CIV'):
            #     pdb.set_trace()

            if (dic_summarydat[numerator_line]['Fratio_temp'][0] != 0) & (trust_numerator != 'None'):
                # error on q=|B|x where |B| is known exact is just dq=|B|dx
                f1_num      = numerator_dat['Ftot_FELIS_S2Nmax'][ent_num]     / (1 + 1/numerator_dat['Fratio_temp'][ent_num])
                f1err_num   = numerator_dat['Ftot_FELIS_S2Nmax_err'][ent_num] / (1 + 1/numerator_dat['Fratio_temp'][ent_num])
                f2_num      = f1_num    / numerator_dat['Fratio_temp'][ent_num]
                f2err_num   = f1err_num / numerator_dat['Fratio_temp'][ent_num]
                FR12, FR12err = lce.set_ratios('gooddoublet','gooddoublet',f1_num,f1err_num,f2_num,f2err_num)

                fluxratioarray[ii,colents['f_'+numerator_line+'1']]                         = f1_num
                fluxratioarray[ii,colents['ferr_'+numerator_line+'1']]                      = f1err_num
                fluxratioarray[ii,colents['f_'+numerator_line+'2']]                         = f2_num
                fluxratioarray[ii,colents['ferr_'+numerator_line+'2']]                      = f2err_num
                fluxratioarray[ii,colents['FR_'+numerator_line+'1'+numerator_line+'2']]     = FR12
                fluxratioarray[ii,colents['FRerr_'+numerator_line+'1'+numerator_line+'2']]  = FR12err
                fluxratioarray[ii,colents['FRs2n_'+numerator_line+'1'+numerator_line+'2']]  = FR12/FR12err

            for kk, denominator_line in enumerate(lineindicators):
                denominator_dat = dic_summarydat[denominator_line]

                ent_denom       = np.where((denominator_dat['id'].astype(int) == id) & (denominator_dat['spectrum'] == spectra[ii]))[0]
                if len(ent_denom) > 1:
                    sys.exit(' id pointing combination '+str(id)+' '+pointings[ii]+' appears '+str(len(ent_denom))+
                             ' times in '+numerator_line+' summary -> that should not happen!')

                if len(ent_denom) == 0:
                    # if verbose: print('       object '+str(id)+' in '+pointings[ii]+' not found in '+
                    #                   denominator_line+' summary (numerator)')
                    continue

                if numerator_line == denominator_line:
                    continue
                else:
                    trust_denominator = 'yes'
                    f_denom    = denominator_dat['Ftot_FELIS_S2Nmax'][ent_denom]
                    ferr_denom = denominator_dat['Ftot_FELIS_S2Nmax_err'][ent_denom]

                    if vetfelis_output is not None:
                        ferr_denom = ferr_denom * Nsigmalimits

                        if (obj_vetfelis['trust'+denominator_line] == 0) or \
                                (obj_vetfelis['trust'+denominator_line] == 99) or \
                                (f_denom/ferr_denom < Nsigmalimits):
                            f_denom           = ferr_denom
                            ferr_denom        = 99
                            trust_denominator = 'None'

                    if (trust_numerator == 'None') & (trust_denominator == 'None'):
                        continue

                    FR, FRerr = lce.set_ratios(trust_numerator,trust_denominator,f_num,ferr_num,f_denom,ferr_denom)
                    fluxratioarray[ii,colents['FR_'+numerator_line+denominator_line]]     = FR
                    fluxratioarray[ii,colents['FRerr_'+numerator_line+denominator_line]]  = FRerr
                    fluxratioarray[ii,colents['FRs2n_'+numerator_line+denominator_line]]  = FR/FRerr

                    if (dic_summarydat[numerator_line]['Fratio_temp'][0] != 0) & (trust_numerator != 'None'):
                        FR, FRerr = lce.set_ratios(trust_numerator,trust_denominator,f1_num,f1err_num,f_denom,ferr_denom)
                        fluxratioarray[ii,colents['FR_'+numerator_line+'1'+denominator_line]]     = FR
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'1'+denominator_line]]  = FRerr
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'1'+denominator_line]]  = FR/FRerr

                        FR, FRerr = lce.set_ratios(trust_numerator,trust_denominator,f2_num,f2err_num,f_denom,ferr_denom)
                        fluxratioarray[ii,colents['FR_'+numerator_line+'2'+denominator_line]]     = FR
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'2'+denominator_line]]  = FRerr
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'2'+denominator_line]]  = FR/FRerr

                    if (dic_summarydat[denominator_line]['Fratio_temp'][0] != 0)  & (trust_denominator != 'None'):
                        f1_denom    = denominator_dat['Ftot_FELIS_S2Nmax'][ent_denom]     / \
                                      (1 + 1/denominator_dat['Fratio_temp'][ent_denom])
                        f1err_denom = denominator_dat['Ftot_FELIS_S2Nmax_err'][ent_denom] / \
                                      (1 + 1/denominator_dat['Fratio_temp'][ent_denom])
                        f2_denom    = f1_denom    / denominator_dat['Fratio_temp'][ent_denom]
                        f2err_denom = f1err_denom / denominator_dat['Fratio_temp'][ent_denom]

                        FR, FRerr = lce.set_ratios(trust_numerator,'gooddoublet',f_num,ferr_num,f1_denom,f1err_denom)
                        fluxratioarray[ii,colents['FR_'+numerator_line+denominator_line+'1']]     = FR
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+denominator_line+'1']]  = FRerr
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+denominator_line+'1']]  = FR/FRerr

                        FR, FRerr = lce.set_ratios(trust_numerator,'gooddoublet',f_num,ferr_num,f2_denom,f2err_denom)
                        fluxratioarray[ii,colents['FR_'+numerator_line+denominator_line+'2']]     = FR
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+denominator_line+'2']]  = FRerr
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+denominator_line+'2']]  = FR/FRerr

                    if (dic_summarydat[numerator_line]['Fratio_temp'][0] != 0) & \
                        (dic_summarydat[denominator_line]['Fratio_temp'][0] != 0) & \
                            (trust_numerator != 'None') & (trust_denominator != 'None'):
                        FR, FRerr = lce.set_ratios('gooddoublet','gooddoublet',f1_num,f1err_num,f1_denom,f1err_denom)
                        fluxratioarray[ii,colents['FR_'+numerator_line+'1'+denominator_line+'1']]     = FR
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'1'+denominator_line+'1']]  = FRerr
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'1'+denominator_line+'1']]  = FR/FRerr

                        FR, FRerr = lce.set_ratios('gooddoublet','gooddoublet',f1_num,f1err_num,f2_denom,f2err_denom)
                        fluxratioarray[ii,colents['FR_'+numerator_line+'1'+denominator_line+'2']]     = FR
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'1'+denominator_line+'2']]  = FRerr
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'1'+denominator_line+'2']]  = FR/FRerr

                        FR, FRerr = lce.set_ratios('gooddoublet','gooddoublet',f2_num,f2err_num,f1_denom,f1err_denom)
                        fluxratioarray[ii,colents['FR_'+numerator_line+'2'+denominator_line+'1']]     = FR
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'2'+denominator_line+'1']]  = FRerr
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'2'+denominator_line+'1']]  = FR/FRerr

                        FR, FRerr = lce.set_ratios('gooddoublet','gooddoublet',f2_num,f2err_num,f2_denom,f2err_denom)
                        fluxratioarray[ii,colents['FR_'+numerator_line+'2'+denominator_line+'2']]     = FR
                        fluxratioarray[ii,colents['FRerr_'+numerator_line+'2'+denominator_line+'2']]  = FRerr
                        fluxratioarray[ii,colents['FRs2n_'+numerator_line+'2'+denominator_line+'2']]  = FR/FRerr

    for ll in np.arange(len(ids)):
        outstr = str(int(fluxratioarray[ll,0]))+'  '+pointings[ll]+' '+' '.join([str("%10.4f" % ff) for ff in fluxratioarray[ll,2:]])
        fout.write(outstr+' \n')
    fout.close()
    if verbose: print('\n - Wrote the flux ratio output to \n   '+outputfile)
    fmt = 'i,12a,'+','.join((Ncols-2)*['d'])
    fluxratiodat = np.genfromtxt(outputfile,skip_header=7,dtype=fmt,comments='#',names=True)
    return fluxratiodat

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_lineratios_fromsummaryfiles(lineratiofile, plotbasename, infofile, colorvar_obj='s2n_CIII', point_text=None,
                                     Nsigma=3.0, colorvar_pi='logUs', vshiftmax=1e5, obj2show='all', showlimits=True,
                                     addliteraturevalues = False,
                                     overwrite=False, verbose=True):
    """
    Function to plot the output containing flux ratios generated with uves.calc_lineratios_fromsummary()

    --- INPUT ---


    --- EXAMPLE OF USE ---
    uves.plot_lineratios_fromsummaryfiles(lineratiofile, plotbasename, overwrite=False, verbose=True)

    """
    if verbose: print(' - Loading flux ratio data to plot ')
    fluxratiodatALL = np.genfromtxt(lineratiofile,skip_header=7,dtype='d',comments='#',names=True)

    if obj2show is 'all':
        showent = np.arange(len(fluxratiodatALL))
    elif obj2show.lower() == 'none':
        showent = np.array([0])
    else:
        sample = 'udf10'
        if obj2show is 'goodspec_only':
            ids_badTDOSEspec, ids_goodTDOSEspec = uves.summarize_tdosevetting(sample=sample,verbose=verbose)
            idlist2show = ids_goodTDOSEspec
        elif obj2show is 'badspec_only':
            ids_badTDOSEspec, ids_goodTDOSEspec = uves.summarize_tdosevetting(sample=sample,verbose=verbose)
            idlist2show = ids_badTDOSEspec
        else:
            idlist2show = obj2show

        showent = np.array([])
        for objid in idlist2show:
            objent = np.where( fluxratiodatALL['id'].astype(int) == objid)[0]
            if len(objent) > 0:
                showent = np.append(showent,objent)

    Nselspec    = len(showent)
    if Nselspec > 0:
        fluxratiodat = fluxratiodatALL[showent.astype(int)]
        if verbose: print(' - '+str(Nselspec)+'/'+str(len(fluxratiodatALL))+' spectra in flux ratio summary satisfies the cuts\n')
    else:
        if verbose: print(' WARNING No flux ratio matches found in summary file satisfying cuts; returning...')
        return

    infofiledat  = afits.open(infofile)[1].data

    if colorvar_obj in fluxratiodat.dtype.names:
        cdatvec   = fluxratiodat[colorvar_obj]
    elif colorvar_obj in infofiledat.columns.names:
        cdatvec = np.zeros(len(fluxratiodat['id']))*np.nan
        for ii, id in enumerate(fluxratiodat['id']):
            infoent     = np.where(infofiledat['id'] == int(id))
            cdatvec[ii] = infofiledat[colorvar_obj][infoent]

    if colorvar_obj.lower() == 's2n_ciii':
        cdattype = 's2n_ciii'
    elif colorvar_obj.lower() == 'redshift':
        cdattype = colorvar_obj.lower()
    else:
        cdattype = None

    #------------------------------- Append literature measurements -------------------------------
    if addliteraturevalues:
        litcat  = '/Users/kschmidt/work/catalogs/literaturecollection_emissionlinestrengths/' \
                  'literaturecollection_emissionlinestrengths.fits'
        litdat  = afits.open(litcat)[1].data
        # litdat  = np.genfromtxt(litcat,names=True,skip_header=5,comments='#',dtype=None)
        Nlitobj = len(litdat)
        litarr  = np.array(np.zeros(Nlitobj)*np.nan,fluxratiodat.dtype)
        for lo, litobject in enumerate(litdat):
            for litcol in litdat.dtype.names:
                if litcol in fluxratiodat.dtype.names:
                    litarr[litcol][lo] = litdat[litcol][lo]

        fluxratiodat = np.hstack((fluxratiodat,litarr))

        if colorvar_obj.lower() == 'redshift':
            cdatvec  = np.hstack((cdatvec,litdat['redshift']))
    # pdb.set_trace() #  litdat['FR_CIVOIII'][-3:], litdat['FR_CIVHeII'][-3:],  litdat['FRerr_CIVHeII'][-3:],  litdat['FRerr_CIVOIII'][-3:]
    # fluxratiodat['FR_CIVOIII'][-3:], fluxratiodat['FR_CIVHeII'][-3:],  fluxratiodat['FRerr_CIVHeII'][-3:],  fluxratiodat['FRerr_CIVOIII'][-3:]

    #----------------------------------------------------------------------------------------------

    if point_text is not None:
        point_text = fluxratiodat['id'].astype(str)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    fluxes_range       = [10,1e4]
    linesetlist_fluxes = []
    linesetlist_fluxes.append(['CIII','CIV'   ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIII','OIII'  ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIII','HeII'  ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIII','MgII'  ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIII','NV'    ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIII','SiIII' ,None,None,fluxes_range, fluxes_range,   None])
    #
    # linesetlist_fluxes.append(['CIV','OIII'   ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIV','HeII'   ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIV','MgII'   ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIV','NV'     ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['CIV','SiIII'  ,None,None,fluxes_range, fluxes_range,   None])
    #
    linesetlist_fluxes.append(['OIII','HeII'  ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['OIII','MgII'  ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['OIII','NV'    ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['OIII','SiIII' ,None,None,fluxes_range, fluxes_range,   None])
    #
    # linesetlist_fluxes.append(['HeII','MgII'  ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['HeII','NV'    ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['HeII','SiIII' ,None,None,fluxes_range, fluxes_range,   None])
    #
    # linesetlist_fluxes.append(['MgII','NV'    ,None,None,fluxes_range, fluxes_range,   None])
    # linesetlist_fluxes.append(['MgII','SiIII' ,None,None,fluxes_range, fluxes_range,   None])
    #
    linesetlist_fluxes.append(['NV','SiIII'   ,None,None,fluxes_range, fluxes_range,   None])

    Nhistbins = 30
    histaxes  = True
    for lineset in linesetlist_fluxes:
        plot_lineratios_fromsummaryfiles_wrapper(plotbasename,fluxratiodat,lineset,histaxes,Nhistbins,cdatvec,cdattype,
                                                 Nsigma=Nsigma,point_text=point_text,vshiftmax=vshiftmax,
                                                 overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ratios_range = [1e-4,1e3]
    linesetlist  = []
    linesetlist.append(['CIV','CIII','CIV','HeII',ratios_range,ratios_range  ,'Schmidt+17 fig. 7 top,   Feltre+16 fig A2a'])
    linesetlist.append(['CIII','HeII','CIV','HeII',ratios_range,ratios_range ,'Schmidt+17 fig. 7 center                  '])
    linesetlist.append(['CIV','OIII','CIV','HeII',ratios_range,ratios_range  ,'Schmidt+17 fig. 7 bottom                  '])
    # linesetlist.append(['CIII','HeII','NV','HeII',ratios_range,ratios_range  ,'Plat+19 fig. 6d                           '])
    # linesetlist.append(['CIII','OIII','CIV','CIII',ratios_range,ratios_range ,'Plat+19 fig. 6f                           '])
    # linesetlist.append(['CIV','HeII','CIV','CIII',ratios_range,ratios_range  ,'Feltre+16 fig 5                           '])
    # linesetlist.append(['CIV','HeII','CIII','HeII',ratios_range,ratios_range ,'Feltre+16 fig 6                           '])
    # linesetlist.append(['NV','HeII','CIII','HeII',ratios_range,ratios_range  ,'Feltre+16 fig 8, fig A1b                  '])
    # linesetlist.append(['CIV','CIII','CIII','HeII',ratios_range,ratios_range ,'Feltre+16 fig A1a                         '])
    # linesetlist.append(['NV','CIV','CIII','HeII',ratios_range,ratios_range   ,'Feltre+16 fig A1c                         '])
    # linesetlist.append(['NV','HeII','CIV','HeII',ratios_range,ratios_range   ,'Feltre+16 fig A2b                         '])
    # linesetlist.append(['NV','CIV','CIV','HeII',ratios_range,ratios_range    ,'Feltre+16 fig A2c                         '])
    # linesetlist.append(['OIII','HeII','CIV','HeII',ratios_range,ratios_range ,'Feltre+16 fig A2e                         '])
    #
    # linesetlist.append(['SiIII','HeII','CIV','HeII',ratios_range,ratios_range,'Feltre+16 fig A2i                         '])
    # linesetlist.append(['CIII','OIII','HeII','CIII',ratios_range,ratios_range  , None])
    # linesetlist.append(['CIII','CIV','OIII','HeII',ratios_range,ratios_range  , None])
    # linesetlist.append(['CIV','SiIII','OIII','HeII',ratios_range,ratios_range, None])

    # linesetlist.append(['MgII','SiIII','OIII','HeII',ratios_range,ratios_range, None])

    Nhistbins = 30
    histaxes  = False
    for lineset in linesetlist:
        if 'MgII' in lineset:                # No MgII columns in the NEOGAL photoionisation models
            photoionizationplotparam = None
        # elif 'NV' in lineset:                # No columns with NV in Maseda line ratio summaryfile
        #     continue
        else:
            #varyparam, cutSFmodels, markersize, SFmarker, AGNmarker, linestrings, doubletratios, histaxes = piplotparam
            photoionizationplotparam = colorvar_pi, False, 1.5, 's', 'D', \
                                       [uves.linenameUVES2NEOGAL(lineset[0]),uves.linenameUVES2NEOGAL(lineset[1]),
                                        uves.linenameUVES2NEOGAL(lineset[2]),uves.linenameUVES2NEOGAL(lineset[3])], \
                                       [None,None,None,None], True

        plot_lineratios_fromsummaryfiles_wrapper(plotbasename,fluxratiodat,lineset,histaxes,Nhistbins,cdatvec,cdattype,
                                                 Nsigma=Nsigma,point_text=point_text,vshiftmax=vshiftmax,
                                                 overwrite=overwrite,verbose=verbose,
                                                 photoionizationplotparam=photoionizationplotparam)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_lineratios_fromsummaryfiles_wrapper(plotbasename,fluxratiodat,lineset,histaxes,Nhistbins,cdatvec,cdattype,
                                             photoionizationplotparam=None,point_text=None,
                                             overwrite=False,Nsigma=3.0,vshiftmax=1e4,verbose=True):
    """
    Wrapper to define input data and excecute plot command

    """
    line1,line2,line3,line4,xrange,yrange,title = lineset

    if (line3 is None) & (line4 is None):
        plotname = plotbasename+'_linefluxes_'+line1+'vs'+line2+\
                   '_Nsigma'+str(Nsigma).replace('.','p')+\
                   '_vshiftLT'+str(vshiftmax).replace('.','p')+'.pdf'
        if ('f_'+line1 in fluxratiodat.dtype.names) & ('f_'+line2 in fluxratiodat.dtype.names):
            goodent  = np.where(np.isfinite(fluxratiodat['f_'+line1]) & np.isfinite(fluxratiodat['f_'+line2]) &
                                (np.abs(fluxratiodat['vshift_'+line1]) < vshiftmax) &
                                (np.abs(fluxratiodat['vshift_'+line2]) < vshiftmax) &
                                (fluxratiodat['id'].astype(float) < 1e10))[0]
        else:
            goodent  = []

        xlabel   = line1+' [1e-20erg/s/cm$^2$]'
        ylabel   = line2+' [1e-20erg/s/cm$^2$]'

        if len(goodent) == 0:
            if verbose: print('\n - OLD WARNING No good values found for the plot: \n           '+plotname.split('/')[-1]+'\n')
            # goodent  = np.asarray([0,1])
            # xvalues  = [1e10]*2
            # xerr     = [1.0]*2
            # yvalues  = [1e10]*2
            # yerr     = [1.0]*2
            # cdatvec  = np.asarray([0.0]*2)
        else:
            xvalues  = fluxratiodat['f_'+line1][goodent]
            xerr     = fluxratiodat['ferr_'+line1][goodent]
            yvalues  = fluxratiodat['f_'+line2][goodent]
            yerr     = fluxratiodat['ferr_'+line2][goodent]

            xlimits_ent  = np.where(fluxratiodat['s2n_'+line1][goodent] < Nsigma)[0]
            if len(xlimits_ent) > 0:
                xvalues[xlimits_ent] = xerr[xlimits_ent] * Nsigma
                xerr[xlimits_ent]    = +99 # upper limit

            ylimits_ent  = np.where(fluxratiodat['s2n_'+line2][goodent] < Nsigma)[0]
            if len(ylimits_ent) > 0:
                yvalues[ylimits_ent] = yerr[ylimits_ent] * Nsigma
                yerr[ylimits_ent]    = +99 # upper limit

    else:
        plotname = plotbasename+'_lineratios_'+line1+line2+'vs'+line3+line4+\
                   '_Nsigma'+str(Nsigma).replace('.','p')+\
                   '_vshiftLT'+str(vshiftmax).replace('.','p')+'.pdf'

        if ('FR_'+line1+line2 in fluxratiodat.dtype.names) & ('FR_'+line3+line4 in fluxratiodat.dtype.names):
            goodent  = np.where(np.isfinite(fluxratiodat['FR_'+line1+line2]) & np.isfinite(fluxratiodat['FR_'+line3+line4]) &
                                (np.abs(fluxratiodat['vshift_'+line1]) < vshiftmax) &
                                (np.abs(fluxratiodat['vshift_'+line2]) < vshiftmax) &
                                (np.abs(fluxratiodat['vshift_'+line3]) < vshiftmax) &
                                (np.abs(fluxratiodat['vshift_'+line4]) < vshiftmax) &
                                (fluxratiodat['id'].astype(float) < 1e10))[0]

        else:
            goodent  = []

        xlabel   = line1+'/'+line2
        ylabel   = line3+'/'+line4

        if len(goodent) == 0:
            if verbose: print('\n - OLD WARNING No good values found for the plot \n           '+plotname.split('/')[-1]+'\n')
            # goodent  = np.asarray([0,1])
            # xvalues  = [1e10]*2
            # xerr     = [1.0]*2
            # yvalues  = [1e10]*2
            # yerr     = [1.0]*2
            # cdatvec  = np.asarray([0.0]*2)
        else:
            xvalues  = fluxratiodat['FR_'+line1+line2][goodent]
            xerr     = fluxratiodat['FRerr_'+line1+line2][goodent]
            yvalues  = fluxratiodat['FR_'+line3+line4][goodent]
            yerr     = fluxratiodat['FRerr_'+line3+line4][goodent]

            xlimits_ent_num  = np.where((fluxratiodat['s2n_'+line1][goodent] < Nsigma) &
                                        (fluxratiodat['s2n_'+line1][goodent] > 0.0))[0]
            xlimits_ent_den  = np.where((fluxratiodat['s2n_'+line2][goodent] < Nsigma) &
                                        (fluxratiodat['s2n_'+line2][goodent] > 0.0))[0]

            for xent, xval in enumerate(xvalues):
                if (xent in xlimits_ent_num) & (xent in xlimits_ent_den):
                    xvalues[xent]     = np.nan
                    xerr[xent] = 0      # no constraint
                elif (xent in xlimits_ent_num) & (xent not in xlimits_ent_den):
                    xvalues[xent] = xerr[xent] * Nsigma
                    xerr[xent]    = +99 # upper limit
                elif (xent not in xlimits_ent_num) & (xent in xlimits_ent_den):
                    xvalues[xent] = xerr[xent] * Nsigma
                    xerr[xent]    = -99 # lower limit

            ylimits_ent_num  = np.where((fluxratiodat['s2n_'+line3][goodent] < Nsigma) &
                                        (fluxratiodat['s2n_'+line3][goodent] > 0.0))[0]
            ylimits_ent_den  = np.where((fluxratiodat['s2n_'+line4][goodent] < Nsigma) &
                                        (fluxratiodat['s2n_'+line4][goodent] > 0.0))[0]
            for yent, yval in enumerate(yvalues):
                if (yent in ylimits_ent_num) & (yent in ylimits_ent_den):
                    yvalues[yent]   = np.nan
                    yerr[yent]      = 0      # no constraint
                elif (yent in ylimits_ent_num) & (yent not in ylimits_ent_den):
                    yvalues[yent] = yerr[yent] * Nsigma
                    yerr[yent]    = +99 # upper limit
                elif (yent not in ylimits_ent_num) & (yent in ylimits_ent_den):
                    yvalues[yent] = yerr[yent] * Nsigma
                    yerr[yent]    = -99 # lower limit

            if (xerr == 0).all():
                if verbose: print('\n - WARNING all values for '+line1+' and '+line2+' were below '+str(Nsigma)+
                                  'sigma for the plot \n           '+plotname.split('/')[-1]+'\n')
                #return
            if (yerr == 0).all():
                if verbose: print('\n - WARNING all values for '+line3+' and '+line4+' were below '+str(Nsigma)+
                                  'sigma for the plot \n           '+plotname.split('/')[-1]+'\n')
                #return

    if point_text is not None:
        point_textALL = point_text[goodent]
    else:
        point_textALL = point_text

    IDsALL     = fluxratiodat['id'][goodent]
    cdatvecALL = cdatvec[goodent]

    if len(cdatvecALL) == 0: # no objects found in FELIS output
        xvalues = np.array([])
        xerr    = np.array([])
        yvalues = np.array([])
        yerr    = np.array([])

    # - - - - - - - - - Literature - - - - - - - - -
    if (line3 is None) & (line4 is None):
        if ('f_'+line1 in fluxratiodat.dtype.names) & ('f_'+line2 in fluxratiodat.dtype.names):
            litent  = np.where(np.isfinite(fluxratiodat['f_'+line1]) & np.isfinite(fluxratiodat['f_'+line2]) &
                               (fluxratiodat['id'].astype(float) > 1e10))[0]

            if len(litent) > 0:
                xvalues    = np.append(xvalues,fluxratiodat['f_'+line1][litent])
                xerr       = np.append(xerr,fluxratiodat['ferr_'+line1][litent])
                yvalues    = np.append(yvalues,fluxratiodat['f_'+line2][litent])
                yerr       = np.append(yerr,fluxratiodat['ferr_'+line2][litent])
                cdatvecALL = np.append(cdatvecALL,cdatvec[litent])
                IDsALL     = np.append(IDsALL,fluxratiodat['id'][litent])
                if point_text is not None:
                    point_textALL = np.append(point_textALL,point_text[litent])

    else:
        if ('FR_'+line1+line2 in fluxratiodat.dtype.names) & ('FR_'+line3+line4 in fluxratiodat.dtype.names):
            litent  = np.where(np.isfinite(fluxratiodat['FR_'+line1+line2]) & np.isfinite(fluxratiodat['FR_'+line3+line4]) &
                               (fluxratiodat['id'].astype(float) > 1e10))[0]

            if len(litent) > 0:
                xvalues    = np.append(xvalues,fluxratiodat['FR_'+line1+line2][litent])
                xerr       = np.append(xerr,fluxratiodat['FRerr_'+line1+line2][litent])
                yvalues    = np.append(yvalues,fluxratiodat['FR_'+line3+line4][litent])
                yerr       = np.append(yerr,fluxratiodat['FRerr_'+line3+line4][litent])
                cdatvecALL = np.append(cdatvecALL,cdatvec[litent])
                IDsALL     = np.append(IDsALL,fluxratiodat['id'][litent])
                if point_text is not None:
                    point_textALL = np.append(point_textALL,point_text[litent])

    # - - - - - - - - - - - - - - - - - - - - - - - -

    if len(cdatvecALL) == 0:
        if verbose: print('\n - WARNING No good values found for the plot: \n           '+plotname.split('/')[-1]+'\n')
        xvalues    = [1e10]*2
        xerr       = [1.0]*2
        yvalues    = [1e10]*2
        yerr       = [1.0]*2
        cdatvecALL = np.asarray([0.0]*2)

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,
                                                   'dummydat',linetype='onetoone',title=title,ids=IDsALL,
                                                   ylog=True,xlog=True,yrange=yrange,xrange=xrange,
                                                   colortype=cdattype,colorcode=True,cdatvec=cdatvecALL,
                                                   point_text=point_textALL,photoionizationplotparam=photoionizationplotparam,
                                                   histaxes=histaxes,Nbins=Nhistbins,
                                                   overwrite=overwrite,verbose=verbose)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def estimate_EW0(lineratiofile,infofile,outputfile='default', vetfelis_included=None, fixbeta=False, overwrite=False, s2nlimit=3.0,
                 fcontverbose=False, verbose=True):
    """
    Estimate the EWs for the fluxes in a lineratio summary file

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves

    lineratiofile = './all_aperture190926/fluxratios/fluxratios_FELISmatch2uves190926_aperture.txt'
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits'
    EW0data       = uves.estimate_EW0(lineratiofile,infofile,fixbeta=-2.0,overwrite=False)


    """
    if verbose: print(' - Estimating the continuum flux level for each source in \n   '+lineratiofile)
    EW0dic = collections.OrderedDict()
    EW0dic['id'] = np.array([])

    if verbose: print(' - Loading flux ratio data and infofile ')
    infofiledat     = afits.open(infofile)[1].data
    frdatBadFMT     = np.genfromtxt(lineratiofile,skip_header=7,dtype=None,comments='#',names=True)
    fmt             = 'd,12a,'+','.join((len(frdatBadFMT.dtype.names)-2)*['d'])
    fluxratiodatALL = np.genfromtxt(lineratiofile,skip_header=7,dtype=fmt,comments='#',names=True)
    ids             = fluxratiodatALL['id']
    pointings       = fluxratiodatALL['pointing']
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Initializing output ')
    if outputfile == 'default':
        outputfile = lineratiofile.replace('.txt','_EW0estimates.txt')
        if outputfile == lineratiofile:
            sys.exit(' The default output name is the same as the lineratiofile (missing .txt?) which is \n '+lineratiofile)
    if os.path.isfile(outputfile) & (overwrite == False):
        pdb.set_trace()
        sys.exit(' Overwrite=False and the expected output '+outputfile+' already exists so exiting')
    else:
        fout = open(outputfile,'w')
        fout.write('# Estimated rest-frame EWs for the objects and fluxes in \n   '+lineratiofile+'\n')
        fout.write('# Output generated with uves.estimate_EW0() on  '+kbs.DandTstr2()+'\n')
        if fixbeta:
            strout = '# Fixing beta = '+str(fixbeta)+'\n'
            if verbose: print(strout.replace('# ',' - '))
            fout.write(strout)
        else:
            strout = '# Using estimated beta from infofile (if unavailable beta = -2)\n'
            if verbose: print(strout.replace('# ',' - '))
            fout.write(strout)
        fout.write('# EW0 upper(lower) limits are indicated by EW0err = +99(-99) and are '+str(s2nlimit)+'sigma limits. 0s indicate that both line flux and continuum flux were <'+str(s2nlimit)+'sigma \n')

        bandskey = {'F275W':275,'F336W':336,'F435W':435,
                    'F606W':606,'F775W':775,'F814W':814,'F850LP':850,
                    'F105W':105,'F125W':125,'F160W':160}
        fout.write('# The reference continuum band (before extrapolation to line location using beta) is based on the band indicated in the cont_band columns and use the keys: \n# '+str(bandskey)+'\n# \n')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Loading photometric catalogs for continuum estimates')
    catSkeltonGS  = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
    datSkeltonGS  = afits.open(catSkeltonGS)[1].data
    catSkeltonCOS = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
    datSkeltonCOS = afits.open(catSkeltonCOS)[1].data
    catRafelski   = '/Users/kschmidt/work/catalogs/rafelski/uvudf_rafelski_2015.fits'
    datRafelski   = afits.open(catRafelski)[1].data
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    fluxcols = []
    for colname in fluxratiodatALL.dtype.names:
        if colname.startswith('f_'):
            fluxcols.append(colname)
    Nfluxcol   = len(fluxcols)
    outcolumns = '# id  pointing  beta  '+'    '.join([('EW0_'+fc[2:]+' '+'EW0err_'+fc[2:]+' '+'contband_'+fc[2:]) for fc in fluxcols])
    fout.write(outcolumns+'\n')

    EW0array = np.zeros([len(ids),Nfluxcol*3])*np.nan

    if verbose: print(' - Estimating continuum level based on band fluxes and from that EW0 for all lines for object: ')
    betavals = np.zeros(len(ids))
    for ii, id in enumerate(ids):
        if verbose:
            infostr = '   '+str(int(id))+'   ( '+str("%.5d" % (ii+1))+' / '+str("%.5d" % len(ids))+' ) '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        obj_infoent = np.where(infofiledat['id'].astype(int) == int(id))[0]
        redshift    = infofiledat['redshift'][obj_infoent][0]
        for ff, fluxcol in enumerate(fluxcols):
            line_name    = fluxcol[2:]
            line_wave    = uves.linewavesUVES(line_name) * (1.0 + redshift)
            line_flux    = fluxratiodatALL[fluxcol][ii]
            line_fluxerr = fluxratiodatALL[fluxcol.replace('f_','ferr_')][ii]

            if vetfelis_included: # FELIS vetting accounted for meaning fluxes are Nsigma limits already
                if line_fluxerr == 99:
                    line_fluxerr = line_flux / s2nlimit
                else:
                    line_fluxerr = line_fluxerr / s2nlimit

            if np.isfinite(line_flux) & (line_flux > 0):
                if fixbeta:
                    beta    = fixbeta
                else:
                    if infofiledat['beta_linear_many'][obj_infoent] != 0.0:
                        beta  = infofiledat['beta_linear_many'][obj_infoent]
                    else:
                        beta  = -1.92 # beta_own_median from Josie's Cat

                f_conts      = uves.estimate_fcont(infofiledat,obj_infoent,line_wave,fixbeta=beta,
                                                   datSkeltonGS=datSkeltonGS, datSkeltonCOS=datSkeltonCOS, datRafelski=datRafelski,
                                                   verbose=fcontverbose)
                betavals[ii] = beta
                # selecting continuum band to extrapolate from as:
                # The band with effective wavelength closest to the line that does not contain Lya or
                # the line itself and is not from WFC3_UVIS
                bands     = f_conts.keys()
                goodbands = []
                for band in bands:
                    if (band not in ['F275W', 'F336W']) & (f_conts[band] !=  (-99, -99)) & (f_conts[band] !=  (np.nan, np.nan)):
                        goodbands.append(band)

                if len(goodbands) > 0:
                    wavediff  = np.asarray([np.abs(uves.band_waveeff(bb) - line_wave) for bb in goodbands])
                    cont_band = goodbands[np.where(wavediff == np.min(wavediff))[0][0]]

                    f_cont, f_cont_err   = f_conts[cont_band]
                    f_cont_restframe     = f_cont     * (1.0 + redshift)
                    f_cont_err_restframe = f_cont_err * (1.0 + redshift)

                    if (line_flux/line_fluxerr > s2nlimit) & (f_cont/f_cont_err > s2nlimit):
                        EW0array[ii,ff*3]   = line_flux / f_cont_restframe
                        EW0array[ii,ff*3+1] = np.sqrt((line_fluxerr/line_flux)**2 +
                                                      (f_cont_err_restframe/f_cont_restframe)**2) * EW0array[ii,ff*3]
                    elif (line_flux/line_fluxerr <= s2nlimit) & (f_cont/f_cont_err > s2nlimit): # upper limit
                        EW0array[ii,ff*3]   = s2nlimit * line_fluxerr / f_cont_restframe
                        EW0array[ii,ff*3+1] = +99 # indicate that EW0 value is "s2nlimit sigma upper limit"
                    elif (line_flux/line_fluxerr > s2nlimit) & (f_cont/f_cont_err <= s2nlimit): # upper limit
                        EW0array[ii,ff*3]   = line_flux / (s2nlimit * f_cont_err_restframe)
                        EW0array[ii,ff*3+1] = -99 # indicate that EW0 value is "s2nlimit sigma lower limit"
                    else:
                        EW0array[ii,ff*3]   = 0.0
                        EW0array[ii,ff*3+1] = 0.0

                    EW0array[ii,ff*3+2] = bandskey[cont_band.upper()]

        outstr = str(int(id))+' '+pointings[ii]+' '+str("%10.2f" % betavals[ii])+' '+\
                 ' '.join([str("%10.4f" % ff) for ff in EW0array[ii,:]])
        fout.write(outstr.replace('.0000','     ')+' \n')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    fout.close()
    if verbose: print('\n - Wrote the EW0 estimates to \n   '+outputfile)
    fmt = ','.join((2+Nfluxcol*3)*['d'])
    EW0dat = np.genfromtxt(outputfile,skip_header=8,dtype=fmt,comments='#',names=True)
    return EW0dat

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def estimate_fcont(infofiledat,obj_infoent,wavelength,fixbeta=False,photmatchlim=0.5,
                   datSkeltonGS=None, datSkeltonCOS=None, datRafelski=None, verbose=True):
    """
    Estimate the rest-frame continuum flux at a given wavelength for an object in the infofile using the
    observed broad band magnitudes and the beta estimate.

    """
    objid         = infofiledat['id'][obj_infoent][0]
    redshift      = infofiledat['redshift'][obj_infoent][0]
    if fixbeta:
        beta      = fixbeta
    else:
        beta      = infofiledat['beta'][obj_infoent][0]

    if datSkeltonGS is None:
        catSkeltonGS  = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
        datSkeltonGS  = afits.open(catSkeltonGS)[1].data

    if datSkeltonCOS is None:
        catSkeltonCOS = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
        datSkeltonCOS = afits.open(catSkeltonCOS)[1].data

    if datRafelski is None:
        catRafelski   = '/Users/kschmidt/work/catalogs/rafelski/uvudf_rafelski_2015.fits'
        datRafelski   = afits.open(catRafelski)[1].data

    bands         = ['F275W','F336W','F435W','F606W','F775W','F814W','F880LP','F105W','F125W','F160W']

    try:
        bandswithLya  = uves.wavelength_in_bands( 1216 * (redshift + 1))
    except:
        bandswithLya  = uves.wavelength_in_bands( 1216 * (redshift + 1))

    bandswithline = uves.wavelength_in_bands( wavelength )

    f_cont        = {}
    for bb, band in enumerate(bands):
        if verbose: print(' - Getting flux estimate for band '+band)
        if (band not in bandswithLya) & (band not in bandswithline):
            # - - - - - first check infofile for flux estimate - - - - -
            if band in ['F105W','F125W','F160W']:
                hstinst = 'wfc3'
            else:
                hstinst = 'acs'

            try:
                f_ref     = infofiledat[ 'flux_'+hstinst+'_'+band.lower()[1:] ][obj_infoent][0] * 1e20
                f_ref_err = infofiledat[ 'flux_err_'+hstinst+'_'+band.lower()[1:] ][obj_infoent][0] * 1e20
            except:
                f_ref     = 0.0
                f_ref_err = 0.0

            # - - - - - if not there try to get flux from photometric catalogs - - - - -
            if f_ref == 0.0:
                if verbose: print('   was not in the infofile; trying photmetric catalogs')
                if str(objid)[0] in ['6', '7']:
                    phot_id    = infofiledat['id_rafelski'][obj_infoent][0]
                    phot_match = infofiledat['sep_rafelski'][obj_infoent][0]
                    phot_ent   = np.where(datRafelski['id'] == phot_id)[0]

                    if phot_match <= photmatchlim:
                        try:
                            f_cont_jy     =  datRafelski['FLUX_'+band.upper()][phot_ent] * 1e-6
                            f_cont_jy_err =  datRafelski['FLUXERR_'+band.upper()][phot_ent] * 1e-6

                            # ------ from http://www.stsci.edu/~strolger/docs/UNITS.txt: ------
                            # [Y Jy]            = 3.33564095E+04 * [X1 erg/cm^2/s/A] * [X2 A]^2
                            # [Y erg/cm^2/s/A]  = 2.99792458E-05 * [X1 Jy] / [X2 A]^2
                            f_ref     = f_cont_jy     * 2.99792458E-05 / uves.band_waveeff(band)**2.0 / 1e-20
                            f_ref_err = f_cont_jy_err * 2.99792458E-05 / uves.band_waveeff(band)**2.0 / 1e-20
                        except:
                            f_ref     = 0.0
                            f_ref_err = 0.0
                else:
                    if str(objid)[0] in ['1','3','4']:
                        datSkel = datSkeltonGS
                    elif str(objid)[0] in ['2']:
                        datSkel = datSkeltonCOS
                    else:
                        sys.exit(' - No Skelton data for ID = '+str(objid))

                    phot_id    = infofiledat['id_skelton'][obj_infoent][0]
                    phot_match = infofiledat['sep_skelton'][obj_infoent][0]
                    phot_ent   = np.where(datSkel['id'] == phot_id)[0][0]

                    if phot_match <= photmatchlim:
                        try:
                            # magAB    = -2.5*log10(f_nu/Jy) + 8.90    <- https://en.wikipedia.org/wiki/AB_magnitude
                            skelflux   = datSkel['f_'+band.lower()][phot_ent]
                            skelerr    = datSkel['e_'+band.lower()][phot_ent]
                            magAB      = 25.0-2.5*np.log10(skelflux)
                            magABerr   = np.abs(-2.5* np.log10(np.e) / skelflux * skelerr)

                            f_cont_jy      = 10**( (magAB-8.90)/-2.5 )
                            f_cont_jy_err  = np.abs(10**((magAB-8.90)/-2.5) * np.log(10)/-2.5 * magABerr) # deriv. from Schaums 15.28
                            # ------ from http://www.stsci.edu/~strolger/docs/UNITS.txt: ------
                            # [Y Jy]            = 3.33564095E+04 * [X1 erg/cm^2/s/A] * [X2 A]^2
                            # [Y erg/cm^2/s/A]  = 2.99792458E-05 * [X1 Jy] / [X2 A]^2
                            f_ref     = f_cont_jy     * 2.99792458E-05 / uves.band_waveeff(band)**2.0 / 1e-20
                            f_ref_err = f_cont_jy_err * 2.99792458E-05 / uves.band_waveeff(band)**2.0 / 1e-20
                        except:
                            f_ref     = 0.0
                            f_ref_err = 0.0
            else:
                phot_match = 0.0
                if verbose: print('   found flux estimate in infofile')
            # - - - - - if still not available set to NaNs - - - - -
            if f_ref == 0.0:
                if phot_match > photmatchlim:
                    if verbose: print('   Photometric match further than '+str(photmatchlim)+' arcsec from object coordinates.')
                else:
                    if verbose: print('   Hmm; no value in photmetric catalogs either. Returning NaNs')
                f_cont[band] = np.nan, np.nan
            else:
                if verbose: print('   Using flux value to estimate the continuum strength at lambda='+
                                  str(wavelength)+' using beta='+str(beta))
                f_wave       = uves.estimate_continuumlevel_viaBeta(wavelength, uves.band_waveeff(band), f_ref, beta, verbose=False)
                f_wave_err   = f_ref_err * np.abs((wavelength / uves.band_waveeff(band))**beta)
                f_cont[band] = f_wave, f_wave_err
        else:
            if verbose: print('   Band contains either Lya or the wavelength itself, so returning -99s')
            f_cont[band] = -99, -99
    return f_cont

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def band_waveeff(bandname):
    """
    Returning the effective wavelength of an HST band

    """
    #  WFC3-UVIS filters: F225W, F275W, and F336W
    #  ACS-WFC  optical filters: F435W, F606W, F775W, and F850LP
    #  WFC3-IR filters: F105W, F125W, F140W, and F160W
    #
    # effective wavelengths of ACS-WFC, WFC3-UVIS1 and WFC3-IR from
    # http://svo2.cab.inta-csic.es/svo/theory/fps3/index.php?mode=browse&gname=HST&gname2=ACS_WFC
    bands_wavecen = {'F275W':2720.9	,'F336W':3359.4,
                     'F435W':4341.9,'F606W':5810.8,'F775W':7652.5,'F814W':7972.9,'F880LP':9008.7,
                     'F105W':10431.7,'F125W':12364.6,'F160W':15279.1}
    return bands_wavecen[bandname.upper()]

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_EW0estimates(lineratiofile, plotbasename, infofile, EW0file, colorvar_obj='EW_0', point_text=None, showlimits=True,
                      addliteraturevalues=True, ErrNsigma=1.0, vshiftmax=1e5, obj2show='all', xlog=True, ylog=True,
                      lyaEWtype='EW_0_beta_beta2', overwrite=False, verbose=True):
    """
    Function to plot the output containing EW0 estimates generated with uves.estimate_EW0()

    --- INPUT ---


    --- EXAMPLE OF USE ---


    """
    if verbose: print(' - Loading EW data to plot ')
    fluxratiodatALL = np.genfromtxt(lineratiofile,skip_header=7,dtype='d',comments='#',names=True)
    EW0datALL       = np.genfromtxt(EW0file,skip_header=8,dtype='d',comments='#',names=True)

    if obj2show is 'all':
        showent = np.arange(len(fluxratiodatALL))
    elif obj2show.lower() == 'none':
        showent = np.array([0])
    else:
        sample = 'udf10'
        if obj2show is 'goodspec_only':
            ids_badTDOSEspec, ids_goodTDOSEspec = uves.summarize_tdosevetting(sample=sample,verbose=verbose)
            idlist2show = ids_goodTDOSEspec
        elif obj2show is 'badspec_only':
            ids_badTDOSEspec, ids_goodTDOSEspec = uves.summarize_tdosevetting(sample=sample,verbose=verbose)
            idlist2show = ids_badTDOSEspec
        else:
            idlist2show = obj2show

        showent = np.array([])
        for objid in idlist2show:
            objent = np.where( fluxratiodatALL['id'].astype(int) == objid)[0]
            if len(objent) > 0:
                showent = np.append(showent,objent)

    Nselspec    = len(showent)
    if Nselspec > 0:
        fluxratiodat = fluxratiodatALL[showent.astype(int)]
        EW0dat       = EW0datALL[showent.astype(int)]
        if verbose: print(' - '+str(Nselspec)+'/'+str(len(fluxratiodatALL))+
                          ' spectra in flux ratio summary (and EW0 file) satisfies the cuts\n')
    else:
        if verbose: print(' WARNING No flux ratio matches found in summary file satisfying cuts; returning...')
        #return

    # Getting info from infofile
    infofiledat  = afits.open(infofile)[1].data

    LyaEW         = np.zeros(len(fluxratiodat['id']))*np.nan
    LyaEWerr      = np.zeros(len(fluxratiodat['id']))*np.nan

    LyaFWHM       = np.zeros(len(fluxratiodat['id']))*np.nan
    LyaFWHMerr    = np.zeros(len(fluxratiodat['id']))*np.nan

    LyaPeaksep    = np.zeros(len(fluxratiodat['id']))*np.nan
    LyaPeakseperr = np.zeros(len(fluxratiodat['id']))*np.nan

    for ii, id in enumerate(fluxratiodat['id']):
        infoent            = np.where(infofiledat['id'] == int(id))
        LyaEW[ii]          = infofiledat[lyaEWtype+''][infoent]
        LyaEWerr[ii]       = infofiledat[lyaEWtype+'_error'][infoent]
        LyaFWHM[ii]        = infofiledat['fwhm_kms_jk'][infoent]
        LyaFWHMerr[ii]     = infofiledat['fwhm_kms_std_jk'][infoent]
        LyaPeaksep[ii]     = infofiledat['peak_sep_rest_kms'][infoent]
        LyaPeakseperr[ii]  = infofiledat['peak_sep_rest_kms_std'][infoent]

    if colorvar_obj in fluxratiodat.dtype.names:
        cdatvec   = fluxratiodat[colorvar_obj]
    elif colorvar_obj in infofiledat.columns.names:
        cdatvec = np.zeros(len(fluxratiodat['id']))*np.nan
        for ii, id in enumerate(fluxratiodat['id']):
            infoent     = np.where(infofiledat['id'] == int(id))
            cdatvec[ii] = infofiledat[colorvar_obj][infoent]
    else:
        cdatvec = None

    if colorvar_obj.lower() == 's2n_ciii':
        cdattype = 's2n_ciii'
    elif colorvar_obj.lower() == 'redshift':
        cdattype = colorvar_obj.lower()
    elif colorvar_obj.lower() == 'ew_0':
        cdattype = colorvar_obj.lower()

    if point_text is not None:
        point_text = fluxratiodat['id'].astype(str)

    #------------------------------- Append literature measurements -------------------------------
    if addliteraturevalues:
        litcat  = '/Users/kschmidt/work/catalogs/literaturecollection_emissionlinestrengths/' \
                  'literaturecollection_emissionlinestrengths.fits'
        litdat  = afits.open(litcat)[1].data
        # litdat  = np.genfromtxt(litcat,names=True,skip_header=5,comments='#',dtype=None)
        Nlitobj = len(litdat)

        litarr  = np.array(np.zeros(Nlitobj)*np.nan,fluxratiodat.dtype)
        for lo, litobject in enumerate(litdat):
            for litcol in litdat.dtype.names:
                if litcol in fluxratiodat.dtype.names:
                    litarr[litcol][lo] = litdat[litcol][lo]
        fluxratiodat = np.hstack((fluxratiodat,litarr))

        litarr  = np.array(np.zeros(Nlitobj)*np.nan,EW0dat.dtype)
        for lo, litobject in enumerate(litdat):
            for litcol in litdat.dtype.names:
                if litcol in EW0dat.dtype.names:
                    litarr[litcol][lo] = litdat[litcol][lo]
        EW0dat = np.hstack((EW0dat,litarr))

        LyaEW         = np.hstack((LyaEW,        litdat['EW0_Lya']))
        LyaEWerr      = np.hstack((LyaEWerr,     litdat['EW0err_Lya']))

        LyaFWHM       = np.hstack((LyaFWHM,      litdat['sigma_Lya']*2.355))
        LyaFWHMerr    = np.hstack((LyaFWHMerr,   litdat['sigmaerr_Lya']*2.355))

        LyaPeaksep    = np.hstack((LyaPeaksep,   litdat['sigma_Lya']*0.0))
        LyaPeakseperr = np.hstack((LyaPeakseperr,litdat['sigma_Lya']*0.0))

        if colorvar_obj.lower() == 's2n_ciii':
            cdatvec = np.hstack((cdatvec,litdat['s2n_CIII']))
        elif colorvar_obj.lower() == 'redshift':
            cdatvec = np.hstack((cdatvec,litdat['redshift']))
        elif colorvar_obj.lower() == 'ew_0':
            cdatvec = np.hstack((cdatvec,litdat['EW0_Lya']))
        else:
            sys.exit(' Selected color vector not enabled for literature values ')

    #----------------------------------------------------------------------------------------------s

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if ylog:
        EW0_range_y = [0.1,1000]
    else:
        EW0_range_y = [0,40]

    if xlog:
        EW0_range_x = [0.1,1000]
    else:
        EW0_range_x = [0,40]

    if xlog:
        LyaEW_range = [0.1,2000]
    else:
        LyaEW_range = [0,300]

    if xlog:
        LyaPS_range = [0.1,2000]
    else:
        LyaPS_range = [0,1000]


    linesetlist_EWs = []

    for yline in ['CIII','CIV', 'OIII', 'HeII', 'MgII', 'SiIII']: #, 'NV'
        linesetlist_EWs.append([['LyaEW',     'EW$_0$(Ly$\\alpha$) [\AA]',LyaEW,LyaEWerr],
                                yline   ,LyaEW_range, EW0_range_y,   None])
        linesetlist_EWs.append([['LyaFWHM',   'FWHM(Ly$\\alpha$) [km/s]',LyaFWHM,LyaFWHMerr],
                                yline   ,LyaEW_range, EW0_range_y,   None])
        linesetlist_EWs.append([['LyaPeaksep','Ly$\\alpha$ Peak Seperation [km/s]',LyaPeaksep,LyaPeakseperr],
                                yline   ,LyaPS_range, EW0_range_y,   None])

    linesetlist_EWs.append(['CIII','CIV'   ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIII','OIII'  ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIII','HeII'  ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIII','MgII'  ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIII','NV'    ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIII','SiIII' ,EW0_range_x, EW0_range_y,   None])

    linesetlist_EWs.append(['CIV','OIII'   ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIV','HeII'   ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIV','MgII'   ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIV','NV'     ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['CIV','SiIII'  ,EW0_range_x, EW0_range_y,   None])

    linesetlist_EWs.append(['OIII','HeII'  ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['OIII','MgII'  ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['OIII','NV'    ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['OIII','SiIII' ,EW0_range_x, EW0_range_y,   None])

    linesetlist_EWs.append(['HeII','MgII'  ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['HeII','NV'    ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['HeII','SiIII' ,EW0_range_x, EW0_range_y,   None])

    linesetlist_EWs.append(['MgII','NV'    ,EW0_range_x, EW0_range_y,   None])
    linesetlist_EWs.append(['MgII','SiIII' ,EW0_range_x, EW0_range_y,   None])

    linesetlist_EWs.append(['NV','SiIII'   ,EW0_range_x, EW0_range_y,   None])

    Nhistbins = 30
    histaxes  = True
    for lineset in linesetlist_EWs:
        plot_EW0estimates_wrapper(plotbasename,EW0dat,fluxratiodat,lineset,histaxes,Nhistbins,cdatvec,cdattype,
                                  ErrNsigma=ErrNsigma,point_text=point_text,vshiftmax=vshiftmax,
                                  xlog=xlog,ylog=ylog,showlimits=showlimits,overwrite=overwrite,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_EW0estimates_wrapper(plotbasename,EWdat,fluxratiodat,EWset,histaxes,Nhistbins,cdatvec,cdattype,
                              photoionizationplotparam=None,point_text=None,showlimits=True,
                              xlog=True,ylog=True,overwrite=False,ErrNsigma=1.0,vshiftmax=1e4,verbose=True):
    """
    Wrapper to define input data and excecute plot command

    """
    lineEW1,lineEW2,xrange,yrange,title = EWset

    if type(lineEW1) != str:
        str1  = lineEW1[0]
    else:
        str1  = lineEW1

    if type(lineEW2) != str:
        str2 = lineEW2[0]
    else:
        str2 = lineEW2

    plotname = plotbasename+'_EW0_'+str1+'vs'+str2+\
               '_ErrNsigma'+str(ErrNsigma).replace('.','p')+\
               '_vshiftLT'+str(vshiftmax).replace('.','p')+'.pdf'
    if not showlimits:
        plotname = plotname.replace('.pdf','_nolimits.pdf')

    if 'lya' in str1.lower():
        if ('f_'+str2 in fluxratiodat.dtype.names) & showlimits:
            goodent  = np.where(np.isfinite(EWdat['EW0_'+str2]) &  (lineEW1[2] != 0) &  np.isfinite(lineEW1[2]) &
                                np.isfinite(fluxratiodat['f_'+str2]) &
                                (np.abs(fluxratiodat['vshift_'+str2]) < vshiftmax) )[0]
        elif ('f_'+str2 in fluxratiodat.dtype.names) & (not showlimits):
            goodent  = np.where((np.abs(EWdat['EW0err_'+str2]) != 99) & (lineEW1[2] != 0) & np.isfinite(lineEW1[2]) &
                                (EWdat['EW0err_'+str2] != 0) &
                                np.isfinite(EWdat['EW0_'+str2]) &
                                np.isfinite(fluxratiodat['f_'+str2])  &
                                (np.abs(fluxratiodat['vshift_'+str2]) < vshiftmax) )[0]
        else:
            goodent  = []
    elif 'lya' in str2.lower():
        if ('f_'+str1 in fluxratiodat.dtype.names) & showlimits:
            goodent  = np.where(np.isfinite(EWdat['EW0_'+str1]) & (lineEW2[2] != 0) & np.isfinite(lineEW2[2]) &
                                np.isfinite(fluxratiodat['f_'+str1]) &
                                (np.abs(fluxratiodat['vshift_'+str1]) < vshiftmax) )[0]
        elif ('f_'+str1 in fluxratiodat.dtype.names) & (not showlimits):
            goodent  = np.where((np.abs(EWdat['EW0err_'+str1]) != 99) & (lineEW2[2] != 0) & np.isfinite(lineEW2[2]) &
                                (EWdat['EW0err_'+str1] != 0) &
                                np.isfinite(EWdat['EW0_'+str1]) &
                                np.isfinite(fluxratiodat['f_'+str1])  &
                                (np.abs(fluxratiodat['vshift_'+str1]) < vshiftmax) )[0]
        else:
            goodent  = []
    else:
        if ('f_'+str1 in fluxratiodat.dtype.names) & ('f_'+str2 in fluxratiodat.dtype.names) & showlimits:
            goodent  = np.where(np.isfinite(EWdat['EW0_'+str1]) & np.isfinite(EWdat['EW0_'+str2]) &
                                np.isfinite(fluxratiodat['f_'+str1]) & np.isfinite(fluxratiodat['f_'+str2]) &
                                (np.abs(fluxratiodat['vshift_'+str1]) < vshiftmax) &
                                (np.abs(fluxratiodat['vshift_'+str2]) < vshiftmax) )[0]
        elif ('f_'+str1 in fluxratiodat.dtype.names) & ('f_'+str2 in fluxratiodat.dtype.names) & (not showlimits):
            goodent  = np.where((np.abs(EWdat['EW0err_'+str1]) != 99) & (np.abs(EWdat['EW0err_'+str2]) != 99) &
                                (EWdat['EW0err_'+str1] != 0) & (EWdat['EW0err_'+str2] != 0) &
                                np.isfinite(EWdat['EW0_'+str1]) & np.isfinite(EWdat['EW0_'+str2]) &
                                np.isfinite(fluxratiodat['f_'+str1]) & np.isfinite(fluxratiodat['f_'+str2]) &
                                (np.abs(fluxratiodat['vshift_'+str1]) < vshiftmax) &
                                (np.abs(fluxratiodat['vshift_'+str2]) < vshiftmax) )[0]
        else:
            goodent  = []

    if len(goodent) == 0:
        if verbose: print('\n - WARNING No good values found for the plot: \n           '+plotname.split('/')[-1]+'\n')
        goodent  = np.asarray([0,1])
        xvalues  = np.asarray([1e10]*2)
        xerr     = np.asarray([1.0]*2)
        xlabel   = 'EW$_0$('+str1+') [\AA]'
        yvalues  = np.asarray([1e10]*2)
        yerr     = np.asarray([1.0]*2)
        ylabel   = 'EW$_0$('+str2+') [\AA]'
        cdatvec  = np.asarray([0.0]*2)
        IDsALL   = np.asarray([0.0]*2)
    else:
        if 'lya' in str1.lower():
            xlabel   = lineEW1[1]
            xvalues  = lineEW1[2][goodent]
            xerr     = lineEW1[3][goodent]
        else:
            xlabel   = 'EW$_0$('+str1+') [\AA]'
            xvalues  = EWdat['EW0_'+str1][goodent]
            xerr     = EWdat['EW0err_'+str1][goodent]

        if 'lya' in str2.lower():
            ylabel   = lineEW2[1]
            yvalues  = lineEW2[2][goodent]
            yerr     = lineEW2[3][goodent]
        else:
            ylabel   = 'EW$_0$('+str2+') [\AA]'
            yvalues  = EWdat['EW0_'+str2][goodent]
            yerr     = EWdat['EW0err_'+str2][goodent]

        IDsALL = EWdat['id'][goodent]

    xerr[np.abs(xerr) != 99] = xerr[np.abs(xerr) != 99]*ErrNsigma
    yerr[np.abs(yerr) != 99] = yerr[np.abs(yerr) != 99]*ErrNsigma

    if point_text is not None:
        point_text = point_text[goodent]

    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,
                                                   'dummydat',linetype='onetoone',title=title,ids=IDsALL,
                                                   ylog=ylog,xlog=xlog,yrange=yrange,xrange=xrange,
                                                   colortype=cdattype,colorcode=True,cdatvec=cdatvec[goodent],
                                                   point_text=point_text,photoionizationplotparam=photoionizationplotparam,
                                                   histaxes=histaxes,Nbins=Nhistbins,
                                                   overwrite=overwrite,verbose=verbose)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def linenameUVES2NEOGAL(uvesname):
    """
    Translateror between the UVES names of emission lines and the NEOGAL emission line names

    """
    translatedic = {}
    # - - - - - - - UVES -> NEOGAL - - - - - - -
    translatedic['NV']        = 'NV1240'
    translatedic['CIV1']      = 'CIV1549'
    translatedic['CIV']       = 'CIV1550'# Not a NEOGAL column but calculated in uves.add_photoionization_models_to_lineratioplot()
    translatedic['CIV2']      = 'CIV1551'
    translatedic['CIII']      = 'CIII1908'
    translatedic['CIII1']     = 'CIII1907'
    translatedic['CIII2']     = 'CIII1910'
    translatedic['HeII']      = 'HeII1640'
    translatedic['OIII1']     = 'OIII1661'
    translatedic['OIII']      = 'OIII1663'
    translatedic['OIII2']     = 'OIII1666'
    translatedic['SiIII1']    = 'SiIII1883'
    translatedic['SiIII']     = 'SiIII1888'
    translatedic['SiIII2']    = 'SiIII1892'# Not a NEOGAL column but calculated in uves.add_photoionization_models_to_lineratioplot()

    return translatedic[uvesname]
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def linewavesUVES(uvesname):
    """
    Return line wavelength for a UVES line

    """
    linewavedic = {}
    # - - - - - - - UVES -> NEOGAL - - - - - - -
    linewavedic['nv1']       = 1238.821
    linewavedic['nv']        = 1240
    linewavedic['nv2']       = 1242.804
    linewavedic['civ1']      = 1548.195
    linewavedic['civ']       = 1550.00
    linewavedic['civ2']      = 1550.770
    linewavedic['ciii1']     = 1906.68
    linewavedic['ciii']      = 1908.00
    linewavedic['ciii2']     = 1908.73
    linewavedic['heii']      = 1640.420
    linewavedic['oiii1']     = 1660.809
    linewavedic['oiii']      = 1663.00
    linewavedic['oiii2']     = 1666.150
    linewavedic['siiii1']    = 1882.71
    linewavedic['siiii']     = 1888.00
    linewavedic['siiii2']    = 1892.03
    linewavedic['mgii1']     = 2795.528
    linewavedic['mgii']      = 2799.00
    linewavedic['mgii2']     = 2802.705

    return linewavedic[uvesname.lower()]
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def calculatelineratios(outputfile='./fluxratioresults.txt', S2Nmaxrange=[5.0,100.0], zspecrange=[0.0,10.0],
                        voffsetrange=[-1500.0,1500.0], onesigmalimit=100.0, plotdir=None, verbose=True):
    """
    Function to calculate the flux and line ratios for a selection of objects with FELIS template matches
    satisfying a set of criteria based on the FELIS output pickle.

    --- INPUT ---
    outputfile       The ascii file to write results to
    S2Nmaxrange      Range of S/N template matches to unclude
    zspecrange       The range of redshifts for objects to include
    voffsetrange     Estimated velocity offset of line to include
    onesigmalimit    1 sigma flux limit to use for ratio limits (in units of spectra 10.0)
    plotdir          Provide path to output directory, to plot selected tempalte matches.
    verbose          Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.calculatelineratios(outputfile='./fluxratioresults.txt', S2Nmaxrange=[5.0,100.0], zspecrange=[0.0,10.0], voffsetrange=[-1500.0,1500.0], onesigmalimit=100.0)

    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - The estimated line flux ratios will be based on the following FELIS outputs ')
    picklepath  = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/'
    pickleCIII  = picklepath+'MUSEWideLAEs_CCresultsdateofrun_CIII_all575specX180914templates.pkl'
    pickleCIV   = picklepath+'MUSEWideLAEs_CCresultsdateofrun_CIV_all575specX180914templates.pkl'
    pickleHeII  = picklepath+'MUSEWideLAEs_CCresultsdateofrun_HEII_all575specX180914templates.pkl'
    pickleOIII  = picklepath+'MUSEWideLAEs_CCresultsdateofrun_OIII_all575specX180914templates.pkl'
    pickleNV    = picklepath+'MUSEWideLAEs_CCresultsdateofrun_NV_all575specX180914templates.pkl'
    zspecISzLya = False

    if verbose: print('   '+pickleCIII)
    if verbose: print('   '+pickleCIV)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Performing selection on FELIS output ')

    goodkeysCIII    = felis.selection_from_picklefile(pickleCIII, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)
    goodkeysCIV     = felis.selection_from_picklefile(pickleCIV, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)
    goodkeysHeII    = felis.selection_from_picklefile(pickleHeII, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)
    goodkeysOIII    = felis.selection_from_picklefile(pickleOIII, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)
    goodkeysNV      = felis.selection_from_picklefile(pickleNV, S2Nmaxrange=S2Nmaxrange, zspecrange=zspecrange,
                                                    voffsetrange=voffsetrange, zspecISzLya=zspecISzLya)

    goodkeys_unique = np.unique(goodkeysCIV+goodkeysCIII+goodkeysHeII+goodkeysOIII+goodkeysNV)

    loaddicCIII     = felis.load_picklefile(pickleCIII)
    loaddicCIV      = felis.load_picklefile(pickleCIV)
    loaddicHeII     = felis.load_picklefile(pickleHeII)
    loaddicOIII     = felis.load_picklefile(pickleOIII)
    loaddicNV       = felis.load_picklefile(pickleNV)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if os.path.isfile(outputfile):
        sys.exit('Ouptut file '+outputfile+' already exists')

    if verbose: print(' - Initializing the output file '+outputfile)
    fout = open(outputfile,'w')
    fout.write('# Flux and line ratios estimated based on FELIS template match results.\n')
    fout.write('# \n')
    fout.write('# Each template match was narrowed down to only contain matches with \n')
    fout.write('#   - z_spec         :  ['+str(zspecrange[0])+','+str(zspecrange[1])+']\n')
    fout.write('#   - max(S/N)       :  ['+str(S2Nmaxrange[0])+','+str(S2Nmaxrange[1])+']\n')
    fout.write('#   - voffset[km/s]  :  ['+str(voffsetrange[0])+','+str(voffsetrange[1])+']\n')
    fout.write('# \n')
    fout.write('# The selection was performed on the following pickle files outputted by FELIS \n')
    fout.write('#   - CIII: '+pickleCIII+'\n')
    fout.write('#     ('+str(len(goodkeysCIII))+' satisfying the cuts)\n')
    fout.write('#   - CIV: '+pickleCIV+'\n')
    fout.write('#     ('+str(len(goodkeysCIV))+' satisfying the cuts)\n')
    fout.write('#   - HeII: '+pickleHeII+'\n')
    fout.write('#     ('+str(len(goodkeysHeII))+' satisfying the cuts)\n')
    fout.write('#   - OIII: '+pickleOIII+'\n')
    fout.write('#     ('+str(len(goodkeysOIII))+' satisfying the cuts)\n')
    fout.write('#   - NV: '+pickleNV+'\n')
    fout.write('#     ('+str(len(goodkeysNV))+' satisfying the cuts)\n')
    fout.write('# \n')
    fout.write('# In total '+str(len(goodkeys_unique))+' template matches satisfied the cuts and are included in this file \n')
    fout.write('# \n')
    fout.write('# Upper and lower limits are given as negative values with uncertainty of +99 or -99, respectively. \n')
    fout.write('# For the limits a 1sigma limit of '+str(onesigmalimit)+' was used \n')
    fout.write('# \n')
    fout.write('# This file contains the following columns:\n')

    fluxratiodic = collections.OrderedDict()
    fluxratiodic['vshift_AV18']          = 999
    fluxratiodic['vshift_ciii1908']      = 999
    fluxratiodic['vshift_civ1550']       = 999
    fluxratiodic['vshift_heii1640']      = 999
    fluxratiodic['vshift_oiii1663']      = 999
    fluxratiodic['vshift_nv1241']        = 999

    fluxratiodic['f_ciii1908']           = 999
    fluxratiodic['ferr_ciii1908']        = 999
    fluxratiodic['S2N_ciii1908']         = 999
    fluxratiodic['sigma_ciii1908']       = 999

    fluxratiodic['f_civ1550']            = 999
    fluxratiodic['ferr_civ1550']         = 999
    fluxratiodic['S2N_civ1550']          = 999
    fluxratiodic['sigma_civ1550']        = 999

    fluxratiodic['f_heii1640']           = 999
    fluxratiodic['ferr_heii1640']        = 999
    fluxratiodic['S2N_heii1640']         = 999
    fluxratiodic['sigma_heii1640']       = 999

    fluxratiodic['f_oiii1663']           = 999
    fluxratiodic['ferr_oiii1663']        = 999
    fluxratiodic['S2N_oiii1663']         = 999
    fluxratiodic['sigma_oiii1663']       = 999

    fluxratiodic['f_nv1241']             = 999
    fluxratiodic['ferr_nv1241']          = 999
    fluxratiodic['S2N_nv1241']           = 999
    fluxratiodic['sigma_nv1241']         = 999

    fluxratiodic['ciii1907ciii1909']     = 999
    fluxratiodic['ciii1907ciii1909err']  = 999
    fluxratiodic['civ1549civ1551']       = 999
    fluxratiodic['civ1549civ1551err']    = 999
    fluxratiodic['oiii1661oiii1666']     = 999
    fluxratiodic['oiii1661oiii1666err']  = 999
    fluxratiodic['nv1239nv1243']         = 999
    fluxratiodic['nv1239nv1243err']      = 999

    fluxratiodic['civ1550ciii1908']      = 999
    fluxratiodic['civ1550ciii1908err']   = 999
    fluxratiodic['ciii1908heii1640']     = 999
    fluxratiodic['ciii1908heii1640err']  = 999
    fluxratiodic['civ1550heii1640']      = 999
    fluxratiodic['civ1550heii1640err']   = 999
    fluxratiodic['oiii1663heii1640']     = 999
    fluxratiodic['oiii1663heii1640err']  = 999
    fluxratiodic['nv1241heii1640']       = 999
    fluxratiodic['nv1241heii1640err']    = 999
    fluxratiodic['nv1241civ1550']        = 999
    fluxratiodic['nv1241civ1550err']     = 999

    hdrstr = '# id_musewide '
    for col in fluxratiodic.keys():
        hdrstr = hdrstr+col+' '
    hdrstr = hdrstr+'\n'
    fout.write(hdrstr)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Calculating line ratios based on FELIS template matches')
    for goodkey in goodkeys_unique:
        template_ciii1908, vshift_V18_ciii1908, vshift_ciii1908, f_ciii1908, \
        ferr_ciii1908, S2Nmax_ciii1908, Ngoodent_ciii1908, chi2_ciii1908, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicCIII,goodkey)
        template_civ1550, vshift_V18_civ1550, vshift_civ1550, f_civ1550, \
        ferr_civ1550, S2Nmax_civ1550, Ngoodent_civ1550, chi2_civ1550, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicCIV,goodkey)
        template_heii1640, vshift_V18_heii1640, vshift_heii1640, f_heii1640, \
        ferr_heii1640, S2Nmax_heii1640, Ngoodent_heii1640, chi2_heii1640, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicHeII,goodkey)
        template_oiii1663, vshift_V18_oiii1663, vshift_oiii1663, f_oiii1663, \
        ferr_oiii1663, S2Nmax_oiii1663, Ngoodent_oiii1663, chi2_oiii1663, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicOIII,goodkey)
        template_nv1241, vshift_V18_nv1241, vshift_nv1241, f_nv1241, \
        ferr_nv1241, S2Nmax_nv1241, Ngoodent_nv1241, chi2_nv1241, zspec, zS2Nmax = \
            felis.getresult4maxS2N(loaddicNV,goodkey)

        fluxratiodic['vshift_AV18']          = np.max(np.array([vshift_V18_ciii1908, vshift_V18_civ1550,
                                                                vshift_V18_heii1640, vshift_V18_oiii1663,
                                                                vshift_V18_nv1241])) # max to handle -99 values
        fluxratiodic['vshift_ciii1908']      = vshift_ciii1908
        fluxratiodic['vshift_civ1550']       = vshift_civ1550
        fluxratiodic['vshift_heii1640']      = vshift_heii1640
        fluxratiodic['vshift_oiii1663']      = vshift_oiii1663
        fluxratiodic['vshift_nv1241']        = vshift_nv1241


        if template_ciii1908 is 'None':
            f_ciii1908    = -1.0 * onesigmalimit
            ferr_ciii1908 = +99
        if template_civ1550 is 'None':
            f_civ1550     = -1.0 * onesigmalimit
            ferr_civ1550  = +99
        if template_heii1640 is 'None':
            f_heii1640    = -1.0 * onesigmalimit
            ferr_heii1640 = +99
        if template_oiii1663 is 'None':
            f_oiii1663    = -1.0 * onesigmalimit
            ferr_oiii1663 = +99
        if template_nv1241 is 'None':
            f_nv1241      = -1.0 * onesigmalimit
            ferr_nv1241   = +99

        fluxratiodic['f_ciii1908']           = f_ciii1908
        fluxratiodic['ferr_ciii1908']        = ferr_ciii1908
        # fluxratiodic['S2N_ciii1908_calc']    = f_ciii1908/ferr_ciii1908
        fluxratiodic['S2N_ciii1908']         = S2Nmax_ciii1908

        fluxratiodic['f_civ1550']            = f_civ1550
        fluxratiodic['ferr_civ1550']         = ferr_civ1550
        # fluxratiodic['S2N_civ1550_calc']     = f_civ1550/ferr_civ1550
        fluxratiodic['S2N_civ1550']          = S2Nmax_civ1550

        fluxratiodic['f_heii1640']           = f_heii1640
        fluxratiodic['ferr_heii1640']        = ferr_heii1640
        # fluxratiodic['S2N_heii1640_calc']    = f_heii1640/ferr_heii1640
        fluxratiodic['S2N_heii1640']         = S2Nmax_heii1640

        fluxratiodic['f_oiii1663']           = f_oiii1663
        fluxratiodic['ferr_oiii1663']        = ferr_oiii1663
        # fluxratiodic['S2N_oiii1663_calc']    = f_oiii1663/ferr_oiii1663
        fluxratiodic['S2N_oiii1663']         = S2Nmax_oiii1663

        fluxratiodic['f_nv1241']           = f_nv1241
        fluxratiodic['ferr_nv1241']        = ferr_nv1241
        # fluxratiodic['S2N_nv1241_calc']    = f_nv1241/ferr_nv1241
        fluxratiodic['S2N_nv1241']         = S2Nmax_nv1241

        if template_ciii1908 is 'None':
            fluxratiodic['ciii1907ciii1909']    = np.nan
            fluxratiodic['ciii1907ciii1909err'] = np.nan
            fluxratiodic['sigma_ciii1908']      = np.nan
        else:
            fluxratiodic['ciii1907ciii1909']    = float(template_ciii1908.split('fluxratio_')[-1].split('.')[0].replace('p','.'))
            fluxratiodic['ciii1907ciii1909err'] = ferr_ciii1908
            temp_sigma_ciii1908                 = float(template_ciii1908.split('sig_')[-1].split('_')[0].replace('p','.'))
            fluxratiodic['sigma_ciii1908']      = 299792.458 * 2.354 * temp_sigma_ciii1908 / 1908.0

        if template_civ1550 is 'None':
            fluxratiodic['civ1549civ1551']     = np.nan
            fluxratiodic['civ1549civ1551err']  = np.nan
            fluxratiodic['sigma_civ1550']      = np.nan
        else:
            fluxratiodic['civ1549civ1551']     = float(template_civ1550.split('fluxratio_')[-1].split('.')[0].replace('p','.'))
            fluxratiodic['civ1549civ1551err']  = ferr_civ1550
            temp_sigma_civ1550                 = float(template_civ1550.split('sig_')[-1].split('_')[0].replace('p','.'))
            fluxratiodic['sigma_civ1550']      = 299792.458 * 2.354 * temp_sigma_civ1550 / 1550.0

        if template_oiii1663 is 'None':
            fluxratiodic['oiii1661oiii1666']    = np.nan
            fluxratiodic['oiii1661oiii1666err'] = np.nan
            fluxratiodic['sigma_oiii1663']      = np.nan
        else:
            fluxratiodic['oiii1661oiii1666']    = float(template_oiii1663.split('fluxratio_')[-1].split('.')[0].replace('p','.'))
            fluxratiodic['oiii1661oiii1666err'] = ferr_oiii1663
            temp_sigma_oiii1663                 = float(template_oiii1663.split('sig_')[-1].split('_')[0].replace('p','.'))
            fluxratiodic['sigma_oiii1663']      = 299792.458 * 2.354 * temp_sigma_oiii1663 / 1550.0

        if template_nv1241 is 'None':
            fluxratiodic['nv1239nv1243']     = np.nan
            fluxratiodic['nv1239nv1243err']  = np.nan
            fluxratiodic['sigma_nv1241']     = np.nan
        else:
            fluxratiodic['nv1239nv1243']     = float(template_nv1241.split('fluxratio_')[-1].split('.')[0].replace('p','.'))
            fluxratiodic['nv1239nv1243err']  = ferr_nv1241
            temp_sigma_nv1241                = float(template_nv1241.split('sig_')[-1].split('_')[0].replace('p','.'))
            fluxratiodic['sigma_nv1241']     = 299792.458 * 2.354 * temp_sigma_nv1241 / 1550.0

        if template_heii1640 is 'None':
            fluxratiodic['sigma_heii1640']       = np.nan
        else:
            temp_sigma_heii1640                  = float(template_heii1640.split('sig_')[-1].split('.fi')[0].replace('p','.'))
            fluxratiodic['sigma_heii1640']       = 299792.458 * 2.354 * temp_sigma_heii1640 / 1640.0

        fluxratiodic['civ1550ciii1908'], fluxratiodic['civ1550ciii1908err'] = \
            lce.set_ratios(template_civ1550,template_ciii1908,f_civ1550,ferr_civ1550,f_ciii1908,ferr_ciii1908)

        fluxratiodic['ciii1908heii1640'], fluxratiodic['ciii1908heii1640err'] = \
            lce.set_ratios(template_ciii1908,template_heii1640,f_ciii1908,ferr_ciii1908,f_heii1640,ferr_heii1640)

        fluxratiodic['civ1550heii1640'], fluxratiodic['civ1550heii1640err'] = \
            lce.set_ratios(template_civ1550,template_heii1640,f_civ1550,ferr_civ1550,f_heii1640,ferr_heii1640)

        fluxratiodic['oiii1663heii1640'], fluxratiodic['oiii1663heii1640err'] = \
            lce.set_ratios(template_oiii1663,template_heii1640,f_oiii1663,ferr_oiii1663,f_heii1640,ferr_heii1640)

        fluxratiodic['nv1241heii1640'], fluxratiodic['nv1241heii1640err'] = \
            lce.set_ratios(template_nv1241,template_heii1640,f_nv1241,ferr_nv1241,f_heii1640,ferr_heii1640)

        fluxratiodic['nv1241civ1550'], fluxratiodic['nv1241civ1550err'] = \
            lce.set_ratios(template_nv1241,template_civ1550,f_nv1241,ferr_nv1241,f_civ1550,ferr_civ1550)

        outstr = ' '
        outstr = outstr+goodkey.split('-')[-1].split('.')[0][1:]+' '
        for col in fluxratiodic.keys():
            outstr = outstr+str("%12.2f" % fluxratiodic[col])+' '
        outstr = outstr+'\n'
        fout.write(outstr)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Wrote results to '+outputfile)
    fout.close()
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if plotdir is not None:
        if verbose: print(' - plotobjects=True so plotting selections to the directory:\n    '+plotdir)
        goodkeysall = [goodkeysCIII,goodkeysCIV,goodkeysHeII,goodkeysOIII,goodkeysNV]
        picklefiles = [pickleCIII,pickleCIV,pickleHeII,pickleOIII,pickleNV]
        lines = ['CIII1908','CIV1549','HeII1640','OIII1663','NV1241']

        for gg, goodkeys in enumerate(goodkeysall):
            plotnames = []
            plotnameinput = []
            for key in goodkeys:
                fname = key.split('/')[-1]
                plotnameinput.append(key.replace('.fits','_maxS2Ntemplatematch_'+lines[gg]+'.pdf'))
                plotnames.append(plotdir+fname.replace('.fits','_maxS2Ntemplatematch_'+lines[gg]+'.pdf'))

            felis.plot_picklefilecontent(goodkeys, picklefiles[gg], plotdir=plotdir, plotnames=plotnameinput,
                                         showspecerr=False, zspecISzLya=zspecISzLya)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def TDOSE_sourcecat_from_infofile(infofile,outputdir,minRaper=0.5,minCutwidth=4.5,goodmatchsep=0.25,overwrite=False,verbose=True):
    """
    Generate a TDOSE source catatalog (and catalog with intitial guesses for Gaussian modeling) from
    an infofile generated with uves.build_LAEfitstable().
    Based on the MUSEWideUtilities.TDOSE_sourcecat_from_*() scripts

    --- INPUT ---
    infofile          infofile from uves.build_LAEfitstable() to based source catalogs on
    outputdir         location of output
    goodmatchsep      Any match to the photometric catalog below goodmatchsep is replaced by MW object
    overwrite         Overwrite output files if they exists?
    verbose           Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits'
    outputdir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_sourcecatalogs_100fields/'
    uves.TDOSE_sourcecat_from_infofile(infofile,outputdir,minRaper=0.25,minCutwidth=4.5,goodmatchsep=0.25,overwrite=True,verbose=True)

    """
    if verbose: print(' - Generating TDOSE source catalog from the infofile:\n'+infofile+' '
                      '   Restricting source to FoV of individual reference images\n'
                      '   Output will be saved to '+outputdir)

    infodat              = afits.open(infofile)[1].data
    ids_all              = infodat['id']
    ras_all              = infodat['ra']
    decs_all             = infodat['dec']
    aimage_arr_inarcsec  = np.array([])

    skelcosmos     = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
    skelcosmosdat  = afits.open(skelcosmos)[1].data

    skelcdfs       = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
    skelcdfsdat    = afits.open(skelcdfs)[1].data

    rafelskicat    = '/Users/kschmidt/work/catalogs/rafelski/uvudf_rafelski_2015.fits'
    rafelskidat    = afits.open(rafelskicat)[1].data

    imgpath        = '/Users/kschmidt/work/images_MAST/MUSEWidePointings/'
    refimages      = glob.glob(imgpath+'*_814w_*cdfs*.fits')
    refimages      = refimages + glob.glob(imgpath+'*_814w_*cosmos*.fits')
    refimages      = refimages + glob.glob(imgpath+'*_160w_*hudf09*.fits')
    refimages      = refimages + glob.glob(imgpath+'*_775w_*udf-0*rot.fits')
    refimages      = refimages + ['/Users/kschmidt/work/images_MAST/MUSEWidePointings/acs_775w_udf-10_cut.fits']

    for refimage in refimages:
        if '_wht_' in refimage:
            continue
        else:
            if 'udf-' in refimage:
                outputnamebase = outputdir+refimage.split('/')[-1].\
                    replace('acs_775w','tdose_sourcecat_MWuves_acs_775w').replace('.fits','')
            elif 'hudf09' in refimage:
                outputnamebase = outputdir+refimage.split('/')[-1].\
                    replace('wfc3_160w','tdose_sourcecat_MWuves_wfc3_160w').replace('.fits','')
            else:
                outputnamebase = outputdir+refimage.split('/')[-1].\
                    replace('acs_814w','tdose_sourcecat_MWuves_acs_814w').replace('.fits','')

        refimgdata       = afits.open(refimage)[0].data
        refimghdr        = afits.open(refimage)[0].header

        if '-cosmos-' in refimage:
            skeltondat       = skelcosmosdat
        else:
            skeltondat       = skelcdfsdat

        if '_udf-' in refimage:
            match_sep          = infodat['sep_rafelski']
            match_id           = infodat['id_rafelski']
            phot_id_all        = rafelskidat['ID']
            phot_ra_all        = rafelskidat['RA']
            phot_dec_all       = rafelskidat['DEC']
            phot_flux_all      = rafelskidat['FLUX_ISO_F775W']
            phot_theta_all     = rafelskidat['THETA']
            phot_a_image_all   = np.sqrt(rafelskidat['AREAF']/np.pi/(1-rafelskidat['ELLIPTICITY']))
            phot_b_image_all   = (1.0-rafelskidat['ELLIPTICITY'])*phot_a_image_all
            arcsecPerPix_phot  = 0.03
            fivesigma_maglimit = 29.5  # f775w 5sigma limit
            onesigma_flux     = 10**((8.90-fivesigma_maglimit)/2.5) / 5.0 * 1e6 # flux in muJy
        else:
            match_sep          = infodat['sep_skelton']
            match_id           = infodat['id_skelton']
            phot_id_all        = skeltondat['id']
            phot_ra_all        = skeltondat['ra']
            phot_dec_all       = skeltondat['dec']
            phot_flux_all      = skeltondat['f_f160w']
            phot_theta_all     = skeltondat['theta_j2000']
            phot_a_image_all   = skeltondat['a_image']
            phot_b_image_all   = skeltondat['b_image']
            arcsecPerPix_phot  = 0.06
            if '-cosmos-' in refimage:
                fivesigma_maglimit = 25.8  # f160w 5sigma limit COSMOS
            else:
                fivesigma_maglimit = 26.4  # f160w 5sigma limit GOODS-S
            onesigma_flux     = 10**((25-fivesigma_maglimit)/2.5) / 5.

        fluxf_all   = []
        theta_all   = []
        a_image_all = []
        b_image_all = []

        matchedids = []
        for mm, mid in enumerate(match_id):
            MWid = ids_all[mm]
            firstdigit = int(str(MWid)[0])
            if '-cosmos-' in refimage:
                if firstdigit in [2]:
                    includeobj = True
                    if match_sep[mm] < goodmatchsep: matchedids.append(mid)
                else:
                    includeobj = False
            elif '_udf-0' in refimage:
                if firstdigit in [6]: # Include the mosaic full-deth ids; not the MWmock ids (firstdigit=5).
                    includeobj = True
                    if match_sep[mm] < goodmatchsep: matchedids.append(mid)
                else:
                    includeobj = False
            elif '_udf-10' in refimage:
                if firstdigit in [7]:
                    includeobj = True
                    if match_sep[mm] < goodmatchsep: matchedids.append(mid)
                else:
                    includeobj = False
            else:
                if firstdigit in [1,3,4]:
                    includeobj = True
                    if match_sep[mm] < goodmatchsep: matchedids.append(mid)
                else:
                    includeobj = False

            if includeobj:
                if  (match_sep[mm] < goodmatchsep) & (match_sep[mm] > 0.0):
                    phot_ent = np.where(phot_id_all== mid)[0]
                    fluxf_all.append(phot_flux_all[phot_ent][0])
                    theta_all.append(phot_theta_all[phot_ent][0])
                    a_image_all.append(phot_a_image_all[phot_ent][0])
                    b_image_all.append(phot_b_image_all[phot_ent][0])
                else:
                    fluxf_all.append(onesigma_flux)
                    theta_all.append(0.0)
                    a_image_all.append(2.0)
                    b_image_all.append(2.0)

                if len(aimage_arr_inarcsec) == 0:
                    aimage_arr_inarcsec = np.array([str(MWid),str(np.asarray(a_image_all)[-1]*arcsecPerPix_phot)])
                else:
                    aimage_arr_inarcsec = np.vstack([aimage_arr_inarcsec,
                                                     np.array([str(MWid),str(np.asarray(a_image_all)[-1]*arcsecPerPix_phot)])])
            else:
                fluxf_all.append(-99)
                theta_all.append(-99)
                a_image_all.append(-99)
                b_image_all.append(-99)

        # if '_udf-10' in refimage: pdb.set_trace()
        fluxf_all    = np.asarray(fluxf_all)
        theta_all    = np.asarray(theta_all)
        a_image_all  = np.asarray(a_image_all)
        b_image_all  = np.asarray(b_image_all)

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print(' - Finding objects within reference image field-of-view')
        if verbose: print('   (Estimating pixel positions using wcs info from header)')
        striphdr   = tu.strip_header(refimghdr,verbose=verbose,delkeys=['COMMENT','HISTORY','','A_ORDER','B_ORDER'])
        wcs_in     = wcs.WCS(striphdr)
        arcsecPerPix_refimg = wcs.utils.proj_plane_pixel_scales(wcs_in)*60*60

        skycoord   = SkyCoord(ras_all, decs_all, frame='fk5', unit='deg')
        pixcoord   = wcs.utils.skycoord_to_pixel(skycoord,wcs_in,origin=1)
        xpos       = pixcoord[0]
        ypos       = pixcoord[1]
        goodent    = np.where((xpos < refimghdr['NAXIS1']) & (xpos > 0) &
                              (ypos < refimghdr['NAXIS2']) & (ypos > 0) &
                              (a_image_all > 0.0))[0]

        if verbose: print('   (Make sure no 0s exist in a 6x6 pixel region around position, '
                          'i.e., ignoring 0-edges of ref images.)')
        Ngoodinit  = len(goodent)
        intxpos    = np.round(xpos).astype(int)
        intypos    = np.round(ypos).astype(int)
        for ent in goodent:
            if (refimgdata[np.max([intypos[ent]-5,0]):np.min([intypos[ent]+5,refimghdr['NAXIS2']-1]),
                np.max([intxpos[ent]-5,0]):np.min([intxpos[ent]+5,refimghdr['NAXIS1']-1])] == 0).any():
                goodent[np.where(goodent == ent)[0]] = -99
        Nedge     = len(np.where(goodent == -99)[0])
        goodent   = goodent[np.where(goodent != -99)[0]]
        if verbose: print('   (Ended up removing '+str(Nedge)+'/'+str(Ngoodinit)+
                          ' objects that fall in the edge region but are within the image FoV)')

        ids             = ids_all[goodent]
        ras             = ras_all[goodent]
        decs            = decs_all[goodent]
        x_image         = xpos[goodent]
        y_image         = ypos[goodent]
        fluxscale       = fluxf_all[goodent]
        a_image         = a_image_all[goodent] * arcsecPerPix_phot / np.mean(arcsecPerPix_refimg)
        b_image         = b_image_all[goodent] * arcsecPerPix_phot / np.mean(arcsecPerPix_refimg)
        theta           = theta_all[goodent]

        MWidsinfield    = ids
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if verbose: print(' - Add photometric objects around MUSE-Wide objects of interest')

        skycoord   = SkyCoord(phot_ra_all, phot_dec_all, frame='fk5', unit='deg')
        pixcoord   = wcs.utils.skycoord_to_pixel(skycoord,wcs_in,origin=1)
        xpos       = pixcoord[0]
        ypos       = pixcoord[1]
        goodent    = np.where((xpos < refimghdr['NAXIS1']) & (xpos > 0) &
                              (ypos < refimghdr['NAXIS2']) & (ypos > 0) &
                              (phot_a_image_all > 0.0))[0]

        if verbose: print('   (Make sure no 0s exist in a 6x6 pixel region around position, '
                          'i.e., ignoring 0-edges of ref images.)')
        Ngoodinit  = len(goodent)
        intxpos    = np.round(xpos).astype(int)
        intypos    = np.round(ypos).astype(int)
        for ent in goodent:
            if (refimgdata[np.max([intypos[ent]-5,0]):np.min([intypos[ent]+5,refimghdr['NAXIS2']-1]),
                np.max([intxpos[ent]-5,0]):np.min([intxpos[ent]+5,refimghdr['NAXIS1']-1])] == 0).any() or \
                    (phot_id_all[ent] in matchedids):
                goodent[np.where(goodent == ent)[0]] = -99
        Nedge     = len(np.where(goodent == -99)[0])
        goodent   = goodent[np.where(goodent != -99)[0]]
        if verbose: print('   (Ended up removing '+str(Nedge)+'/'+str(Ngoodinit)+
                          ' objects that fall in the edge region but are within the image FoV)')

        ids        = np.append(ids,phot_id_all[goodent])
        ras        = np.append(ras,phot_ra_all[goodent])
        decs       = np.append(decs,phot_dec_all[goodent])
        x_image    = np.append(x_image,xpos[goodent])
        y_image    = np.append(y_image,ypos[goodent])
        fluxscale  = np.append(fluxscale,phot_flux_all[goodent])
        a_image    = np.append(a_image,phot_a_image_all[goodent]* arcsecPerPix_phot / np.mean(arcsecPerPix_refimg))
        b_image    = np.append(b_image,phot_b_image_all[goodent]* arcsecPerPix_phot / np.mean(arcsecPerPix_refimg))
        theta      = np.append(theta,phot_theta_all[goodent])
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        outtxt          = outputnamebase+'.txt'
        if (overwrite == False) & os.path.isfile(outtxt):
            sys.exit('Output ('+outtxt+') already exists and clobber=False')
        else:
            if verbose: print(' - Will save source catalog to '+outtxt+' (overwriting any existing files)')
            fout = open(outtxt,'w')
            fout.write('# TDOSE Source catalog generated with '
                       'uvEmissionlineSearch.TDOSE_sourcecat_from_infofile() on '+kbs.DandTstr2()+'\n')
            fout.write('# see objects with ds9 '+refimage+' -regions '+outputnamebase+'.reg \n')
            fout.write('# parent_id id ra dec x_image y_image fluxscale a_image b_image theta \n')
            for ii, id in enumerate(ids):
                fout.write(str(ids[ii])+' '+str(ids[ii])+' '+str(ras[ii])+' '+str(decs[ii])+' '+
                           str(x_image[ii])+' '+str(y_image[ii])+' '+str(fluxscale[ii])+' '+
                           str(a_image[ii])+' '+str(b_image[ii])+' '+str(theta[ii])+'  \n')

            fout.close()

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            regionfile = outtxt.replace('.txt','.reg')
            if verbose: print(' - Storing DS9 region file to '+regionfile)
            idsstr     = [str(id) for id in ids]
            tu.create_simpleDS9region(regionfile,ras,decs,color='cyan',
                                      circlesize=2.0 * a_image * np.mean(arcsecPerPix_refimg),
                                      textlist=idsstr,clobber=overwrite)
            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            outnamefits = outtxt.replace('.txt','.fits')
            if verbose: print(' - Saving fits version of source catalog to '+outnamefits)
            fitsfmt       = ['D']*10
            sourcecatfits = tu.ascii2fits(outtxt,asciinames=True,skip_header=2,fitsformat=fitsfmt,verbose=verbose)

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            extidcat      = outtxt.replace('.txt','_objects2extract.txt')
            if verbose: print(' - Will save ids of objects to extract in '+extidcat+' (overwriting any existing files)')
            fout = open(extidcat,'w')
            fout.write('# id \n')
            for mm, mwid in enumerate(MWidsinfield):
                fout.write(str(MWidsinfield[mm])+'  \n')
            fout.close()

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Creating cutoutsizes.txt and aperturesizes.txt for the TDOSE extractions along the way ')
    uid, uindex = np.unique(aimage_arr_inarcsec[:,0].astype(int), return_index=True)
    aimage_arr_inarcsec = aimage_arr_inarcsec[uindex,:]

    # ===== CTUOUT SIZES =====
    cut_outtxt  = outputdir+'cutoutsizes_MWuves_4xA_IMAGE.txt'
    fout        = open(cut_outtxt,'w')
    fout.write('# Cutout sizes of 4*A_IMAGE on each side (corresponding to twice the aperture diameter '
               'used for the aperture extractions) estimated with '
               'uvEmissionlineSearch.TDOSE_sourcecat_from_infofile() on '+kbs.DandTstr2()+'\n')
    fout.write('# \n')
    fout.write('# id xsize ysize \n')
    for aa, arrid in enumerate(aimage_arr_inarcsec[:,0]):
        cutoutwidth = 4.0 * float(aimage_arr_inarcsec[aa,1])
        if (cutoutwidth >= 0.0) & (cutoutwidth < minCutwidth):
            cutoutwidth = minCutwidth
        if cutoutwidth > 10.0:
            cutoutwidth = 10.0000

        fout.write(str(arrid)+' '+
                   str(cutoutwidth)+' '+
                   str(cutoutwidth)+'  \n')
    fout.close()

    # ===== APERTURE SIZES =====
    aper_outtxt = outputdir+'apertureradii_MWuves_2xA_IMAGE.txt'
    fout        = open(aper_outtxt,'w')
    fout.write('# Aperturesizes of 2*A_IMAGE estimated with '
               'uvEmissionlineSearch.TDOSE_sourcecat_from_infofile() on '+kbs.DandTstr2()+'\n')
    fout.write('# \n')
    fout.write('# id aperturesize \n')
    for aa, arrid in enumerate(aimage_arr_inarcsec[:,0]):
        Raper_arcsec = 2.0 * float(aimage_arr_inarcsec[aa,1])
        if (Raper_arcsec >= 0.0) & (Raper_arcsec < minRaper):
            Raper_arcsec = minRaper
        fout.write(str(arrid)+' '+str(Raper_arcsec)+'  \n')
    fout.close()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_infofile_nondetections(infofile,goodmatchsep=0.25,outdir=None,magcuts=None,withheader=False,
                               magtocuton=['f814wcand','f160w','f814w','f775w'],verbose=True):
    """
    Generate object id lists of objects from the infofile which are (likely) not detected in the imaging
    and which should therfore be extracted as point sources with the "nondetections" keyword in the TDOSE setup files.

    --- INPUT ---
    infofile          infofile from uves.build_LAEfitstable() to base source catalogs on
    goodmatchsep      Any match to the photometric catalog below goodmatchsep is considered detectable
    outdir            To save results to output ascii files instead of printing IDs to screen provide an output directory
    magcuts           Applying magnitude cuts to the selection. Provide a list of 4 cuts to be applied
                      to [cdfs,cdfs-parallel,cosmos,udf] photometry.
    withheader        TDOSE expects no header in id list, but setting withheader=True will add on with info to each file
                      either way (the summary file always contains a header with the info)
    magtocuton        Corresponding to the magcuts, provide the names of the filters to cut on
    verbose           Toggle verbosity

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits'
    outdir        = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/nondetection_lists/'
    uves.get_infofile_nondetections(infofile,goodmatchsep=0.25,outdir=outdir,magcuts=[27.2,26.4,26.5,29.5],verbose=True) # mag cuts are Skelton and Rafelski 5sigma limiting depths

    """
    if outdir is not None:
        out_summary = outdir+'uves_nondetections_summary.txt'
        fout = open(out_summary,'w')
        fout.write('# List of MUSE ids to treat as non-detections for TDOSE extractions generated with uves.get_infofile_nondetections() on '+kbs.DandTstr2()+'\n')
        fout.write('# Selection based on: \n')
        fout.write('# goodmatchsep                                = '+str(goodmatchsep)+' \n')
        fout.write('# magtocuton[cdfs,cdfs-parallel,cosmos,udf]   = '+str(magtocuton)+' \n')
        fout.write('# magcuts[cdfs,cdfs-parallel,cosmos,udf]      = '+str(magcuts)+' \n# \n')

    infodat        = afits.open(infofile)[1].data

    skelcosmos     = '/Users/kschmidt/work/catalogs/skelton/cosmos_3dhst.v4.1.cats/Catalog/cosmos_3dhst.v4.1.cat.FITS'
    skelcosmosdat  = afits.open(skelcosmos)[1].data

    skelcdfs       = '/Users/kschmidt/work/catalogs/skelton/goodss_3dhst.v4.1.cats/Catalog/goodss_3dhst.v4.1.cat.FITS'
    skelcdfsdat    = afits.open(skelcdfs)[1].data

    rafelskicat    = '/Users/kschmidt/work/catalogs/rafelski/uvudf_rafelski_2015.fits'
    rafelskidat    = afits.open(rafelskicat)[1].data

    pointings      = np.unique(infodat['pointing'])

    if magcuts is None:
        if verbose: print(' - WARNING: No magnitude cuts provided')
        magcuts = [35,35,35,35]
    print(' - Including objects with matches brighter than: \n   [cdfs_'+str(magtocuton[0])+',cdfs-parallels_'+str(magtocuton[1])+',cosmos_'+str(magtocuton[2])+',udf_'+str(magtocuton[3])+'] = '+str(magcuts))

    if verbose & (outdir is None):
        print(' - - - - - - - - - - - - - - - OBJECTS FOR NONDETECTION KEYWORD - - - - - - - - - - - - - - - ')
    for pp, pointing in enumerate(pointings):
        pointingent     = np.where(infodat['pointing'] == pointing)
        ids_point       = infodat['id'][pointingent]
        match_sep_Skel  = infodat['sep_skelton'][pointingent]
        match_id_Skel   = infodat['id_skelton'][pointingent]
        match_sep_Raf   = infodat['sep_rafelski'][pointingent]
        match_id_Raf    = infodat['id_rafelski'][pointingent]

        pointing_nondetections   = []
        pointing_nondetections_s = []  # seperate list for UDF skelton objects
        for ii, museid in enumerate(ids_point):

            # magcuts = [cdfs,cdfs-parallel,cosmos,udf,udf10]
            if 'cdfs' in pointing:
                match_id  = match_id_Skel[ii]
                match_sep = match_sep_Skel[ii]
                phot_ent  = np.where(skelcdfsdat['id'] == match_id)[0]
                phot_mag  = 25.0 - 2.5**np.log10(skelcdfsdat['f_'+magtocuton[0]][phot_ent])
                mag_cut   = magcuts[0]

            elif 'hudf09' in pointing:
                match_id  = match_id_Skel[ii]
                match_sep = match_sep_Skel[ii]
                phot_ent  = np.where(skelcdfsdat['id'] == match_id)[0]
                phot_mag  = 25.0 - 2.5**np.log10(skelcdfsdat['f_'+magtocuton[1]][phot_ent])
                mag_cut   = magcuts[1]

            elif 'cosmos' in pointing:
                match_id  = match_id_Skel[ii]
                match_sep = match_sep_Skel[ii]
                phot_ent  = np.where(skelcosmosdat['id'] == match_id)[0]
                phot_mag  = 25.0 - 2.5*np.log10(skelcosmosdat['f_'+magtocuton[2]][phot_ent])
                mag_cut   = magcuts[2]

            elif ('mosaic' in pointing) or ('udf-' in pointing):
                match_id  = match_id_Raf[ii]
                match_sep = match_sep_Raf[ii]
                phot_ent  = np.where(rafelskidat['ID'] == match_id)[0]
                phot_mag  = rafelskidat['MAG_'+magtocuton[1].upper()][phot_ent]
                mag_cut   = magcuts[3]

                match_id_s  = match_id_Skel[ii]
                match_sep_s = match_sep_Skel[ii]
                phot_ent_s  = np.where(skelcdfsdat['id'] == match_id_s)[0]
                phot_mag_s  = 25.0 - 2.5**np.log10(skelcdfsdat['f_'+magtocuton[0]][phot_ent_s])
                mag_cut_s   = magcuts[0]

            else:
                sys.exit(' The pointing '+pointing+' was not recognised')


            if match_sep > goodmatchsep:
                pointing_nondetections.append(museid)
            else:
                if phot_mag > mag_cut:
                    pointing_nondetections.append(museid)

            if ('mosaic' in pointing) or ('udf-' in pointing):
                if match_sep_s > goodmatchsep:
                    pointing_nondetections_s.append(museid)
                else:
                    if phot_mag_s > mag_cut_s:
                        pointing_nondetections.append(museid)

        if verbose & (outdir is None):
            print('   '+str("%30s" % pointing)+' (Nobj='+str("%5i" % len(pointing_nondetections))+
                  ')  '+str(pointing_nondetections))

            if ('mosaic' in pointing) or ('udf-' in pointing):
                if verbose: print('   '+str("%30s" % (pointing+'_SKELTON'))+' (Nobj='+str("%5i" % len(pointing_nondetections_s))+
                                  ')  '+str(pointing_nondetections_s))
        else:
            fout.write('   '+str("%30s" % pointing)+' (Nobj='+str("%5i" % len(pointing_nondetections))+
                       ')  '+str(pointing_nondetections)+'\n')

            if ('mosaic' in pointing) or ('udf-' in pointing):
                fout.write('   '+str("%30s" % (pointing+'_SKELTON'))+' (Nobj='+str("%5i" % len(pointing_nondetections_s))+
                           ')  '+str(pointing_nondetections_s)+'\n')

        out_pointing = outdir+'uves_nondetections_'+pointing+'.txt'
        fout_p = open(out_pointing,'w')
        if withheader:
            fout_p.write('# List of MUSE ids to treat as non-detections for TDOSE extractions generated with uves.get_infofile_nondetections() on '+kbs.DandTstr2()+'\n')
            fout_p.write('# Selection based on: \n')
            fout_p.write('# goodmatchsep           = '+str(goodmatchsep)+' \n')
        if 'cdfs' in pointing:
            if withheader:
                fout_p.write('# magtocuton[cdfs]   = '+str(magtocuton[0])+' \n')
                fout_p.write('# magcuts[cdfs]      = '+str(magcuts[0])+' \n# \n')
            for nonid in pointing_nondetections: fout_p.write(str(nonid)+'\n')
        elif 'hudf09' in pointing:
            if withheader:
                fout_p.write('# magtocuton[cdfs-parallel]   = '+str(magtocuton[1])+' \n')
                fout_p.write('# magcuts[cdfs-parallel]      = '+str(magcuts[1])+' \n# \n')
            for nonid in pointing_nondetections: fout_p.write(str(nonid)+'\n')
        elif 'cosmos' in pointing:
            if withheader:
                fout_p.write('# magtocuton[cosmos]   = '+str(magtocuton[2])+' \n')
                fout_p.write('# magcuts[cosmos]      = '+str(magcuts[2])+' \n# \n')
            for nonid in pointing_nondetections: fout_p.write(str(nonid)+'\n')
        elif ('mosaic' in pointing) or ('udf-' in pointing):
            if withheader:
                fout_p.write('# magtocuton[udf]   = '+str(magtocuton[3])+' \n')
                fout_p.write('# magcuts[udf]      = '+str(magcuts[3])+' \n# \n')
            for nonid in pointing_nondetections: fout_p.write(str(nonid)+'\n')

            out_pointing_skelton = outdir+'uves_nondetections_'+pointing+'_skeltonbased.txt'
            fout_pS = open(out_pointing_skelton,'w')
            if withheader:
                fout_pS.write('# List of MUSE ids to treat as non-detections for TDOSE extractions generated with uves.get_infofile_nondetections() on '+kbs.DandTstr2()+'\n')
                fout_pS.write('# Selection based on: \n')
                fout_pS.write('# goodmatchsep           = '+str(goodmatchsep)+' \n')
                fout_pS.write('# magtocuton[udf]   = '+str(magtocuton[3])+' \n')
                fout_pS.write('# magcuts[udf]      = '+str(magcuts[3])+' \n# \n')
            for nonid in pointing_nondetections_s: fout_pS.write(str(nonid)+'\n')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def build_noise_spectrum(outfile='/Users/kschmidt/work/MUSE/spectra_noise/median_eff_noise_spectrum_RENAME.fits',
                         overwrite=False,verbose=True):
    """
    Build a median noise spectrum for the MUSE-Wide fields

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.build_noise_spectrum(outfile='/Users/kschmidt/work/MUSE/median_eff_noise_spectrum.fits')

    """
    if os.path.isfile(outfile) & (not overwrite):
        sys.exit(' - The output file '+outfile+' exists and overwrite=False')

    #### UDF ####
    # datacubes = glob.glob('/Users/kschmidt/work/MUSE/QtClassify/*/udf-*_mfs-and-effvar-cube.fits')
    # noiseext  = 'EFFVAR'
    # waveunits = 'Angstrom'
    # fluxunits = '1e-20 erg/s/cm2/A'

    #### CDFS/COSMOS MUSE-Wide ####
    datacubes = glob.glob('/Volumes/DATABCKUP1/MUSE-Wide/DATACUBES/DATACUBE_candels-*_v1.0_dcbgc_effnoised.fits')
    noiseext  = 'EFF_STAT'
    waveunits = 'Angstrom'
    fluxunits = '1e-20 erg/s/cm2/A'

    if verbose: print(' - Generating median vec for: ')
    for dd, cube in enumerate(datacubes):
        if verbose: print('   '+cube+'  (spec '+str(dd+1)+'/'+str(len(datacubes))+')')
        effstatarr = afits.open(cube)[noiseext].data
        mediannoisevec = np.sqrt(np.nanmedian(np.nanmedian(effstatarr[:,150:250,150:250],axis=1),axis=1))
        if dd == 0:
            noisearr               = mediannoisevec
            cubehdr_0              = afits.open(cube)[noiseext].header
            wavevec_0              = np.arange(cubehdr_0['NAXIS3'])*cubehdr_0['CD3_3']+cubehdr_0['CRVAL3']
        else:
            cubehdr                = afits.open(cube)[noiseext].header
            wavevec                = np.arange(cubehdr['NAXIS3'])*cubehdr['CD3_3']+cubehdr['CRVAL3']
            func                   = scipy.interpolate.interp1d(wavevec,mediannoisevec,kind='linear',fill_value="extrapolate")
            mediannoisevec_interp  = func(wavevec_0)

            noisearr  = np.vstack([noisearr,mediannoisevec_interp])

    noisevec = np.nanmedian(noisearr,axis=0)

    felis.save_spectrum(outfile,wavevec,noisevec,noisevec*0.0,
                        headerinfo=None,waveunits=waveunits,fluxunits=fluxunits,
                        overwrite=overwrite,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def strip_cube_from_spectra(specdir,outputdir,overwrite=False,verbose=True):
    """
    Remoce source cube extension from spectra.

    --- INPUT ---
    specdir            Directory containing spectra to strip soource cube extension from
    outputdir          Directory to store the stripped spectra to.
    overwrite          Overwrite output if it already exists.
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    outputdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/spectra_aperture/'
    specdir   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/spectra_test/original/'

    uves.strip_cube_from_spectra(specdir,outputdir,overwrite=False,verbose=True)

    """
    spectra   = glob.glob(specdir+'tdose_spectrum_*.fits')
    for spectrum in spectra:
        tu.strip_extension_from_fitsfile(spectrum,outputdir,removeextension='SOURCECUBE',overwrite=overwrite,verbose=verbose)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def checkfluxscales(specWnoise=True):
    """
    function to check conversion of output flux scales to integrated line fluxes


    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.checkfluxscales()

    """
    Nsigma  = 3.0

    testdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStesting/felistest190910/'
    if specWnoise:
        noisestr = 'noisespec'
        pklfile  = testdir+ 'uves_mock_spectrum_fromsetup_CIIIdoublet_noisespec_sigma2p00_skew0p00_' \
                            'Ftot1028p57_Fratio1p40_z2p70_CCresults_templateCIII_matchto_spectrumCIIIdoublet.pkl'
    else:
        noisestr = 'noisestdNone'
        pklfile  = testdir+ 'uves_mock_spectrum_fromsetup_CIIIdoublet_noisestdNone_sigma2p00_skew0p00_' \
                            'Ftot1028p57_Fratio1p40_z2p70_CCresults_templateCIII_matchto_spectrumCIIIdoublet.pkl'

    loaddic  = felis.load_picklefile(pklfile)
    spectrum = loaddic.keys()[0]

    template, vshift_intr, vshift_match, alpha, alphaerr, S2Nmax, Ngoodent, chi2, zspec, zS2Nmax = \
        felis.getresult4maxS2N(loaddic,spectrum,zspecISzLya=False)

    # - - - - - - - - - - - Load spec and temp info - - - - - - - - - - - - -
    specdat   = afits.open(spectrum)[1].data
    spechdr   = afits.open(spectrum)[1].header
    sigma_obs = spechdr['FLINE1_2']
    fluxline1 = spechdr['FLINE1_4']
    fluxline2 = spechdr['FLINE2_4']
    fluxratio = fluxline1/fluxline2

    threesigma_obs = sigma_obs * Nsigma
    wavemin = spechdr['FLINE1_1']-threesigma_obs
    wavemax = spechdr['FLINE2_1']+threesigma_obs

    tempdat = afits.open(template)[1].data
    temphdr = afits.open(template)[1].header
    temp_sigma     = temphdr['FLINE1_2']
    temp_fluxline1 = temphdr['FLINE1_4']
    temp_fluxline2 = temphdr['FLINE2_4']
    temp_fluxratio = temp_fluxline1/temp_fluxline2

    threesigma_rf = temp_sigma * Nsigma
    wavemin_rf = spechdr['FLINE1_1']/(1.0+zspec)-threesigma_rf
    wavemax_rf = spechdr['FLINE2_1']/(1.0+zspec)+threesigma_rf
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    specent   = np.where((specdat['wave'] > wavemin) & (specdat['wave'] < wavemax))[0]
    tempent   = np.where((tempdat['wave'] > wavemin_rf) & (tempdat['wave'] < wavemax_rf))[0]

    print(' --------- Observed frame: ----------')
    Ftot_spec_full = np.sum(specdat['flux'])*np.median(np.diff(specdat['wave']))
    Ftot_temp_full = np.sum(tempdat['flux']/(1+zspec))*np.median(np.diff(tempdat['wave']*(1+zspec)))
    print('Ftot_spec_full      = '+str(Ftot_spec_full))
    print('Ftot_temp_full      = '+str(Ftot_temp_full))

    Ftot_spec_cut = np.sum(specdat['flux'][specent])*np.median(np.diff(specdat['wave'][specent]))
    Ftot_temp_cut = np.sum(tempdat['flux'][tempent]/(1+zspec))*np.median(np.diff(tempdat['wave'][tempent]*(1+zspec)))
    print('Ftot_spec_cut       = '+str(Ftot_spec_cut))
    print('Ftot_temp_cut       = '+str(Ftot_temp_cut))

    Ftot_spec_cut_trapz = np.trapz(specdat['flux'][specent],specdat['wave'][specent])
    Ftot_temp_cut_trapz = np.trapz(tempdat['flux'][tempent]/(1+zspec),tempdat['wave'][tempent]*(1+zspec))
    print('Ftot_spec_cut_trapz = '+str(Ftot_spec_cut_trapz))
    print('Ftot_temp_cut_trapz = '+str(Ftot_temp_cut_trapz))

    #
    # print(' --------- Rest frame: ----------')
    # Ftot_spec_full = np.sum(specdat['flux']*(1+zspec))*np.median(np.diff(specdat['wave']/(1+zspec)))
    # Ftot_temp_full = np.sum(tempdat['flux'])*np.median(np.diff(tempdat['wave']))
    # Ftot_spec_cut = np.sum(specdat['flux'][specent]*(1+zspec))*np.median(np.diff(specdat['wave'][specent]/(1+zspec)))
    # Ftot_temp_cut = np.sum(tempdat['flux'][tempent])*np.median(np.diff(tempdat['wave'][tempent]))
    # print('Ftot_spec_full = '+str(Ftot_spec_full))
    # print('Ftot_temp_full = '+str(Ftot_temp_full))
    # print('Ftot_spec_cut = '+str(Ftot_spec_cut))
    # print('Ftot_temp_cut = '+str(Ftot_temp_cut))

    print(' --------- Values from headers: ----------')
    template_scaled               = tempdat['flux'] / (temp_fluxline1+temp_fluxline2) * alpha
    print('alpha +/- alphaerr     = '+str(alpha)+' +/- '+str(alphaerr))
    print('spec total flux        = '+str(fluxline1+fluxline2))
    print('temp total flux        = '+str(temp_fluxline1+temp_fluxline2))
    print('spec flux ratio        = '+str(fluxratio))
    print('temp flux ratio        = '+str(temp_fluxratio))

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    print(' --------- Plotting overview: ----------')
    import matplotlib.pyplot as plt
    fig = plt.figure(figsize=(6, 3))
    fig.subplots_adjust(wspace=0.1, hspace=0.3,left=0.1, right=0.97, bottom=0.10, top=0.95)
    Fsize    = 12
    lthick   = 2
    marksize = 4
    plt.rc('text', usetex=True)
    plt.rc('font', family='serif',size=Fsize)
    plt.rc('xtick', labelsize=Fsize)
    plt.rc('ytick', labelsize=Fsize)
    plt.clf()
    plt.ioff()

    plt.plot(specdat['wave'],specdat['flux'],color='gray')
    plt.plot(tempdat['wave']*(1+zspec),template_scaled/(1+zspec),color='pink')

    plt.plot([wavemin,wavemin],[np.min(specdat['flux'][specent]),np.max(specdat['flux'][specent])],color='k',ls=':')
    plt.plot([wavemax,wavemax],[np.min(specdat['flux'][specent]),np.max(specdat['flux'][specent])],color='k',ls=':')
    plt.plot(specdat['wave'][specent],specdat['flux'][specent],color='k')

    plt.plot([wavemin_rf*(1+zspec),wavemin_rf*(1+zspec)],
             [np.min(template_scaled[tempent]/(1+zspec)),np.max(template_scaled[tempent]/(1+zspec))],color='red',ls=':')
    plt.plot([wavemax_rf*(1+zspec),wavemax_rf*(1+zspec)],
             [np.min(template_scaled[tempent]/(1+zspec)),np.max(template_scaled[tempent]/(1+zspec))],color='red',ls=':')
    plt.plot(tempdat['wave'][tempent]*(1+zspec),tempdat['flux'][tempent]/(1+zspec),color='green')

    plt.plot(tempdat['wave'][tempent]*(1+zspec),template_scaled[tempent]/(1+zspec),color='red')
    plt.ylim([-50,140])

    plotname = testdir+'fluxscalecheck_'+noisestr+'.pdf'
    plt.savefig(plotname)
    # plt.savefig('/Users/kschmidt/Desktop/fluxscalecheck_'+noisestr+'.pdf')
    print('Saved plot to '+plotname)
    plt.clf()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_UDF10masedaobjcomparison(gaussspec=False,overwrite=False,verbose=True):
    """
    plotting information on FELIS match to Maseda UDF-10 CIII emitters

    --- INPUT ---
    overwrite          Overwrite the plots if they already exist?
    verbose            Toggle verbosity

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves
    uves.plot_UDF10masedaobjcomparison(gaussspec=True,overwrite=True)
    uves.plot_UDF10masedaobjcomparison(gaussspec=False,overwrite=True)

    """
    Nsigmaplot   = 3.0 # the size of the error bars to show
    outdir       = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/CCresults_summary/'

    summaryfile  = outdir+'CCresults_summary_templateCIII_FELISmatch2udf10masedaobj190913.txt'
    if gaussspec:
        summaryfile = summaryfile.replace('.txt','_gauss.txt')
    fmt          = 'd,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
    summarydat   = np.genfromtxt(summaryfile,skip_header=24,dtype=fmt,comments='#',names=True)
    sortindex_S  = np.argsort(summarydat['id'])
    Nspecin      = len(summarydat['spectrum'])

    masedainfo   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/masedaUDF10emitters.txt'
    fmt          = '12a,d,d,d,d,d,d,d,d,d,d,d'
    masedadat    = np.genfromtxt(masedainfo,skip_header=1,dtype=fmt,comments='#',names=True)
    sortindex_M  = np.argsort(masedadat['id_uves'])

    plotbasename = outdir+'UDF10_CIIIemitters_Maseda17comparison'
    if verbose: print(' - Plotting FELIS matches in summary file\n   '+summaryfile+'\n   where the following holds:')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext    = 'Comparison_onetoone_Fciii'
    plotname   = plotbasename+nameext+'.pdf'
    if gaussspec:
        plotname = plotname.replace('.pdf','_gauss.pdf')
    xvalues    = masedadat['f_ciii'][sortindex_M]
    xerr       = masedadat['df_ciii'][sortindex_M]*Nsigmaplot
    yvalues    = summarydat['Ftot_FELIS_S2Nmax'][sortindex_S]
    yerr       = summarydat['Ftot_FELIS_S2Nmax_err'][sortindex_S]*Nsigmaplot
    xlabel     = 'Flux(CIII,Maseda)'
    ylabel     = 'Flux(CIII,FELIS)'
    point_text = (summarydat['id'][sortindex_S].astype(int)).astype(str)


    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,'DUMMY-summarydat',
                                                   histaxes=True,Nbins=30,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][sortindex_S],
                                                   linetype='onetoone',point_text=point_text,
                                                   xlog=True,ylog=True,xrange=[10,1200],yrange=[10,1200],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext    = 'Comparison_horizontal_FciiiVSz'
    plotname   = plotbasename+nameext+'.pdf'
    if gaussspec:
        plotname = plotname.replace('.pdf','_gauss.pdf')
    xvalues    = summarydat['z_temp_S2Nmax'][sortindex_S]
    xerr       = [None]*len(xvalues)
    yvalues    = (summarydat['Ftot_FELIS_S2Nmax'][sortindex_S]/masedadat['f_ciii'][sortindex_M]) - 1
    yerr       = np.sqrt((summarydat['Ftot_FELIS_S2Nmax_err'][sortindex_S] /
                          summarydat['Ftot_FELIS_S2Nmax'][sortindex_S])**2.0+
                         (masedadat['df_ciii'][sortindex_M] /
                          masedadat['f_ciii'][sortindex_M])**2.0) * Nsigmaplot
    xlabel     = '$z$(FELIS)'
    ylabel     = '[Flux(CIII,FELIS)-Flux(CIII,Maseda)] - 1'
    point_text = (summarydat['id'][sortindex_S].astype(int)).astype(str)


    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,'DUMMY-summarydat',
                                                   histaxes=True,Nbins=30,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][sortindex_S],
                                                   linetype='horizontal',point_text=point_text,
                                                   xlog=False,ylog=False,xrange=[1.0,3.0],yrange=[-0.5,0.5],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    nameext    = 'Comparison_horizontal_FciiiVSsigma'
    plotname   = plotbasename+nameext+'.pdf'
    if gaussspec:
        plotname = plotname.replace('.pdf','_gauss.pdf')
    xvalues    = summarydat['sigma_temp_ang_rf'][sortindex_S]
    xerr       = [None]*len(xvalues)
    yvalues    = (summarydat['Ftot_FELIS_S2Nmax'][sortindex_S]/masedadat['f_ciii'][sortindex_M]) - 1
    yerr       = np.sqrt((summarydat['Ftot_FELIS_S2Nmax_err'][sortindex_S] /
                          summarydat['Ftot_FELIS_S2Nmax'][sortindex_S])**2.0+
                         (masedadat['df_ciii'][sortindex_M]/
                          masedadat['f_ciii'][sortindex_M])**2.0) * Nsigmaplot
    xlabel     = '$\sigma$(FELIS)'
    ylabel     = '[Flux(CIII,FELIS)-Flux(CIII,Maseda)] - 1'
    point_text = (summarydat['id'][sortindex_S].astype(int)).astype(str)


    uves.plot_mocspecFELISresults_summary_plotcmds(plotname,xvalues,yvalues,xerr,yerr,xlabel,ylabel,'DUMMY-summarydat',
                                                   histaxes=True,Nbins=30,
                                                   colortype='s2nfelis',cdatvec=summarydat['FELIS_S2Nmax'][sortindex_S],
                                                   linetype='horizontal',point_text=point_text,
                                                   xlog=False,ylog=False,xrange=[0.2,0.8],yrange=[-0.5,0.5],
                                                   colorcode=True,overwrite=overwrite,verbose=verbose)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_FELISmatches(objectids,pickledir,summaryfiles,outputdir,S2Nmin=3.0,vshiftmax=1e4,
                      plot_overview=False,skipplotting=False,
                      verbose=True,verboseplots=False):
    """
    Wrapper to search for objects with line detections and then plot
    the corresponding FELIS template overview.

    --- INPUT ---
    objectids          The ids of the objects to check and plot. Either provide a list or a "glob string" to append pickledir.
    pickledir          The picklefiles to plot information from. Generated with uves.match_tdosespectra_to_templates()
    summaryfiles       The summaryfile generate with uves.gen_tdosespecFELISresults_summary()
    outputdir          Directory to store plots in
    S2Nmin             Minimum FELIS S2N of line match to plot results for
    vshiftmax          Maximum velocity shift of line match to plot results for
    plot_overview      Plot the overview of the spectrum with zoom-in on lines using mwp.
    verbose            Toggle verbosity
    verboseplots       Toggle verbosity of plotting functions

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    parentdir   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/'
    objectids   = '7201*'
    summaryfile = glob.glob(parentdir+'CCresults_summary/CCresults_summary_template*_FELISmatch2udf10_190913.txt')
    outputdir   = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/FELISmatches_plots/'
    uves.plot_FELISmatches(objectids,parentdir,summaryfile,outputdir,S2Nmin=3.0,plot_overview=True)

    """

    if type(objectids) is str:
        pfiles    = glob.glob(pickledir+'*'+objectids+'*.pkl')
        idlist    = [int(pfile.split('_CCresults_')[0].split('_')[-1]) for pfile in pfiles]
        objidlist = np.unique(np.asarray(idlist))
    else:
        objidlist = np.unique(np.asarray(objectids))

    if verbose: print('# - Loading the data of the '+str(len(summaryfiles))+' summary files into memory')
    summarfiledat_dic = {}
    for summaryfile in summaryfiles:
        fmt                             = '12a,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,200a,200a'
        summarfiledat_dic[summaryfile]  = np.genfromtxt(summaryfile,skip_header=25,dtype=fmt,comments='#',names=True)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print('# - Looping over the '+str(len(objidlist))+
                      ' (unique) object IDs to look for FELIS matches with S/N(FELIS) > '+str(S2Nmin)+
                      ' and vshift < '+str(vshiftmax)+' km/s ')
    matchcount = 0
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    for oo, objid in enumerate(objidlist):
        if verbose & (not skipplotting): print('---- Checking object  '+str(objid)+' ----')
        NlinesMatchCuts  = 0 # keeping track of number of lines above threshold
        zobj             = np.array([])
        matchline        = np.array([])
        pfilenumber      = np.array([])
        pointings        = np.array([])
        spectra          = np.array([])
        templates        = np.array([])
        matchS2N         = np.array([])
        vshift           = np.array([])
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        for summaryfile in summaryfiles:
            summarydat       = summarfiledat_dic[summaryfile]
            objsummary_ent   = np.where(summarydat['id'].astype(int) == objid)[0]
            zobj             = np.append(zobj,summarydat['z_spec'][objsummary_ent])
            linesummarized   = summaryfile.split('_template')[-1].split('_')[0]
            outkeystr        = summaryfile.split('_template'+linesummarized)[-1].split('.txt')[0]

            if len(objsummary_ent) != 0:
                if len(objsummary_ent) > 1:
                    if verbose & (not skipplotting):
                        print('     NOTE: Found '+str(len(objsummary_ent))+
                              ' spectra (template matches) in '+linesummarized+' summaryfile ')

                picklefiles = glob.glob(pickledir+'*'+str(objid)+'*template'+linesummarized+'*'+outkeystr+'*.pkl')
                for pp, pfile in enumerate(picklefiles):
                    spec             = summarydat['spectrum'][objsummary_ent[pp]]
                    pfilenumber      = np.append(pfilenumber,pp+1)
                    pointings        = np.append(pointings,spec.split('/tdose_spectrum_')[-1].split('-full')[0])
                    spectra          = np.append(spectra,spec)
                    templates        = np.append(templates,summarydat['template'][objsummary_ent[pp]])
                    matchline        = np.append(matchline,linesummarized)
                    matchS2N         = np.append(matchS2N,summarydat['FELIS_S2Nmax'][objsummary_ent[pp]])
                    vshift           = np.append(vshift,summarydat['vshift_CCmatch'][objsummary_ent[pp]])

                    if (summarydat['FELIS_S2Nmax'][objsummary_ent[pp]] > S2Nmin) & \
                            (np.abs(summarydat['vshift_CCmatch'][objsummary_ent[pp]]) < vshiftmax):
                        NlinesMatchCuts  = NlinesMatchCuts  + 1
                        for pp, pickle in enumerate(picklefiles):
                            plotname  = pickle.replace('.pkl','_CCwith_maxS2N.pdf')
                            if not skipplotting:
                                felis.plot_picklefilecontent([summarydat['spectrum'][objsummary_ent[pp]]],
                                                             pickle,showspecerr=False,plotnames=[plotname],
                                                             plotdir=outputdir,verbose=verboseplots)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        zobj = np.unique(zobj)[0]
        if verbose & (not skipplotting):
            print('     Found '+str(NlinesMatchCuts )+' lines with S2N(FELIS) > '+str(S2Nmin)+
                  ' and vshift < '+str(vshiftmax)+' km/s at z='+str("%.6f" % zobj))
        if NlinesMatchCuts  > 0:
            matchcount = matchcount + 1
            outstr = ''
            for ii, mline in enumerate(matchline):
                if verbose & (not skipplotting):
                    print('     '+mline+' @ S/N = '+str(matchS2N[ii])+'  (vshift='+str(vshift[ii])+'km/s)')
                if skipplotting:
                    outstr = outstr+' S2N('+mline+'_'+str(pointings[ii])+\
                             ')='+str(matchS2N[ii])+' w. Dv='+str(vshift[ii])+'km/s | '
            if skipplotting:
                print(str(objid)+' '+str("%12.6f" % zobj)+'   # '+outstr)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if plot_overview & (NlinesMatchCuts  > 0) & (not skipplotting):
            uspec      = np.unique(spectra)
            gaussspec  = []
            aperspec   = []
            for spec in uspec:
                gfile = spec.replace('aperture','gauss')
                if os.path.isfile(gfile):
                    gaussspec.append(gfile)

                afile = spec.replace('gauss','aperture')
                if os.path.isfile(afile):
                    aperspec.append(afile)

            specoverview = gaussspec + aperspec
            labels       = ['TDOSE gauss']*len(gaussspec) +['TDOSE aper']*len(aperspec)

            wavecols     = ['wave']*len(specoverview)
            fluxcols     = ['flux']*len(specoverview)
            fluxerrcols  = ['fluxerror']*len(specoverview)
            redshift     = zobj
            voffset      = 100.0

            if str(objid)[0] == '1':
                skyspec     = '/Users/kschmidt/work/MUSE/spectra_sky/SKY_SPECTRUM_candels-cdfs-'+str(objid)[1:3]+'_av.fits'
                wavecol_sky = 'lambda'
                fluxcol_sky = 'data'
            elif str(objid)[0] == '2':
                skyspec     = '/Users/kschmidt/work/MUSE/spectra_sky/SKY_SPECTRUM_candels-cosmos-'+str(objid)[1:3]+'_av.fits'
                wavecol_sky = 'lambda'
                fluxcol_sky = 'data'
            elif str(objid)[0] == '6':
                skyspec     = '/Users/kschmidt/work/MUSE/spectra_noise/median_eff_noise_spectrum_UDF190819.fits'
                wavecol_sky = 'wave'
                fluxcol_sky = 'flux'
            elif (str(objid)[0] == '3') or (str(objid)[0] == '4'):
                # skyspec     = '/Users/kschmidt/work/MUSE/spectra_noise/median_eff_noise_spectrum_70fields190819.fits'
                # wavecol_sky = 'wave'
                # fluxcol_sky = 'flux'
                skyspec     = '/Users/kschmidt/work/MUSE/spectra_sky/SKY_SPECTRUM_candels-cdfs-20_av.fits'
                wavecol_sky = 'lambda'
                fluxcol_sky = 'data'
            elif str(objid)[0] == '7':
                skyspec     = 'None'
                wavecol_sky = 'None'
                fluxcol_sky = 'None'
            else:
                skyspec     = 'None'
                wavecol_sky = 'None'
                fluxcol_sky = 'None'

            skyspectra   = [None]*len(specoverview)
            wavecols_sky = [wavecol_sky]*len(specoverview)
            fluxcols_sky = [fluxcol_sky]*len(specoverview)

            if os.path.isfile(skyspec):
                skyspectra[0] = skyspec

            yrangefull   = None
            xrangefull   = [4600,9400]
            linenames    = ['Lyb','Lya','CIV','HeII','OIII1663','SiIII','CIII','MgII','OII']
            outputfigure = outputdir+'overview_1DspecWzooms_'+str(objid)+'.pdf'

            mwp.plot_1DspecOverview(specoverview, labels, wavecols, fluxcols, fluxerrcols, redshift,
                                    voffset=voffset, skyspectra=skyspectra, wavecols_sky=wavecols_sky,
                                    fluxcols_sky=fluxcols_sky, outputfigure=outputfigure,linenames=linenames,
                                    yrangefull=yrangefull, xrangefull=xrangefull, plotSN=False,verbose=verboseplots)

            mwp.plot_1DspecOverview(specoverview, labels, wavecols, fluxcols, fluxerrcols, redshift,
                                    voffset=voffset, skyspectra=skyspectra, wavecols_sky=wavecols_sky,
                                    fluxcols_sky=fluxcols_sky, outputfigure=outputfigure,linenames=linenames,
                                    yrangefull=yrangefull, xrangefull=xrangefull, plotSN=True,verbose=verboseplots)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose:
        print('# - Done; so that was '+str(matchcount)+' objects with at least one line matching the cuts: ')
        print('#   S2N(FELIS) > '+str(S2Nmin))
        print('#   vshift     < '+str(vshiftmax)+' km/s ')
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def count_SpecOnArche(countfields):
    """
    Small script that can be copy-pasted into ipython on Arche to count the spectra and keep track of the reductions.
    Before this script I did copy-paste from muse notes Latex file.

    """
    import glob, sys
    setupglobstr       = 'tdose_setupfiles/tdose_setupfile_*_gauss.txt'
    setupglobstr_reext = 'tdose_setupfiles/tdose_setupfile_*_gauss_reext.txt'
    setupfiledir = {}
    setupfiledir['rafelski']   = list(np.sort(glob.glob('Rafelski-UDF-*/'+setupglobstr)))
    setupfiledir['rafudfmock'] = list(np.sort(glob.glob('Rafelski-UDF-MWmock-v1p0/'+setupglobstr)))
    setupfiledir['rafudffull'] = list(np.sort(glob.glob('Rafelski-UDF-full-v1p0/'+setupglobstr)))

    setupfiledir['skelton']         = list(np.sort(glob.glob('Skelton-*/'+setupglobstr)))
    setupfiledir['skelcdfsfull']    = list(np.sort(glob.glob('Skelton-CDFS-full-v1p0/'+setupglobstr)))
    setupfiledir['skelcdfsparfull'] = list(np.sort(glob.glob('Skelton-CDFSparallel-full-v1p0/'+setupglobstr)))
    setupfiledir['skeludffull']     = list(np.sort(glob.glob('Skelton-UDF-full-v1p0/'+setupglobstr)))
    setupfiledir['skeludf10full']   = list(np.sort(glob.glob('Skelton-UDF10-full-v1p0/'+setupglobstr)))
    setupfiledir['skeludfmock']     = list(np.sort(glob.glob('Skelton-UDF-MWmock-v1p0/'+setupglobstr)))
    setupfiledir['skelcosfull']     = list(np.sort(glob.glob('Skelton-COSMOS-full-v1p0/'+setupglobstr)))

    setupfiledir['uves']        = list(np.sort(glob.glob('MWuves100full/MWuves-*/'+setupglobstr)))
    setupfiledir['uvescos']     = list(np.sort(glob.glob('MWuves100full/MWuves-COSMOS*/'+setupglobstr)))
    setupfiledir['uvescdfs']    = list(np.sort(glob.glob('MWuves100full/MWuves-CDFS-*/'+setupglobstr)))
    setupfiledir['uvescdfspar'] = list(np.sort(glob.glob('MWuves100full/MWuves-CDFSpar*/'+setupglobstr)))
    setupfiledir['uvesudf']     = list(np.sort(glob.glob('MWuves100full/MWuves-UDF-*/'+setupglobstr)))
    setupfiledir['uvesudf10']   = list(np.sort(glob.glob('MWuves100full/MWuves-UDF10*/'+setupglobstr)))
    setupfiledir['uvesreext']   = list(np.sort(glob.glob('MWuves100full/*/'+setupglobstr_reext)))

    setupfiledir['laigle']      = list(np.sort(glob.glob('Laigle-*/'+setupglobstr)))

    setupfiledir['guo']            = list(np.sort(glob.glob('Guo-*/'+setupglobstr)))
    setupfiledir['guocdfsfull']    = list(np.sort(glob.glob('Guo-CDFS-full-v1p0/'+setupglobstr)))
    setupfiledir['guoudffull']     = list(np.sort(glob.glob('Guo-UDF-full-v1p0/'+setupglobstr)))
    setupfiledir['guoudf10full']   = list(np.sort(glob.glob('Guo-UDF10-full-v1p0/'+setupglobstr)))
    setupfiledir['guoudfmock']     = list(np.sort(glob.glob('Guo-UDF-MWmock-v1p0/'+setupglobstr)))

    if countfields == 'all':
        setupfiles = setupfiledir['rafelski']+setupfiledir['skelton']+setupfiledir['uves']
    else:
        try:
            setupfiles = setupfiledir[countfields]
        except:
            sys.exit('"'+countfields+'" is not a valid setup file selection. Choices are: '+str(setupfiledir.keys()))

    print('                                 ExtractionDir               '
          ' Fieldname           Ngaussspec        Naperturespec     missingGaussspec')
    completefields   = []
    incompletefields = []
    emptyfields      = []
    for sf in setupfiles :

        extdir     = sf.split('/tdose')[0]
        fieldname  = sf.split('_gauss')[0].split('v1p0-')[-1].split('v1p0_')[-1].split('andels-')[-1]

        specsearchstr = sf.split('/tdose_setupfiles/')[0]+'/tdose_spectra/tdose_spec*'+fieldname+'*gauss*.fits'
        if '_reext' in sf:
            specsearchstr = sf.split('/tdose_setupfiles/')[0]+'/tdose_spectra_reext/tdose_spec*'+fieldname+'*gauss*.fits'

        Ng = len(glob.glob('/store/data/musewide/TDOSE/'+specsearchstr))
        Na = len(glob.glob('/store/data/musewide/TDOSE/'+specsearchstr.replace('gauss*.fits','aperture*.fits')))
        if '_reext' in sf:
            import sys
            sys.path.append('/store/data/musewide/TDOSE/TDOSE')
            import tdose_utilities as tu
            try:
                sfdat = tu.load_setup(sf,verbose=False)
                Na    = len(sfdat['sources_to_extract'])
            except:
                Na    = np.nan

        Ngmissing = Na-Ng
        outstr    = str("%50s" % extdir)+' '+str("%20s" % fieldname)+' '+\
                    str("%20s" % Ng)+' '+str("%20s" % Na)+' '+str("%20s" % Ngmissing)

        if Ngmissing > 0:
            print('\033[91m'+outstr+'\033[0m') # coloring output red if spectra are missing
            incompletefields.append(fieldname)
        else:
            print(outstr)
            if Ng > 0:
                completefields.append(fieldname)
        if Na == 0:
            emptyfields.append(fieldname)

    print('\n - Hence, the '+str(len(completefields))+'/'+str(len(setupfiles))+' completed fields are: \n'+str(completefields))

    print('\n The fields with no aperture spectra at all are: '+str(emptyfields))
    return completefields, incompletefields, emptyfields
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def vet_felisdetection(idlist,plotdirs,outputfile,lineratiosummary,S2Nmincheck=3.0,
                       infofile='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits',
                       FELISsummary=False,EWestimates=False,overwrite=False,verbose=True):
    """
    Script to automize the vetting of the supposed FELIS emission line detections.

    --- INPUT ---

    --- EXAMPLE OF RUN ---
    import uvEmissionlineSearch as uves

    parentdir    = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/all_aperture190926/'

    idlist = [101005016,720190222,101011026,77]
    lineratiosummary = parentdir+'fluxratios/fluxratios_FELISmatch2uves190926_aperture.txt'
    EWestimates      = parentdir+'fluxratios/fluxratios_FELISmatch2uves190926_aperture_EW0estimates_191015run.txt'
    plotdirs         = [parentdir+'../FELIS_bestmatches_plots_aperture/']

    outputfile = parentdir+'vet_felisdetection_outputRENAME.txt'
    uves.vet_felisdetection(idlist,plotdirs,outputfile,lineratiosummary,S2Nmincheck=3.0,EWestimates=EWestimates,overwrite=True)

    """
    pversion = sys.version_info[0]
    Nobj   = len(idlist)
    if verbose: print(' - '+str(Nobj)+' IDs provided for vetting')
    if verbose: print(' - Preparing output file '+outputfile)
    if os.path.isfile(outputfile) & (not overwrite):
        sys.exit('The output ('+outputfile+') alreaduy exists and overwrite=False so exiting.')
    else:
        fout = open(outputfile,'w')
        fout.write('# Result from vetting the '+str(Nobj)+' IDs provided to uves.vet_felisdetection() on '+kbs.DandTstr2()+'\n')
        fout.write('# \n')
        fout.write('# Each of the "trustLINE" columns provide \n'
                   '#        1  = yes   I would trust the line detection. \n'
                   '#        0  = no    I would not the line detection. \n'
                   '#        9  = maybe I would trust the line detection. \n'
                   '#      -99  = no spectral coverage of the given line. \n'
                   '#       99  = estimated S/N < '+str(S2Nmincheck)+'  (limit from "S2Nmincheck")  \n'
                   '#      NaN  = ID missing in line flux ratio summary.\n')
        fout.write('# The columns are followed by notes on the object \n')
        fout.write('# \n')
        fout.write('# Columns are:\n')
        emlines    = ['NV', 'CIV', 'HeII', 'OIII', 'SiIII', 'CIII', 'MgII']
        fout.write('#  id               pointing'+''.join([str("%13s" % ('trust'+el)) for el in emlines])+'\n')

    if verbose: print(' - Loading main info file: '+infofile)
    dat_maininfo = afits.open(infofile)[1].data

    if verbose: print(' - Loading ancillary information to display for each object ')

    frdatBadFMT     = np.genfromtxt(lineratiosummary,skip_header=7,dtype='d',comments='#',names=True)
    fmt             = 'd,12a,'+','.join((len(frdatBadFMT.dtype.names)-2)*['d'])
    dat_lineratio   = np.genfromtxt(lineratiosummary,skip_header=7,dtype=fmt,comments='#',names=True)

    if EWestimates:
        ew0BadFMT = np.genfromtxt(EWestimates,skip_header=8,dtype='d',comments='#',names=True)
        fmt       = 'd,12a,'+','.join((len(ew0BadFMT.dtype.names)-2)*['d'])
        dat_ew0   = np.genfromtxt(EWestimates,skip_header=8,dtype=fmt,comments='#',names=True)
    else:
        dat_ew0 = None


    answerkeys = {'y':1, 'n':0, 'm':9, 'nocov':-99, 'lows2n':99, 'idmissing':np.nan}
    if verbose: print(' - Loop over objects while opening figures and printing info ')
    for ii, objid in enumerate(idlist):
        objent_info      = uves.return_objent(objid,dat_maininfo,idcol='id',verbose=False)
        objent_lineratio = uves.return_objent(objid,dat_lineratio,idcol='id',verbose=False)
        if objent_lineratio is None:
            if verbose: print('--------- OBJECT  '+str("%.10d" % objid)+
                              ' ('+str("%.5d" % (ii+1))+'/'+str("%.5d" % len(idlist))+') --------- ')
            if verbose: print(' WARNING - No objects found in line ratio summary')
            if verbose: print('           Continuing to next object ')
            continue
        objpointings     = dat_lineratio['pointing'][objent_lineratio]

        for plotdir in plotdirs:
            mainplots = ' '.join(glob.glob(plotdir+'overview_1DspecWzooms*'+str("%.9d" % objid)+'*.pdf'))

        opencommand = 'open -n -F '
        if mainplots != '':
            pipe_mainplots = subprocess.Popen(opencommand+mainplots,shell=True,executable=os.environ["SHELL"])
            time.sleep(1.1) # sleep to make sure process appears in PIDlist
            pid_mainplots  = MiGs.getPID('Preview.app',verbose=False) # get PID of png process

        for pp, objpoint in enumerate(objpointings):
            objent_lr        = objent_lineratio[pp]
            objent_ew0       = uves.return_objent([objid,objpoint],dat_ew0,idcol=['id','pointing'],verbose=False)
            if verbose: print('\n--------- OBJECT  '+str("%.10d" % objid)+' ('+str("%.5d" % (ii+1))+'/'+str("%.5d" % len(idlist))+') POINTING '+str(objpoint)+' --------- ')
            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            if verbose:
                print(' z(info)         = '+str("%7.4f" % dat_maininfo['redshift'][objent_info]))
                print(' FWHM(Lya)       = '+str("%8.2f" % dat_maininfo['fwhm_kms'][objent_info])+' +\-'+
                      str("%8.2f" % dat_maininfo['fwhm_kms_std'][objent_info])+'  km/s ')
                print(' Dv_redpeak(V18) = '+str("%8.2f" % dat_maininfo['red_peak_shift_V18_kms'][objent_info])+' +\-'+
                      str("%8.2f" % dat_maininfo['red_peak_shift_V18_kms_err'][objent_info])+'  km/s ')
                print(' EW0(Lya)        = '+str("%8.2f" % dat_maininfo['EW_0'][objent_info])+' +\-'+
                      str("%8.2f" % dat_maininfo['EW_0_err'][objent_info])+'  A ')
                print(' beta            = '+str("%8.2f" % dat_maininfo['beta'][objent_info])+' +\-'+
                      str("%8.2f" % dat_maininfo['beta_err'][objent_info]))
                print(' f606wJK         = '+str("%10.4f" % (1e20*dat_maininfo['flux_acs_606w'][objent_info]))+' +\-'+
                      str("%10.4f" % (1e20*dat_maininfo['flux_err_acs_606w'][objent_info]))+'  1e-20cgs')
                print(' f814wJK         = '+str("%10.4f" % (1e20*dat_maininfo['flux_acs_814w'][objent_info]))+' +\-'+
                      str("%10.4f" % (1e20*dat_maininfo['flux_err_acs_814w'][objent_info]))+'  1e-20cgs')
                print(' id_Laigle       = '+str("%8.2f" % dat_maininfo['id_Laigle'][objent_info])+
                      '         sep = '+str("%8.2f" % dat_maininfo['sep_Laigle'][objent_info]))
                print(' id_Skelton      = '+str("%8.2f" % dat_maininfo['id_skelton'][objent_info])+
                      '         sep = '+str("%8.2f" % dat_maininfo['sep_skelton'][objent_info]))
                print(' id_Guo          = '+str("%8.2f" % dat_maininfo['id_guo'][objent_info])+
                      '         sep = '+str("%8.2f" % dat_maininfo['sep_guo'][objent_info]))
                print(' id_Rafelski     = '+str("%8.2f" % dat_maininfo['id_rafelski'][objent_info])+
                      '         sep = '+str("%8.2f" % dat_maininfo['sep_rafelski'][objent_info])+'\n')
                for el in emlines:
                    print(' EW0('+str("%5s" % el)+') = '+str("%8.2f" % dat_ew0['EW0_'+el][objent_ew0])+' +\-'+
                          str("%8.2f" % dat_ew0['EW0err_'+el][objent_ew0])+'   for beta = '+
                          str("%8.4f" % dat_ew0['beta'][objent_ew0]))
                print('\n')
                for el in emlines:
                    print(' f('+str("%5s" % el)+')   = '+str("%8.2f" % dat_lineratio['f_'+el][objent_lr])+' @ S/N ='+
                          str("%8.2f" % dat_lineratio['s2n_'+el][objent_lr])+'   with Dv = '+
                          str("%8.2f" % dat_lineratio['vshift_'+el][objent_lr])+' km/s  and  sigma = '+
                          str("%8.2f" % dat_lineratio['sigma_'+el][objent_lr]))
            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            if verbose: print('\n (Info from summaries; -99 = no data file provided; None = ID missing) ')
            outstr = str("%12s" % objid)+' '+str("%15s" % objpoint)+' '

            for emline in emlines:
                if verbose: print(' - Checking template matches to '+emline)
                answer = ''
                if objent_lr is None:
                    answer = 'idmissing'
                    outstr = outstr+str("%12s" % answerkeys[answer.lower()])+' '
                else:
                    lineS2N    = dat_lineratio['s2n_'+emline][objent_lr]
                    ELquestion = '   -> Do you trust FELIS LLLL (y)es/(n)o/(m)aybe/(e)exit? '.replace('LLLL',str("%5s" % emline))

                    if lineS2N < S2Nmincheck:
                        answer = 'lows2n'
                    elif ~np.isfinite(lineS2N):
                        answer = 'nocov'
                    else:
                        for plotdir in plotdirs:
                            lineplots = ' '.join(glob.glob(plotdir+'*'+str(objpoint)+'*'+
                                                           str("%.9d" %  objid)+'*'+str(emline)+'*.pdf'))

                        if lineplots != '':
                            pipe_lineplots = subprocess.Popen(opencommand+lineplots,shell=True,executable=os.environ["SHELL"])
                            time.sleep(1.1) # sleep to make sure process appears in PIDlist
                            pid_lineplots  = MiGs.getPID('Preview.app',verbose=False) # get PID of png process
                        else:
                            if verbose: print('   WARNING did not find a plot of the FELIS match to the line')

                        while answer.lower() not in ['y','n','m']:
                            if pversion == 2:
                                answer = raw_input(ELquestion) # raw_input for python 2.X
                            elif pversion == 3:
                                answer = input(ELquestion)     # input for python 3.X
                            else:
                                sys.exit(' Unknown version of python: version = '+str(pversion))
                            if answer == 'e':
                                fout.close()
                                sys.exit('   Exiting as answer provided was "e". Vetting summarized in\n   '+outputfile)
                        if lineplots != '':
                            killsignal = 1
                            try:
                                os.kill(pipe_lineplots.pid+1,killsignal)
                            except:
                                print(' WARNING: Was unable to close lineplots ')

                    outstr = outstr+str("%12i" % answerkeys[answer.lower()])+' '

            if pversion == 2:
                notes  = raw_input('   -> Anything to add for this object?\n'
                                   '      (AGN? Marginal detections? Bad spec?)    ') # raw_input for python 2.X
            elif pversion == 3:
                notes  = input('   -> Anything to add for this object?\n'
                               '      (AGN? Marginal detections? Bad spec?)    ') # raw_input for python 3.X
            else:
                sys.exit(' Unknown version of python: version = '+str(pversion))

            if notes == 'e':
                fout.close()
                sys.exit('   Exiting as input for notes was "e". Vetting summarized in\n   '+outputfile)
            else:
                outstr = outstr+'  #Notes: '+notes+' \n'

            fout.write(outstr)
            fout.close()
            fout = open(outputfile,'a')

        if mainplots != '':
            killsignal = 1
            try:
                os.kill(pid_mainplots,killsignal)
            except:
                print(' WARNING: Was unable to close mainplots ')
    if verbose: print('\n--------- Done --------- ')
    if verbose: print(' Wrote output to:\n '+outputfile)
    fout.close()
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def return_objent(id,dataarray,idcol='id',verbose=True):
    """
    Little script to match and return object index in data array
    """
    if dataarray is not None:
        if type(id) is list: # list provided so ID and Pointing to be usef for selection
            objents = np.where((dataarray[idcol[0]].astype(int) == int(id[0])) &
                               (dataarray[idcol[1]] == str(id[1])))[0]
        else:
            objents = np.where(dataarray[idcol].astype(int) == int(id))[0]
        if len(objents) > 1:
            if verbose: print('   WARNING: Multiple matches ('+str(len(objents))+') to '+str(id)+' found by uves.return_objdat()')
        elif len(objents) == 0:
            if verbose: print('   WARNING: No matches to '+str(id)+' found in uves.return_objdat()')
            objents = None
    else:
        objents = -99

    return objents

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def summarize_tdosevetting(returnsample='udf10',verbose=True):
    """
    Summarizing the content of the vetting of the TDOSE spectra

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    idbad, idgood = uves.summarize_tdosevetting(returnsample='udf10')
    """

    vetdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/vet_tdose_extractions_outputs/'
    vetcat = vetdir+'MWuves-full-v1p0_vet_tdose_extractions_output_manuallycombined.txt'

    vetdat = np.genfromtxt(vetcat,names=True,comments='#',dtype=None,skip_header=28)

    selcuts = collections.OrderedDict()
    selcuts['all fields'] = [0.0,   1e12]
    selcuts['cdfs']       = [0.9e8, 1.9e8 ]
    selcuts['parallels']  = [2.9e8, 4.9e8  ]
    selcuts['cosmos']     = [1.9e8, 2.9e8  ]
    selcuts['udfmosaic']  = [5.9e8, 6.9e8  ]
    selcuts['udf10']      = [6.9e8, 7.9e8  ]

    # - - - -  count - - - -
    print(' ---- vetting results in '+vetcat.split('/')[-1]+' ----')
    for key in selcuts.keys():
        idmin, idmax = selcuts[key]
        Nobj  = len(np.where(( vetdat['id'].astype(float) > idmin) & ( vetdat['id'].astype(float) < idmax ) )[0] )
        zeros = np.where((vetdat['vetresult'] == 0) &
                         ( vetdat['id'].astype(float) > idmin) & ( vetdat['id'].astype(float) < idmax ) )[0]
        ones = np.where((vetdat['vetresult'] == 1) &
                        ( vetdat['id'].astype(float) > idmin) & ( vetdat['id'].astype(float) < idmax ) )[0]
        twos  = np.where((vetdat['vetresult'] == 2) &
                         ( vetdat['id'].astype(float) > idmin) & ( vetdat['id'].astype(float) < idmax ) )[0]
        threes = np.where((vetdat['vetresult'] == 3) &
                          ( vetdat['id'].astype(float) > idmin) & ( vetdat['id'].astype(float) < idmax ) )[0]
        fours = np.where((vetdat['vetresult'] == 4) &
                         ( vetdat['id'].astype(float) > idmin) & ( vetdat['id'].astype(float) < idmax ) )[0]

        ids_goodspec = vetdat['id'][np.append(ones,twos)]
        ids_badspec = vetdat['id'][np.append(threes,fours)]

        if Nobj>0:
            fracgood = float(len(ids_goodspec))/float(Nobj)
        else:
            fracgood = 0

        if verbose:
            print(' - The fraction of good spectra (vetresult = 1 or 2) among the '+
                  str("%5s" % Nobj)+' spectra from '+str("%10s" % key)+' is:        '+str(fracgood))
            print('   This corresponds to '+str(len(ids_badspec))+'/'+str(len(ids_badspec)+len(ids_goodspec))+' bad spectra')
            print('   The number of spectra marked for revisiting was: '+str(len(zeros)))

        if key == returnsample:
            ids_badspec_return, ids_goodspec_return = ids_badspec, ids_goodspec
            print('   >>>>>>>>>>>> Note: The '+key+' IDs were returned <<<<<<<<<<<<\n')
        else:
            print('   ')

    return ids_badspec_return, ids_goodspec_return
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def summarize_felisvetting(vetoutput,verbose=True):
    """
    Function summarizing the content of an output file from uves.vet_felisdetection()

    It also looks for close neighbors which can be used to clean out dublicate entries of objects in overlap regions.

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    vetoutput = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/FELIStemplatematch2uvesobjects/all_aperture190926/vet_felisdetection_output_for_object_match_selection_all191029_aperture_s2nGT3_vshiftLT1000_191030vettingUDFonly.txt'
    uves.summarize_felisvetting(vetoutput)

    """
    fmt    = ['d','12a','d','d','d','d','d','d','d']
    vetdat = np.genfromtxt(vetoutput,skip_header=12,dtype=fmt,names=True,comments='#')

    lines = [nn.replace('trust','') for nn in vetdat.dtype.names[2:]]
    if verbose: print(' - Summarizing content of '+str(len(vetdat))+' entries in \n   '+vetoutput)
    if verbose: print('   (entries for '+str(len(np.unique(vetdat['id'])))+' unique ids)\n')
    for cc, col in enumerate(vetdat.dtype.names[2:]):
        N_cov   = float(len(np.where(vetdat[col] >= 0)[0]))
        N_yes   = float(len(np.where(vetdat[col] == 1)[0]))
        N_no    = float(len(np.where(vetdat[col] == 0)[0]))
        N_maybe = float(len(np.where(vetdat[col] == 9)[0]))
        N_lim   = float(len(np.where(vetdat[col] == 99)[0]))
        if verbose:
            print('  '+str("%5s" % lines[cc])+' (numbers)  : '+str("%8i" % N_yes)+' '+str("%8i" % N_no)+' '+
                  str("%8i" % N_maybe)+' '+str("%8i" % N_lim)+'   of '+str("%5i" % N_cov)+' entries')
            print('        (fraction) : '+str("%8.4f" % (N_yes/N_cov))+' '+
                  str("%8.4f" % (N_no/N_cov))+' '+str("%8.4f" % (N_maybe/N_cov))+' '+str("%8.4f" % (N_lim/N_cov)))

    N_systemic           = 0.0
    N_systemic_wCIV      = 0.0
    N_systemic_wCIVaMgII = 0.0
    id_sys               = []
    id_sys_wCIV          = []
    id_sys_wCIVaMgII     = []

    for ii, objid in enumerate(vetdat['id']):
        if  (vetdat['trustNV'][ii]    == 1) or (vetdat['trustHeII'][ii]  == 1) or (vetdat['trustOIII'][ii]  == 1) or (vetdat['trustSiIII'][ii] == 1) or (vetdat['trustCIII'][ii]  == 1):
            N_systemic = N_systemic + 1.0
            id_sys.append(int(objid))

        if  (vetdat['trustNV'][ii]    == 1) or (vetdat['trustCIV'][ii]   == 1) or  (vetdat['trustHeII'][ii]  == 1) or (vetdat['trustOIII'][ii]  == 1) or (vetdat['trustSiIII'][ii] == 1) or (vetdat['trustCIII'][ii]  == 1):
            N_systemic_wCIV = N_systemic_wCIV + 1.0
            id_sys_wCIV.append(int(objid))

        if  (vetdat['trustNV'][ii]    == 1) or (vetdat['trustCIV'][ii]   == 1) or (vetdat['trustHeII'][ii]  == 1) or (vetdat['trustOIII'][ii]  == 1) or (vetdat['trustSiIII'][ii] == 1) or (vetdat['trustCIII'][ii]  == 1) or (vetdat['trustMgII'][ii]  == 1):
            N_systemic_wCIVaMgII = N_systemic_wCIVaMgII + 1.0
            id_sys_wCIVaMgII.append(int(objid))

    if verbose:
        print('\n - Number of systemic redshifst = '+str(N_systemic)+'      (excl. CIV and MgII detections)')
        print(' - Number of systemic redshifst = '+str(N_systemic_wCIV)+'      (incl. CIV but excl. MgII detections)')
        print(' - Number of systemic redshifst = '+str(N_systemic_wCIVaMgII)+'      (incl. CIV and MgII detections)')

    coordsepsel = 0.5
    if verbose: print(' - Checking for dublicates/close neighbors within '+str(coordsepsel)+' arcsec:')
    infofile ='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/LAEinfo_UVemitters_3timesUDFcats.fits'
    datinfo  = afits.open(infofile)[1].data
    ralist   = []
    declist  = []
    zlist    = []

    for objid in np.unique(vetdat['id']):
        ralist.append( datinfo['ra'][np.where(datinfo['id'].astype(int) == int(objid))[0][0]] )
        declist.append( datinfo['dec'][np.where(datinfo['id'].astype(int) == int(objid))[0][0]] )
        zlist.append( datinfo['redshift'][np.where(datinfo['id'].astype(int) == int(objid))[0][0]] )

    for oo, objid in enumerate(np.unique(vetdat['id'])):
        coordiff_deg = np.sqrt( (np.cos(np.deg2rad(np.asarray(declist)))*(np.asarray(ralist)-np.asarray(ralist)[oo]))**2.0 +
                                (np.asarray(declist)-np.asarray(declist)[oo])**2.0 )
        coordiff = coordiff_deg * 3600.
        matchent = np.where((0 < coordiff) & (coordiff < coordsepsel))[0]
        if len(matchent) > 0:
            matchIDs = vetdat['id'][matchent]
            coorsep  = coordiff[matchent]
            if verbose: print('   matches to '+str(int(objid))+': '+str(matchIDs.astype(int))+'      @ sep = '+str("%.4f" % coorsep)+' arcsec')

    regionfile = vetoutput.replace('.txt','.reg')
    if regionfile != vetoutput:
        if verbose: print('\n - Storing region file to\n'+regionfile)
        colors = ['red']*len(ralist)
        for oo, objid in enumerate(vetdat['id'].astype(int)):
            if objid in id_sys_wCIVaMgII:
                colors[oo] = 'magenta'
            if objid in id_sys_wCIV:
                colors[oo] = 'orange'
            if objid in id_sys:
                colors[oo] = 'cyan'

        kbs.create_DS9region(regionfile,ralist,declist,color=colors,textlist=vetdat['id'].astype(str),clobber=True)

        ent_wLya = np.where(np.asarray(zlist) > 2.9)[0]
        regionfileLya = regionfile.replace('.reg','_zLT2p9.reg')
        if verbose: print('\n - Storing LAEs to region file \n'+regionfileLya)
        kbs.create_DS9region(regionfileLya,np.asarray(ralist)[ent_wLya],np.asarray(declist)[ent_wLya],
                             color=np.asarray(colors)[ent_wLya],textlist=vetdat['id'].astype(str)[ent_wLya]
                             ,circlesize=0.3,clobber=True)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def build_mastercat(outputfits, printwarning=True, overwrite=False, verbose=True):
    """
    Function assembling a master output catalog from the flux ratio measurements and EW estimates taking
    the results of the FELIS and TDOSE vetting into account.

    Ideally, this should be the catalog plotted, analyzed and released with any publication.

    This can also form the base of generating LaTeX tables

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    outputfits = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/results_master_catalog_version191202.fits'
    uves.build_mastercat(outputfits)

    """
    if os.path.isfile(outputfits) and (overwrite == False):
        sys.exit('The output file '+outputfits+' already exists and overwrite=False ')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' --- Building the master catalog for the UVES study --- ')
    dir_main         = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/'

    file_info        = dir_main+'objectinfofile_zGT1p5_3timesUDFcats_JKthesisInfo.fits'
    file_fluxratio   = dir_main+'FELIStemplatematch2uvesobjects/all_gauss190926/fluxratios/' \
                                'fluxratios_FELISmatch2uves190926_gauss_wpointings.txt'
    file_EWestimates = file_fluxratio.replace('.txt','_EW0estimates_191028run.txt')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Load infofile data ')
    dat_info         = afits.open(file_info)[1].data

    if verbose: print(' - Load fluxratio data ')
    dat_fluxratio    = np.genfromtxt(file_fluxratio,    dtype=None,comments='#',names=True,skip_header=7)

    if verbose: print(' - Load EW estiamtes ')
    dat_EWestimates  = np.genfromtxt(file_EWestimates,  dtype=None,comments='#',names=True,skip_header=8)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Setting up output structure. \n   Definiing columns: ')
    outcolnames = dat_fluxratio.dtype.names + dat_EWestimates.dtype.names[2:]
    Nrows       = len(dat_info)
    Ncols       = len(outcolnames)
    Nskip       = 0
    for cc, colname in enumerate(outcolnames):
        if verbose:
            infostr = '   '+str("%20s" % colname)+'   ( '+str("%.5d" % (cc+1))+' / '+str("%.5d" % Ncols)+' ) '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        try:
            npstr   = dat_fluxratio.dtype[colname].str
        except:
            npstr   = dat_EWestimates.dtype[colname].str

        if '|S' in npstr:
            fmt = npstr.split('S')[1]+'A'
            if colname == 'pointing': fmt = '30A'
            dat = np.asarray(['None'*Nrows])
        elif npstr == '<i8':
            fmt     = 'K'
            dat     = (np.zeros(Nrows)-99).astype(int)
        elif npstr == '<f8':
            fmt     = 'D'
            dat     = np.zeros(Nrows)*np.nan
        else:
            sys.exit(' No setup for the numpy array format "'+npstr+'"')

        if 'NV' in colname: # igrnoring columns incl. NV as this is not going to be sensible due the Lya either way;
                            # helps stay below Ncol = 999 which is a fundamental limitation of the fits format.
            Nskip = Nskip + 1
            continue
        else:
            col_def  = afits.ColDefs([afits.Column(name=colname, format=fmt, array=dat)])
            try:
                col_out = col_out + col_def
            except:
                col_out = col_def

    Ncols = Ncols - Nskip
    if verbose: print('\n   (Skipped the '+str(Nskip)+' rows containing NV so Nrows='+str(Ncols))

    if verbose: print('   Creating fits file HDU with column definitions ')
    hdu_out     = afits.BinTableHDU.from_columns(col_out)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Filling output with data adjusting for vetting results ')
    ids_badspec, ids_goodspec = uves.summarize_tdosevetting(sample='all')
    pointing_selector_dic     = uves.pointing_selector()

    for ii, id in enumerate(dat_info['id'][:]):
        if (len(str(id)) == 9) & (str(id).startswith('5')): # skipping UDF MWmock depth objects
            hdu_out.data['id'][ii]       = id
            hdu_out.data['pointing'][ii] = 'SkippingUDFMWmock'

            continue
        if verbose:
            infostr = '   Checking data for id='+str(id)+' ('+str("%.5d" % (ii+1))+' / '+str("%.5d" % len(dat_info['id']))+')     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()

        if id in ids_badspec:
            hdu_out.data['id'][ii]       = id
            hdu_out.data['pointing'][ii] = 'TDOSEvetBadSpec'
            continue

        objent_flux      = np.where(dat_fluxratio['id']   == id)[0]
        objent_ew        = np.where(dat_EWestimates['id'] == id)[0]
        # ------------- check what pointing to use if more than 1 appearance of ID -------------
        if (len(objent_flux) > 1) or (len(objent_ew) > 1):
            if verbose & printwarning: print('\n   WARNING Multiple pointings for object id='+str(id))
            if str(id) in pointing_selector_dic.keys():
                objent_flux      = np.where((dat_fluxratio['id'] == id) &
                                            (dat_fluxratio['pointing'] == pointing_selector_dic[str(id)]) )[0]
                objent_ew        = np.where((dat_EWestimates['id'] == id) &
                                            (dat_EWestimates['pointing'] == pointing_selector_dic[str(id)]) )[0]
                objent_vet_felis = np.where((dat_vetfelis['id'] == id) &
                                            (dat_vetfelis['pointing'] == pointing_selector_dic[str(id)]) )[0]
            else:
                if verbose & printwarning:
                    print('   ID not found in dictionary from uves.pointing_selector().')
                    if len(objent_flux) > 1:
                        print('   Check the entries in flux ratio file to make a decision (id appears '+
                              str(len(objent_flux))+' times there)')
                    if len(objent_ew) > 1:
                        print('   Check the entries in flux ratio file to make a decision (id appears '+
                              str(len(objent_ew))+' times there)')
                    print('   Skipping object until add to uves.pointing_selector() dictionary ')

                hdu_out.data['id'][ii]       = id
                hdu_out.data['pointing'][ii] = 'MultiPointingNoDecision'
                continue

        # ------------- Pulling out data from catalogs and writing it to master cat -------------
        if len(objent_flux) == 1:
            for colname in dat_fluxratio.dtype.names:
                if 'NV' in colname:
                    continue
                else:
                    hdu_out.data[colname][ii] = dat_fluxratio[colname][objent_flux][0]

        if len(objent_ew) == 1:
            for colname in dat_EWestimates.dtype.names[2:]:
                if 'NV' in colname:
                    continue
                else:
                    hdu_out.data[colname][ii] = dat_EWestimates[colname][objent_ew][0]

        if hdu_out.data['id'][ii] == -99: # checking that data for object was inserted
            hdu_out.data['id'][ii]       = id
            hdu_out.data['pointing'][ii] = 'NoDataToInsert'
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print('\n - Storing final catalog to '+outputfits)
    hdu_primary = afits.PrimaryHDU()
    hdulist     = afits.HDUList([hdu_primary, hdu_out])
    hdulist.writeto(outputfits, overwrite=overwrite)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def pointing_selector():
    """
    Function returning a dictionary with the pointing name to use for analysis for all the objects (IDs) appearing
    in multiple pointings.

    Note: As of 191129 this does not account for overlaps between MUSE-Wide, UDF and UDF-10 as the IDs are
    different in these cases


    """
    pointing_selector_dic = {}
    #                    ['_____id_____'] = pointing                # bad pointings
    pointing_selector_dic['_____id_____'] = 'udf-01'                # bad pointings

    return pointing_selector_dic

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def prepare_reextractionPostVetting(verbose=True,printVetComment=False):
    """
    Function to prepare setupfiles (by editing exiting files) and collecting objects to perform re-extractions for
    based on the TDOSE vetting summary generated with tdose_utilities.vet_tdose_extractions() collected in
    parentdir+'vet_tdose_extractions_outputs/MWuves-full-v1p0_vet_tdose_extractions_output_manuallycombined.txt'

    --- Example of use ---
    import uvEmissionlineSearch as uves
    uves.prepare_reextractionPostVetting()

    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Loading vetting results and grabbing list of original TDOSE setup file to modify.')
    parentdir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/'
    # vetresults    = parentdir+'vet_tdose_extractions_outputs/MWuves-full-v1p0_vet_tdose_extractions_output_manuallycombined.txt'
    vetresults    = parentdir+'vet_tdose_extractions_outputs/MWuves-full-v1p0_vet_tdose_re-extractions_output_manuallycombined.txt'
    if verbose: print('   Vetting results from: '+vetresults)
    outdir        = parentdir+'tdose_reextractionPostVetting/'
    orig_setups   = glob.glob(parentdir+'tdose_setupfiles/*tdose_setupfile_MWuves*_gauss.txt')
    vetdat        = np.genfromtxt(vetresults,names=True,comments='#',dtype=None,skip_header=28)
    Nvets         = len(vetdat['id'])
    ent_reext     = np.where(vetdat['vetresult'] > 2)[0]
    id_reext      = vetdat['id'][ent_reext]
    #--------------------------------------------------------------------
    # speclistfile = parentdir+'MWuves-full-v1p0_spectra_paperselection.txt'
    # if os.path.isfile(speclistfile):
    #     speclistdat = np.genfromtxt(speclistfile,names=True,comments='#',dtype=None,skip_header=4)
    #     if verbose: print(' - Loading output from uves.print_specs to get list of objects with existing good specs')
    #     IDswGoodSpec = speclistdat['id']
    #
    #     for ii, id_re in enumerate(id_reext):
    #         if id_re in IDswGoodSpec:
    #             id_reext[ii]  = -99
    #             ent_reext[ii] = -99
    #
    #     id_reext  = id_reext[id_reext > -1]
    #     ent_reext = ent_reext[ent_reext > -1]
    # else:
    #     if verbose: print(' - Did not find uves.print_specs() list of objects with existing good specs; including all ids')
    #--------------------------------------------------------------------
    Nreext        = len(ent_reext)
    point_reext   = [spec.split('tdose_spectrum_')[-1].split('-full')[0] for spec in vetdat['spectrum'][ent_reext]]
    point_reext_u = np.unique(point_reext)
    if verbose: print(' - Found '+str(Nvets)+' objects that had been vetted; '+str(Nreext)+
                      ' of those should be re-extracted (vet results > 2)')
    if verbose: print('   These are spread out over '+str(len(point_reext_u))+' individual MUSE pointings.')

    if printVetComment:
        print('   The comments for these objects from the vetting file are:')
        print('   - - - - - - - - - - - - - - - - - - - - - - - - ')
        fvet      = open(vetresults,'r')
        for line in fvet.readlines():
            if line.split()[0] in id_reext.astype(str):
                notesstr = line.split('#Notes:')[-1].split('\n')[0]
                if ('fov' in notesstr.lower()) or ('use point source' in notesstr.lower()):
                    print('\033[91m'+'  '+line.split()[0]+':  '+notesstr+'\033[0m')
                else:
                    print('  '+line.split()[0]+':  '+notesstr)

        print('   - - - - - - - - - - - - - - - - - - - - - - - - ')
        fvet.close()

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Initializing setup files for re-extractions based on original TDOSE setup files.')
    reext_setups  = []
    for orig_setup in orig_setups:
        point_setup = orig_setup.split('v1p0-')[-1].split('_gauss')[0].replace('candels-','')
        if point_setup in point_reext_u:
            reext_setup = outdir+'tdose_setupfiles/'+orig_setup.split('/')[-1].replace('.txt','_reext.txt')
            shutil.copyfile(orig_setup, reext_setup)
            reext_setups.append(reext_setup)
        else:
            continue
    if len(point_reext_u) != len(reext_setups):
        print(' ERROR: The number of unique pointings from the vetting results does not '
              'match the number of re-extraction setups initialized')
        pdb.set_trace()
    if verbose: print('   '+str(len(reext_setups))+' re-extraction setups ready for modifications.')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Looping over setupfiles and editing content')
    idlistcheck  = []
    for rr, reext_setup in enumerate(reext_setups):
        pointing = reext_setup.split('v1p0-')[-1].split('_gauss')[0].replace('candels-','')
        fin      = open(reext_setup,'r')
        tmpfile  = reext_setup.replace('.txt','_tmp.txt')
        ftmp     = open(tmpfile,'w')

        for line in fin.readlines():
            if line.startswith('models_directory'):
                line   = line.replace('tdose_models/','tdose_models_reext/')
            if line.startswith('spec1D_directory'):
                line   = line.replace('tdose_spectra/','tdose_spectra_reext/')

            if line.startswith('max_centroid_shift'):
                line   = line.replace('  10  ','  2  ')

            if line.startswith('sources_to_extract'):
                sourceextfile = line.split()[1]
                macloc     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/' \
                             'tdose_extraction_MWuves_100fields_maxdepth190808/tdose_sourcecatalogs/'
                origsource = np.genfromtxt(macloc+sourceextfile.split('/')[-1],names=True,dtype=None)
                idlist = uves.get_idlist_for_reext_pointing(id_reext,pointing,idmaster=origsource['id'])
                line   = line.replace(sourceextfile,str(idlist).replace(' ',''))
                idlistcheck = idlistcheck + list(idlist)

            if line.startswith('spec1D_name'):
                line   = line.replace('MWuves','MWuves_reext')

            ftmp.write(line)
        ftmp.close()
        fin.close()
        shutil.move(tmpfile,reext_setup)   # replacing original file with temporary file with edits

    if verbose: print(' - Chekcing that all IDs to re-extract were found in edited setups')
    idsinsetups = np.unique(np.asarray(idlistcheck))
    for id in id_reext:
        if id not in idsinsetups:
            print('   setups do not appear to contain the id '+str(id))
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_idlist_for_reext_pointing(idsinput,pointing,idmaster=None):
    """
    Function returning the IDs in a given pointing provided a full list of IDs.

    """
    idsout = []
    if 'cdfs-' in pointing:
        pointno = pointing.split('cdfs-')[-1][:2]
        for idcheck in idsinput:
            if str(int(idcheck)).startswith('1'+pointno):
                idsout.append(idcheck)
    elif 'cosmos-' in pointing:
        pointno = pointing.split('cosmos-')[-1][:2]
        for idcheck in idsinput:
            if str(int(idcheck)).startswith('2'+pointno):
                idsout.append(idcheck)
    elif 'hudf09-1-' in pointing:
        pointno = pointing.split('hudf09-1-')[-1][:2]
        for idcheck in idsinput:
            if str(int(idcheck)).startswith('3'+pointno):
                idsout.append(idcheck)
    elif 'hudf09-2-' in pointing:
        pointno = pointing.split('hudf09-2-')[-1][:2]
        for idcheck in idsinput:
            if str(int(idcheck)).startswith('4'+pointno):
                idsout.append(idcheck)
    elif 'udf-0' in pointing:
        for idcheck in idsinput:
            if str(int(idcheck)).startswith('6') & (int(idcheck) in idmaster.astype(int)):
                idsout.append(idcheck)
    elif 'udf-1' in pointing:
        for idcheck in idsinput:
            if str(int(idcheck)).startswith('7'):
                idsout.append(idcheck)
    else:
        sys.exit(' Did not find a matching string in pointing '+pointing)

    return idsout
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def print_specs(outputfile, overwrite=True, verbose=True):
    """
    Small function to print ID and spec list from TDOSE vetting results

    --- INPUT ---

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.print_specs('./outfile.txt')

    """
    parentdir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/'
    vr_main       = parentdir+'vet_tdose_extractions_outputs/MWuves-full-v1p0_vet_tdose_extractions_output_manuallycombined.txt'
    vr_reext1     = parentdir+'vet_tdose_extractions_outputs/MWuves-full-v1p0_vet_tdose_re-extractions_output_manuallycombined.txt'
    vetresults    = [vr_main,vr_reext1]

    if (overwrite == False) & os.path.isfile(outputfile):
        sys.exit('The file '+outputfile+' already exists but overwrite=False ')

    fout = open(outputfile,'w')
    fout.write('# List of spectra to search for UV emission with FELIS. \n')
    fout.write('# List generated with uves.print_specs() on '+kbs.DandTstr2()+' based on the TDOSE vetting results in: \n')
    fout.write('# '+' and '.join(vetresults)+'\n')
    fout.write('# \n')
    fout.write('# id           spectrum \n')

    if verbose: print(' - Looping over vetting results and writing output to \n   '+outputfile)
    for vetresult in vetresults:
        fout.write('### IDs and Spec from vetting results collected in: '+vetresult.split('/')[-1]+' ###\n')
        vetdat        = np.genfromtxt(vetresult,names=True,comments='#',dtype=None,skip_header=28)
        for ii, id in enumerate(vetdat['id']):
            if vetdat['vetresult'][ii] > 2:
                fout.write("# Needs re-extraction: "+str("%s" % id)+'    '+
                           vetdat['spectrum'][ii].replace('..','/store/data/musewide/TDOSE/')+' \n')
            else:
                fout.write(str("%s" % id)+'    '+
                           vetdat['spectrum'][ii].replace('..','/store/data/musewide/TDOSE/')+' \n')
    fout.close()

    if verbose: print(' - Loading output and summarizing: ')
    outdat = np.genfromtxt(outputfile,names=True,comments='#',dtype=None,skip_header=4)
    Nobj   = len(outdat['id'])
    Nobj_u = len(np.unique(outdat['id']))
    if Nobj != Nobj_u:
        if verbose: print('    The following objects appear N times in output ')
        if verbose: print(' objid       N')
        for objid in np.unique(outdat['id']):
            objent = np.where(outdat['id'] == objid)[0]
            if len(objent) > 1:
                if verbose: print(str(objid)+'   '+str(len(objent)))
        if verbose: print(' -> But there should be no duplications... go fix. ')
    else:
        if verbose:
            print('   Found '+str(Nobj_u)+' unique objects in output')
            print('   To be compared with 2197 expected (minus 15 multifield-stacks = 2182)')
            print('   (not accounted for duplicates UDF-CDFS-UDF10 as of 200206)')

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def collectAndRenamArcheSpec(speclist='/store/data/musewide/TDOSE/MWuves100full/MWuves-full-v1p0_speclist12XXXX.txt',
                             outputdir='/store/data/musewide/TDOSE/MWuves100full/MWuvesSpecs20XXXX/',
                             namestring='20XXXXselection',verbose=True):
    """
    As the name says, this function collects and renames the spectra to search for UV emission lines.
    In other words it assembles the final sample including selecting pointings, including stacks,
    assembling re-extractions, etc.

    NB: This has to be run with copy-past on arche

    --- Example of use ---
    import uvEmissionlineSearch as uves
    uves.collectAndRenamArcheSpec(namestring='200121selection',outputdir='/store/data/musewide/TDOSE/MWuves100full/test200121/')

    """
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    import sys, numpy as np, os, tdose_utilities as tu
    if os.path.isdir(outputdir) != True:
        sys.exit(' Did not find output directory '+outputdir)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    specdat  = np.genfromtxt(speclist,dtype=None,names=True,comments='#',skip_header=4)
    Nobjects = len(np.unique(specdat['id']))
    if Nobjects != 2197:
        answer   = 'no answer'
        print('WARNING There should be spectra associated with a total of 2197 objects (IDs). Only found '+str(Nobjects))
        question = '        Are you sure you want to proceed (y/n)? '
        pversion = sys.version_info[0]

        while str(answer).lower() not in ['y','n']:
            if pversion == 2:
                answer = raw_input(question) # raw_input for python 2.X
            elif pversion == 3:
                answer =     input(question) # input for python 3.X
            else:
                sys.exit(' Unknown version of python: version = '+str(pversion))
        if answer.lower() == 'n':
            sys.exit(' okay - then exited as requested')

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    for ss, spec in enumerate(specdat['spectrum']):
        newspec = outputdir+'tdose_spectrum_'+namestring+'_'+str("%.10d" % int(specdat['id'][ss]))+'.fits'
        if verbose:
            infostr = ' - Removing SOURCECUBE and renaming spectrum for id='+str("%.10d" % int(specdat['id'][ss]))+\
                      '  ('+str("%.5d" % (ss+1))+' / '+str("%.5d" % len(specdat['id']))+')     '
            sys.stdout.write("%s\r" % infostr)
            sys.stdout.flush()
        try:
            tu.strip_extension_from_fitsfile(spec,outputdir,removeextension='SOURCECUBE',overwrite=False,verbose=False)
            os.rename(outputdir+spec.split('/')[-1],newspec)
        except:
            print('\nWARNING Attempt to copy '+spec+' to '+newspec+' failed.')
    if verbose: print('\n   ... done')
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose:
        print(' - To tar up the directory and its content excecute: ')
        print('   bash> cd '+outputdir+'..')
        if outputdir.endswith('/'):
            tarname = outputdir.split('/')[-2]
        else:
            tarname = outputdir.split('/')[-1]
        print('   bash> tar -zcvf ./'+tarname+'.tar.gz '+outputdir.split('/')[-2]+'/tdose_spectrum_'+namestring+'*.fits')
        print('   kbs>  scp kasper@arche.aip.de:'+outputdir+'../'+tarname+'.tar.gz  /Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/')
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def stack_IndividualObjectsWithMultiSpec(plotstackoverview=True,verbose=True):
    """
    Function collecting spectra of individual objects with multiple good spectra and stacking them.
    Basing selection on TDOSE vetting comments containing n6-xx-yy notes.

    --- Example of use ---
    import uvEmissionlineSearch as uves
    uves.stack_IndividualObjectsWithMultiSpec(plotstackoverview=False)

    """
    parentdir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/'
    outdir        = parentdir+'stacks1D_individual_objects/'
    specdir       = parentdir+'spectra_all/'
    vetresults    = parentdir+'vet_tdose_extractions_outputs/MWuves-full-v1p0_vet_tdose_extractions_output_manuallycombined.txt'
    vetdat        = np.genfromtxt(vetresults,names=True,comments='#',dtype=None,skip_header=28)
    Nvets         = len(vetdat['id'])

    if verbose: print(' - Looking through vetting results ('+vetresults.split('/')[-1]+') to find objects to stack')
    vetinfo       = open(vetresults,'r')
    stackids      = collections.OrderedDict()
    ll            = 0
    for line in vetinfo.readlines():
        if line.startswith('#'):
            continue
        else:
            if 'n6-' in line:
                objid       = vetdat['id'][ll]
                stackfields = line.split('n6-')[-1].split()[0].split('-')
                objspec     = specdir+'*/tdose_spectra_cubestripped/'+vetdat['spectrum'][ll].split('/')[-1]
                objspecid   = objspec.split('-full')[0][-2:]
                if verbose: print('   Stack '+str(objid)+' spectra in fields: '+str(stackfields))
                stackids[objid] = [glob.glob(objspec.replace(objspecid+'-full',sf+'-full'))[0] for sf in stackfields],stackfields
            ll = ll+1

    if verbose: print(' - Stacking spectra in observed frame and saving output to:\n   '+outdir)
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/objectinfofile_zGT1p5_3timesUDFcats_JKthesisInfo.fits'
    infodat       = afits.open(infofile)[1].data

    for oo, objid in enumerate(stackids.keys()):
        spectra, fields = stackids[objid]
        outfile         = outdir+'tdose_spectrum_stackInclFields'+'-'.join(fields)+'_'+str("%.10d" % int(objid))+'.fits'
        wavelengths     = []
        fluxes          = []
        variances       = []

        for spectrum in spectra:
            data        = afits.open(spectrum)[1].data
            wavelengths.append(data['wave'])
            fluxes.append(data['flux'])
            variances.append(data['fluxerror']**2.0)

        if verbose: print('   Generating '+outfile.split('/')[-1]+'   (stack '+str(oo+1)+'/'+str(len(stackids.keys()))+')')
        stacktype ='mean'   # 'median'
        errtype   ='varsum'
        wave_out, flux_out, variance_out, Nspecstack = \
            stacking.stack_1D(wavelengths, fluxes, variances, z_systemic=np.zeros(len(spectra)),
                              stacktype=stacktype, errtype=errtype, wavemin=4750, wavemax=9350, Nsigmaclip=None,
                              deltawave=1.25, outfile=outfile, verbose=False)

        if plotstackoverview:
            plotspecs    = spectra+[outfile]
            labels       = ['Spec from field '+str(ff) for ff in fields]+['Stack of individual spec']
            wavecols     = ['wave']*len(plotspecs)
            fluxcols     = ['flux']*len(plotspecs)
            fluxerrcols  = ['fluxerror']*len(plotspecs)

            infoent      = np.where(infodat['id'] == objid)[0]
            zLya         = infodat['redshift'][infoent]
            voffset      = 250.0
            skyspectra   = [None]*len(spectra)+['/Users/kschmidt/work/MUSE/spectra_sky/SKY_SPECTRUM_candels-cdfs-06_av.fits']
            wavecols_sky = [None]*len(spectra)+['lambda']
            fluxcols_sky = [None]*len(spectra)+['data']
            yrangefull   = [-300,1000]
            xrangefull   = [4700,9400]

            for plotSN in [True,False]:
                mwp.plot_1DspecOverview(plotspecs, labels, wavecols, fluxcols, fluxerrcols, zLya[0], voffset=voffset,
                                        skyspectra=skyspectra, wavecols_sky=wavecols_sky, fluxcols_sky=fluxcols_sky,
                                        outputfigure=outfile.replace('.fits','_overview.pdf'),
                                        yrangefull=yrangefull, xrangefull=xrangefull,
                                        plotSN=plotSN,verbose=False)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def stack_composites_generate_setup(outputfile,equalsizebins=False,overwrite=False,verbose=True):
    """
    Function automatically putting together a file containing the setups for generating composites
    needed by

    --- Example of use ---
    import uvEmissionlineSearch as uves
    outputfile = './stacks1D_sample_selection.txt'
    outarray   = uves.stack_composites_generate_setup(outputfile,overwrite=True)

    """
    if os.path.isfile(outputfile) & (overwrite == False):
        sys.exit(' Overwrite was set to "False" and found existing copy of the file \n '+outputfile)

    if verbose: print(' - Loading infofile to enable cutting composites ')
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/objectinfofile_zGT1p5_3timesUDFcats_JKthesisInfo.fits'
    infodat       = afits.open(infofile)[1].data
    infodat       = infodat[np.where((infodat['id']<4.9e8) | (infodat['id']>5.9e8))[0]] # ignoring UDF MW mock ids

    columns       = ['zmin','zmax',
                     'Llyamin','Llyamax',
                     'FWHMlyamin','FWHMlyamax',
                     'm814wmin','m814wmax',
                     'EW0lyamin','EW0lyamax',
                     'betamin','betamax']

    outarray    = np.array([],dtype=[('id', 'i4'), ('label', 'U50'), ('nspec', 'i4'), ('ztype', 'U5'), ('bintype', 'U12')]+
                                    [(cn,'>f8') for cn in columns])
    emptyval    = 9999
    for equalsizebins in [False,True]:
        if not equalsizebins:
            eqbinstring = 'EqNumberBins'
            binid       = 100000
        else:
            eqbinstring = 'EqSizeBins'
            binid       = 200000

        for ztype in ['zcat','zv18']:
            if verbose: print('----------------- Generate setups for '+eqbinstring+' and '+ztype+' -----------------')
            coltrans  = uves.stack_composite_col_translator(ztype)
            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            if verbose: print(' - Setup for composite cintaining all spectra')
            if ztype == 'zcat':
                specid   = 10001+binid
            elif ztype == 'zv18':
                specid   = 20001+binid
            else:
                sys.exit(' Invalid entry for ztype (='+ztype+')')

            outrow   = np.asarray((specid,'all',99,ztype,eqbinstring)+
                                  (-emptyval,emptyval)*(len(columns)/2),dtype=outarray.dtype)
            outarray = np.append(outarray,outrow)

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            if verbose: print(' - Generating z-binning setups')
            for Nbins in [4,10]:
                for colbase in ['z']:
                    binranges = uves.get_vector_intervals(infodat[coltrans['zmin']][infodat[coltrans['zmin']]>2.9],
                                                          Nbins,verbose=False,
                                                          equalsizebins=equalsizebins)
                    for bb, br in enumerate(binranges):
                        specid   = specid+1
                        label    = 'zGT2p9_bin'+str(bb+1)+'of'+str(Nbins)
                        outrow   = np.asarray((specid,label,99,ztype,eqbinstring)+
                                              (-emptyval,emptyval)*(len(columns)/2),dtype=outarray.dtype)
                        outrow[colbase+'min'] = br[0]
                        outrow[colbase+'max'] = br[1]
                        outarray = np.append(outarray,outrow)

            Nbins     = 3
            for colbase in ['z']:
                if ztype != 'zv18':
                    binranges = uves.get_vector_intervals(infodat[coltrans['zmin']][infodat[coltrans['zmin']]<2.9],
                                                          Nbins,verbose=False,equalsizebins=equalsizebins)
                    for bb, br in enumerate(binranges):
                        specid   = specid+1
                        label    = 'zLT2p9_bin'+str(bb+1)+'of'+str(Nbins)
                        outrow   = np.asarray((specid,label,99,ztype,eqbinstring)+
                                              (-emptyval,emptyval)*(len(columns)/2),dtype=outarray.dtype)
                        outrow[colbase+'min'] = br[0]
                        outrow[colbase+'max'] = br[1]
                        outarray = np.append(outarray,outrow)
                else:
                    for bb, br in enumerate(np.arange(Nbins)):
                        specid   = specid+1
                        label    = 'zLT2p9_bin'+str(bb+1)+'of'+str(Nbins)
                        outrow   = np.asarray((specid,label,99,ztype,eqbinstring)+
                                              (np.nan,np.nan)*(len(columns)/2),dtype=outarray.dtype)
                        outarray = np.append(outarray,outrow)

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            if verbose: print(' - Generating m814w binning (seperating non-detections out) ')
            for Nbins in [4,10]:
                for colbase in ['m814w']:
                    datvec    = infodat[coltrans[colbase+'min']][infodat[coltrans[colbase+'min']]<29.39]
                    binranges = uves.get_vector_intervals(datvec,Nbins,verbose=False,equalsizebins=equalsizebins)

                    for bb, br in enumerate(binranges):
                        specid   = specid+1
                        label    = colbase+'_bin'+str(bb+1)+'of'+str(Nbins)
                        outrow   = np.asarray((specid,label,99,ztype,eqbinstring)+
                                              (-emptyval,emptyval)*(len(columns)/2),dtype=outarray.dtype)
                        outrow[colbase+'min'] = br[0]
                        outrow[colbase+'max'] = br[1]
                        outarray = np.append(outarray,outrow)

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            if verbose: print(' - Selection of objects with m814w non-edetections (limiting mag) ')
            datvec    = infodat[coltrans['m814wmin']][infodat[coltrans['m814wmin']]>29.39]
            binranges = uves.get_vector_intervals(datvec,1,verbose=True,equalsizebins=equalsizebins)
            specid    = specid+1
            label     = colbase+'nondet_bin1of1'
            outrow    = np.asarray((specid,label,99,ztype,eqbinstring)+
                                   (-emptyval,emptyval)*(len(columns)/2),dtype=outarray.dtype)
            outrow[colbase+'min'] = binranges[0][0]-0.0001 # manually expand range as all values are identical
            outrow[colbase+'max'] = binranges[0][1]+0.0001 # manually expand range as all values are identical
            outarray = np.append(outarray,outrow)

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            if verbose: print(' - Generating 4-bin selections (cut on just one parameter) ')
            coltrans  = uves.stack_composite_col_translator(ztype)
            Nbins     = 4
            for colbase in ['Llya','FWHMlya','EW0lya','beta']:
                binranges = uves.get_vector_intervals(infodat[coltrans[colbase+'min']],Nbins,verbose=False,
                                                      equalsizebins=equalsizebins)
                for bb, br in enumerate(binranges):
                    specid   = specid+1
                    label    = colbase+'_bin'+str(bb+1)+'of'+str(Nbins)
                    outrow   = np.asarray((specid,label,99,ztype,eqbinstring)+
                                          (-emptyval,emptyval)*(len(columns)/2),dtype=outarray.dtype)
                    outrow[colbase+'min'] = br[0]
                    outrow[colbase+'max'] = br[1]
                    outarray = np.append(outarray,outrow)

            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            if verbose: print(' - Generating 3-bin selections (cut on two parameters) ')
            coltrans  = uves.stack_composite_col_translator(ztype)
            Nbins     = 3

            for colbase1,colbase2 in combinations( ['z','m814w','Llya','FWHMlya','EW0lya','beta'],2):
                if colbase1 == 'z':
                    datvec1 = infodat[coltrans['zmin']][infodat[coltrans['zmin']]>2.9]
                elif colbase1 == 'm814w':
                    datvec1 = infodat[coltrans[colbase1+'min']][infodat[coltrans[colbase1+'min']]<29.39]
                else:
                    datvec1 = infodat[coltrans[colbase1+'min']]
                binranges1 = uves.get_vector_intervals(datvec1,Nbins,verbose=False,equalsizebins=equalsizebins)

                if colbase2 == 'z':
                    datvec2 = infodat[coltrans['zmin']][infodat[coltrans['zmin']]>2.9]
                elif colbase2 == 'm814w':
                    datvec2 = infodat[coltrans[colbase2+'min']][infodat[coltrans[colbase2+'min']]<29.39]
                else:
                    datvec2 = infodat[coltrans[colbase2+'min']]
                binranges2 = uves.get_vector_intervals(datvec2,Nbins,verbose=False,equalsizebins=equalsizebins)

                for bb1, br1 in enumerate(binranges1):
                    for bb2, br2 in enumerate(binranges2):
                        specid   = specid+1
                        label    = colbase1+'_bin'+str(bb1+1)+'of'+str(Nbins)+'_'+colbase2+'_bin'+str(bb2+1)+'of'+str(Nbins)
                        outrow   = np.asarray((specid,label,99,ztype,eqbinstring)+
                                              (-emptyval,emptyval)*(len(columns)/2),dtype=outarray.dtype)
                        outrow[colbase1+'min'] = br1[0]
                        outrow[colbase1+'max'] = br1[1]
                        outrow[colbase2+'min'] = br2[0]
                        outrow[colbase2+'max'] = br2[1]
                        outarray = np.append(outarray,outrow)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print('----------------- Counting objects for each setup and generating output -----------------')
    Nrows        = outarray.shape[0]
    # ppp = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/'
    # ccc = ppp + 'stacks1D_sample_selection.txt'
    # sss = np.genfromtxt(ccc,names=True,skip_header=2,comments='#',dtype=None)
    # print(' comparison: outarray VS fileload')
    if os.path.isfile(outputfile):
        dat_outfile     = np.genfromtxt(outputfile,names=True,skip_header=2,comments='#',dtype=None)

    for rr in np.arange(Nrows):
        if os.path.isfile(outputfile):
            ent_sample_file = uves.stack_composites_objselection(dat_outfile[rr],infodat)
            outarray[rr][2] = len(ent_sample_file)
        else:
            ent_sample = uves.stack_composites_objselection(outarray[rr],infodat)
            outarray[rr][2] = len(ent_sample)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if verbose: print(' - Writing output to \n   '+outputfile)
    fout = open(outputfile, 'w')
    fout.write('# Setup file for generating coposite spectra with uves.stack_composites() \n')
    fout.write('# Created with uves.stack_composites_generate_setup() on '+kbs.DandTstr2()+' \n')
    fout.write('#  id                                             label                '
               'nspec              ztype              bintype'+
               ' '.join([str("%14s" % cc) for cc in columns])+'\n')
    for rr in np.arange(Nrows):
        outstr = str('%.5d' % outarray[rr][0])+\
                 str('%50s' % outarray[rr][1])+\
                 str('%20s' % outarray[rr][2])+\
                 str('%20s' % outarray[rr][3])+\
                 str('%20s' % outarray[rr][4])+\
                 ' '.join([str('%14.4f' % val) for val in outarray[rr].tolist()[5:]])
        if '     all     ' in outstr:
            fout.write('#'+''.join(['-------------------']*16)+'\n')
        fout.write(outstr+'\n')

    fout.close()
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def stack_composites(compositesetup,plotstackoverview=True,inloopload=False,verbose=True):
    """
    Function collecting spectra and stacking them based on various collection cuts defined in "stackdefs"

    --- Example of use ---
    import uvEmissionlineSearch as uves

    parentdir       = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/'
    compositesetups = parentdir+'stacks1D_sample_selection_manual.txt'
    uves.stack_composites(compositesetups,plotstackoverview=False)

    """
    parentdir     = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/'
    outdir        = parentdir+compositesetup.split('/')[-1].split('.tx')[0]+'/'
    specdir       = parentdir+'UVESselection200203noreext/'
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/objectinfofile_zGT1p5_3timesUDFcats_JKthesisInfo.fits'
    infodat       = afits.open(infofile)[1].data
    infodat       = infodat[np.where((infodat['id']<4.9e8) | (infodat['id']>5.9e8))[0]] # ignoring UDF_MWmock

    stackinfo     = np.genfromtxt(compositesetup,names=True,skip_header=2,comments='#',dtype=None)
    Nstacks       = len(stackinfo['id'])

    if not inloopload:
        specdatadic   = {}
        if verbose: print(' - Assembling master dictionary with data from spectra (instead of loading in-loop)')
        for ii, id in enumerate(infodat['id']):
            searchstr = specdir+'*_0'+str(id)+'.fits'
            objspecs  = glob.glob(searchstr)
            if len(objspecs) != 1:
                print('WARNING Found '+str(len(objspecs))+' spectra (expected 1) globbing for:\n        '+searchstr)
                specdatadic[str(id)] = np.nan, np.nan, np.nan
            else:
                data                     = afits.open(objspecs[0])[1].data
                specdatadic[objspecs[0]] = data['wave'], data['flux'], data['fluxerror']**2.0

    if verbose: print(' - Stacking spectra in observed frame and saving output to:\n   '+outdir)
    for ii, stackid in enumerate(stackinfo['id']):
        outfile         = outdir+'composite_spectrum_'+str("%.10d" % stackid)+'_'+stackinfo['label'][ii]+'.fits'
        if verbose: print('   === Generating '+outfile.split('/')[-1]+'   (stack '+str(ii+1)+'/'+str(Nstacks)+') === ')
        wavelengths     = []
        fluxes          = []
        variances       = []

        if verbose: print('       > selecting indexes')
        ent_sample      = uves.stack_composites_objselection(stackinfo[ii],infodat)
        spectra         = []
        for ee, ent_s in enumerate(ent_sample):
            searchstr = specdir+'*_0'+str(infodat['id'][ent_s])+'.fits'
            objspecs  = glob.glob(searchstr)
            if len(objspecs) != 1:
                # print('WARNING Found '+str(len(objspecs))+' spectra (expected 1) globbing for:\n        '+searchstr)
                ent_sample[ee] = -99
            else:
                spectra.append(objspecs[0])
        spectra   = np.asarray(spectra)
        Nspec     = len(spectra)
        ent_sample = ent_sample[ent_sample != -99]

        if stackinfo[ii]['ztype'].lower() == 'zcat':
            objredshift  = infodat['redshift'][ent_sample.astype(int)]
        elif stackinfo[ii]['ztype'].lower() == 'zv18':
            objredshift  = infodat['z_sys_V18'][ent_sample.astype(int)]
        else:
            sys.exit(' Invalid entry for ztype (='+stackinfo[ii]['ztype']+') in '+compositesetup)

        # only passing on objects with determined redshifts to stacking (other-wise they cant be moved to rest-frame)
        spectra     = spectra[objredshift > 0]
        objredshift = objredshift[objredshift > 0]
        noz_ent     = np.where(objredshift <= 0)[0]
        if len(noz_ent) > 0:
            print('   Objects removed because they have no good redshift: \n   '+str(infodat['id'][noz_ent]))
        Nspec       = len(spectra)

        if verbose: print('       > building input structures for stacking the selected '+str(Nspec)+' objects ')
        for spectrum in spectra:
            if inloopload:
                data        = afits.open(spectrum)[1].data
                wavelengths.append(data['wave'])
                fluxes.append(data['flux'])
                variances.append(data['fluxerror']**2.0)
            else:
                datwave, datflux, datvariance = specdatadic[spectrum]
                wavelengths.append(datwave)
                fluxes.append(datflux)
                variances.append(datvariance)

        if verbose: print('       > performing stacking of the selected '+str(Nspec)+' objects: ')

        stacktype ='mean'   # 'median'
        errtypes  =['varsum']#,'stdonmean','fspread','std','medianvar']
        for errtype in errtypes:
            if verbose: print('          > estimating errors with the method "'+errtype+'" ')
            outfile_errappend = outfile.replace('.fits','_ERR'+errtype+'.fits')
            wave_out, flux_out, variance_out, Nspecstack = \
                stacking.stack_1D(wavelengths, fluxes, variances, z_systemic=objredshift, Nsigmaclip=1,
                                  stacktype=stacktype, errtype=errtype, wavemin=600, wavemax=3800,
                                  deltawave=0.1, outfile=outfile_errappend, verbose=False)

            if plotstackoverview:
                if verbose: print('            plotting the result ')
                plotspecs    = [outfile_errappend]
                labels       = [stackinfo['label'][ii].replace('_','\_')+' (stack of '+str(Nspec)+' spectra)']
                wavecols     = ['wave']
                fluxcols     = ['flux']
                fluxerrcols  = ['fluxerror']

                plotz        = 0.0
                voffset      = 0.0
                skyspectra   = [None]*len(plotspecs)
                wavecols_sky = [None]*len(plotspecs)
                fluxcols_sky = [None]*len(plotspecs)
                yrangefull   = [-30,100]
                xrangefull   = [600,3800]

                mwp.plot_1DspecOverview(plotspecs, labels, wavecols, fluxcols, fluxerrcols, plotz, voffset=voffset,
                                        skyspectra=skyspectra, wavecols_sky=wavecols_sky, fluxcols_sky=fluxcols_sky,
                                        outputfigure=plotspecs[0].replace('.fits','_overview.pdf'),
                                        yrangefull=yrangefull, xrangefull=xrangefull,
                                        show_error=False,verbose=False,plotSN=False)
                mwp.plot_1DspecOverview(plotspecs, labels, wavecols, fluxcols, fluxerrcols, plotz, voffset=voffset,
                                        skyspectra=skyspectra, wavecols_sky=wavecols_sky, fluxcols_sky=fluxcols_sky,
                                        outputfigure=plotspecs[0].replace('.fits','_overview.pdf'),
                                        yrangefull=yrangefull, xrangefull=xrangefull,
                                        show_error=False,verbose=False,plotSN=True)
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def stack_composites_objselection(selectinfo,selectdata,verbose=True):
    """
    Function returning the entries of a given composite stack selection based on data infofiles

    --- Example of use ---
    see uves.stack_composites above

    """
    coltranslationdic = uves.stack_composite_col_translator(selectinfo['ztype'].lower())

    indexlist = np.arange(len(selectdata)) # all entries returned by default
    colsets   = np.unique(np.asarray([colname[:-3] for colname in selectinfo.dtype.names[5:]]))

    for colset in colsets:
        mincol = colset+'min'
        maxcol = colset+'max'
        if (selectinfo[mincol] != -9999) & (selectinfo[maxcol] != 9999):
            indexsel   = np.where((selectdata[coltranslationdic[mincol]] >= selectinfo[mincol]) &
                                  (selectdata[coltranslationdic[maxcol]] <= selectinfo[maxcol]) &
                                  (selectdata[coltranslationdic[mincol]] != 0.0) &
                                  (selectdata[coltranslationdic['zmin']] != 0.0))[0]
        else:
            indexsel   = np.where((selectdata[coltranslationdic['zmin']] != 0.0))[0]

        indexlist  = np.asarray([ii for ii in indexlist if ii in indexsel])
    return indexlist

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def stack_composite_col_translator(ztype,verbose=True):
    """

    coltranslationdic = uves.stack_composite_col_translator('zcat')

    """
    if ztype.lower() == 'zcat':
        zcol = 'redshift'
    elif ztype.lower() == 'zv18':
        zcol = 'z_sys_V18'
    else:
        print('\nWARNING: uves.stack_composite_col_translator() got unknown redshift type: '+ztype+'\n')
        zcol = None

    coltranslationdic = {}
    coltranslationdic['zmin']       = zcol
    coltranslationdic['zmax']       = zcol
    coltranslationdic['Llyamin']    = 'F_3KRON'
    coltranslationdic['Llyamax']    = 'F_3KRON'
    coltranslationdic['FWHMlyamin'] = 'fwhm_a_jk'
    coltranslationdic['FWHMlyamax'] = 'fwhm_a_jk'
    coltranslationdic['m814wmin']   = 'mag_acs_814w'
    coltranslationdic['m814wmax']   = 'mag_acs_814w'
    coltranslationdic['EW0lyamin']  = 'EW_0_beta_linear_many'
    coltranslationdic['EW0lyamax']  = 'EW_0_beta_linear_many'
    coltranslationdic['betamin']    = 'beta_linear_many'
    coltranslationdic['betamax']    = 'beta_linear_many'

    return coltranslationdic
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def stack_composite_plotNxNspecs(param1,param2,param1range,param2range,spectra,outname,
                                 ztype='zcat',bintype='EqNumberBins',verbose=True):
    """
    function plotting the composite spectra from the binning of the objects displaying the binning
    in a seperate panel of the overview plot.

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves, glob
    specdir = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/stacks1D_sample_selection/'

    # --- two parameters binned ---
    param1  = 'z'
    param2  = 'm814w'
    globstr = specdir+'*'+param1+'_bin*'+param2+'_bin*.fits'
    spectra = np.sort(glob.glob(globstr))

    outname = specdir+'testoverviewWcols.pdf'
    uves.stack_composite_plotNxNspecs(param1,param2,[2.9,6.7],[23.79,28.82],spectra,outname)

    # --- one parameter binned ---
    param1  = 'z'
    globstr = specdir+'*'+param1+'LT2p9_bin*of3.fits'
    spectra = np.sort(glob.glob(globstr))
    outname = specdir+'composite_overview_'+param1+'LT2p9.pdf'
    uves.stack_composite_plotNxNspecs(param1,None,[1.5,2.9],None,spectra,outname)

    """
    parentdir      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/'
    compositesetup = parentdir+'stacks1D_sample_selection.txt'
    setupinfo      = np.genfromtxt(compositesetup,names=True,skip_header=2,comments='#',dtype=None)

    Nspec   = len(spectra)
    setuplabels    = [(param1+ss.split('.fit')[0].split('_'+param1)[-1].split('_ERR')[0]) for ss in spectra]

    # plot overview figure with 9 spectra in
    if verbose: print(' - Plotting the '+str(Nspec)+' spectra provided \n   ')
    plotspecs        = spectra

    if len(spectra) == 9:
        red1, red2, red3      = (205/255.,0/255.,0/255.), (255/255.,76/255.,76/255.), (255/255.,153/255.,153/255.)
        green1, green2, gree3 = (0/255.,205/255.,0/255.), (76/255.,255/255.,76/255.), (153/255.,255/255.,153/255.)
        blue1, blue2, blue3   = (0/255.,0/255.,205/255.), (76/255.,76/255.,255/255.), (153/255.,153/255.,255/255.)
        speccolors            = [blue1, blue2, blue3, green1, green2, gree3, red1, red2, red3]
        # speccolors       = ['orange','blue','red','green','brown','cyan','pink','purple','yellow']
    elif len(spectra) == 3:
        speccolors            = ['blue','green','red']
    elif len(spectra) == 4:
        speccolors            = ['blue','green','orange','red']
    elif len(spectra) == 10:
        cmap         = plt.cm.viridis
        cmap_norm    = plt.Normalize(vmin=1.0, vmax=Nspec)
        speccolors   = [cmap(cmap_norm(cc))[0:3] for cc in np.arange(Nspec)+1]

    labels           = [' ']*len(spectra) #[ll.replace('_','\_') for ll in setuplabels]
    wavecols         = ['wave']*len(spectra)
    fluxcols         = ['flux']*len(spectra)
    fluxerrcols      = ['fluxerror']*len(spectra)
    col_matrix       = True
    col_matrix_title = '' #'The Color Matrix'
    # col_matrix_text  =  [ss.split('.fit')[0].split(param1+'_')[-1].replace('bin','').replace('of','/').replace('_'+param2+'_','-')
    #                      for ss in spectra]
    setupinfo_ents   = np.unique(np.asarray( [np.where((setupinfo['label'] == ll) &
                                                       (setupinfo['ztype'] == ztype) &
                                                       (setupinfo['bintype'] == bintype))[0] for ll in setuplabels] ))
    col_matrix_text  = [str(setupinfo[np.where((setupinfo['label'] == ll) &
                                               (setupinfo['ztype'] == ztype) &
                                               (setupinfo['bintype'] == bintype))[0]]['nspec'][0]) for ll in setuplabels]
    col_matrix_labels=[param1,param2]
    if param2 is None:
        col_matrix_labels=[param1,'']
    col_matrix_ranges=[param1range,param2range]

    transdic      = uves.stack_composite_col_translator(ztype)
    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/objectinfofile_zGT1p5_3timesUDFcats_JKthesisInfo.fits'
    infodat       = afits.open(infofile)[1].data
    infodat       = infodat[np.where((infodat['id']<4.9e8) | (infodat['id']>5.9e8))[0]] # ignoring UDF_MWmock

    if param2 is not None:
        datent        = np.where((infodat[transdic[param1+'min']] >= param1range[0]) &
                                 (infodat[transdic[param1+'max']] <= param1range[1]) &
                                 (infodat[transdic[param1+'max']] != 0) &
                                 (infodat[transdic[param2+'min']] >= param2range[0]) &
                                 (infodat[transdic[param2+'max']] <= param2range[1]) &
                                 (infodat[transdic[param2+'max']] != 0))[0]

        col_matrix_p1dat = infodat[transdic[param1+'min']][datent]
        col_matrix_p2dat = infodat[transdic[param2+'min']][datent]

        minvals1     = np.unique(setupinfo[setupinfo_ents][param1+'min'])
        maxvals1     = np.unique(setupinfo[setupinfo_ents][param1+'max'])
        param1ranges = [[minvals1[ii],maxvals1[ii]] for ii in [0,1,2]]

        minvals2     = np.unique(setupinfo[setupinfo_ents][param2+'min'])
        maxvals2     = np.unique(setupinfo[setupinfo_ents][param2+'max'])
        param2ranges = [[minvals2[ii],maxvals2[ii]] for ii in [0,1,2]]
    else:
        datent        = np.where((infodat[transdic[param1+'min']] >= param1range[0]) &
                                 (infodat[transdic[param1+'max']] <= param1range[1]) &
                                 (infodat[transdic[param1+'max']] != 0.0))[0]

        col_matrix_p1dat = infodat[transdic[param1+'min']][datent]
        col_matrix_p2dat = None

        minvals1     = np.unique(setupinfo[setupinfo_ents][param1+'min'])
        maxvals1     = np.unique(setupinfo[setupinfo_ents][param1+'max'])
        param1ranges = [[minvals1[ii],maxvals1[ii]] for ii in np.arange(len(spectra))]
        param2ranges = [[0,np.max(setupinfo['nspec'][setupinfo_ents])]]*len(spectra)

    col_matrix_binranges = [param1ranges,param2ranges]

    plotz        = 0.0
    voffset      = 0.0
    skyspectra   = [None]*len(plotspecs)
    wavecols_sky = [None]*len(plotspecs)
    fluxcols_sky = [None]*len(plotspecs)
    xrangefull   = [600,3800]

    for plotSNval in [True,False]:
        if plotSNval is False:
            yrangefull   = [-30,150]
        else:
            yrangefull   = 'dummy'

        mwp.plot_1DspecOverview(plotspecs, labels, wavecols, fluxcols, fluxerrcols, plotz, voffset=voffset,
                                skyspectra=skyspectra, wavecols_sky=wavecols_sky, fluxcols_sky=fluxcols_sky,
                                outputfigure=outname, speccols=speccolors, show_error=False,
                                yrangefull=yrangefull, xrangefull=xrangefull,
                                col_matrix=col_matrix, col_matrix_title=col_matrix_title, col_matrix_text=col_matrix_text,
                                col_matrix_labels=col_matrix_labels, col_matrix_ranges=col_matrix_ranges,
                                col_matrix_binranges=col_matrix_binranges,
                                col_matrix_p1dat=col_matrix_p1dat,col_matrix_p2dat=col_matrix_p2dat,
                                plotSN=plotSNval,verbose=True)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def plot_compositespec_wrapper(specdir='/Users/kschmidt/work/MUSE/uvEmissionlineSearch/tdose_extraction_MWuves_100fields_maxdepth190808/stacks1D_sample_selection/'):
    """

    wrapper to stack_composite_plotNxNspecs() setting up and plotting the overveiws of the composite spectra

    --- EXAMPLE OF USE ---
    import uvEmissionlineSearch as uves
    uves.plot_compositespec_wrapper(ztype='zcat')

    """
    bintypes = ['EqNumberBins','EqSizeBins']
    ztypes   = ['zcat','zv18']

    for bintype in bintypes:
        if bintype == 'EqNumberBins':
            binid = 10
        elif bintype == 'EqSizeBins':
            binid = 20
        else:
            sys.exit('Uknown bintype = "'+bintype+'"')
        for ztype in ztypes:
            if ztype == 'zcat':
                zid = 1
            elif ztype == 'zv18':
                zid = 2
            else:
                sys.exit('Uknown ztype = "'+ztype+'"')

            baseid = '_0000'+str(binid+zid)

            # --- two parameters binned ---
            rangedic = {}
            rangedic['z']        = [2.8,6.7]
            rangedic['m814w']    = [23.76,28.82]
            rangedic['Llya']     = [-12420,24500]
            rangedic['FWHMlya']  = [0,17]
            rangedic['EW0lya']   = [0,2000]
            rangedic['beta']     = [-15.5,8.2]

            for param1,param2 in combinations( ['z','m814w','Llya','FWHMlya','EW0lya','beta'],2):
                globstr = specdir+'*'+baseid+'*'+param1+'_bin*'+param2+'_bin*.fits'
                spectra = np.sort(glob.glob(globstr))
                outname = specdir+'composite_overview_'+ztype+'_'+bintype+'_'+param1+'_VS_'+param2+'.pdf'
                if len(spectra) > 0:
                    uves.stack_composite_plotNxNspecs(param1,param2,rangedic[param1],rangedic[param2],spectra,outname,
                                                      ztype=ztype,bintype=bintype)

            # --- one parameter binned ---
            if ztype == 'zcat':
                param1  = 'z'
                globstr = specdir+'*'+baseid+'*'+param1+'LT2p9_bin*of3*.fits'
                spectra = np.sort(glob.glob(globstr))
                outname = specdir+'composite_overview_'+ztype+'_'+bintype+'_'+param1+'LT2p9.pdf'
                if len(spectra) > 0:
                    uves.stack_composite_plotNxNspecs(param1,None,[1.45,2.95],None,spectra,outname,
                                                      ztype=ztype,bintype=bintype)

            for Nbin in [4,10]:
                param1  = 'z'
                globstr = specdir+'*'+baseid+'*'+param1+'GT2p9_bin*of'+str(Nbin)+'*.fits'
                spectra = np.sort(glob.glob(globstr))
                outname = specdir+'composite_overview_'+ztype+'_'+bintype+'_'+param1+'GT2p9_'+str(Nbin)+'bins.pdf'
                if len(spectra) > 0:
                    uves.stack_composite_plotNxNspecs(param1,None,[2.8,6.7],None,spectra,outname,
                                                      ztype=ztype,bintype=bintype)

                param1  = 'm814w'
                globstr = specdir+'*'+baseid+'*'+param1+'_bin*of'+str(Nbin)+'*.fits'
                spectra = np.sort(glob.glob(globstr))
                outname = specdir+'composite_overview_'+ztype+'_'+bintype+'_'+param1+'Detections_'+str(Nbin)+'bins.pdf'
                if len(spectra) > 0:
                    uves.stack_composite_plotNxNspecs(param1,None,rangedic[param1],None,spectra,outname,
                                                      ztype=ztype,bintype=bintype)

            for plotparam in ['Llya','FWHMlya','EW0lya','beta']:
                globstr = specdir+'*'+baseid+'*'+plotparam+'_bin*of4*.fits'
                spectra = np.sort(glob.glob(globstr))
                outname = specdir+'composite_overview_'+ztype+'_'+bintype+'_'+plotparam+'_4bins.pdf'
                if len(spectra) > 0:
                    uves.stack_composite_plotNxNspecs(plotparam,None,rangedic[plotparam],None,spectra,outname,
                                                      ztype=ztype,bintype=bintype)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
def get_vector_intervals(vector,Nsamples,equalsizebins=False,verbose=True):
    """
    Function to split vector in intervals for generating sub-samples.

    --- INPUT ---
    vector        The data vector to bin up
    Nsamples      Number of samples to generate, i.e., the number of bins to return
    equalsizebins To return bins of equal size instead of the default with bins
                  contianing equal number of objects set this keyword to True.
    verbose       Toggle verbosity

    --- Example of use ---
    import uvEmissionlineSearch as uves, astropy.io.fits as afits, numpy as np

    infofile      = '/Users/kschmidt/work/MUSE/uvEmissionlineSearch/objectinfofile_zGT1p5_3timesUDFcats_JKthesisInfo.fits'
    infodat       = afits.open(infofile)[1].data
    infodat       = infodat[np.where((infodat['id']<4.9e8) | (infodat['id']>5.9e8))[0]]

    binranges     = uves.get_vector_intervals(infodat['redshift'],4)

    """
    if verbose: print(' - Input vector has length '+str(len(vector))+
                      ' but will only consider finite and non-0 values in binning, hence...')
    vector      = np.asarray(vector)[np.isfinite(vector) & (vector != 0)]
    vector_s    = np.sort(vector)

    binranges = []
    if not equalsizebins:
        Nobj_perbin = int(np.floor(len(vector)/Nsamples))
        if verbose:
            print(' - Divding vector of length '+str(len(vector))+' with min and max values ['+str(np.min(vector))+','+str(np.max(vector))+'] into subsamples:')

        if verbose: print(' - The provided vector can be split into the following '+str(Nsamples)+' samples:')
        for bb in np.arange(Nsamples):
            if bb < Nsamples-1:
                binlen = len(vector_s[Nobj_perbin*bb:Nobj_perbin*(bb+1)])
                binmin = np.min(vector_s[Nobj_perbin*bb:Nobj_perbin*(bb+1)])
                binmax = np.max(vector_s[Nobj_perbin*bb:Nobj_perbin*(bb+1)])
            else:
                binlen = len(vector_s[Nobj_perbin*bb:])
                binmin = np.min(vector_s[Nobj_perbin*bb:])
                binmax = np.max(vector_s[Nobj_perbin*bb:])

            if verbose: print('   subsample '+str(bb+1)+'   ['+str("%12.4f" % binmin)+' '+str("%12.4f" % binmax)+
                              ']  of length '+str(binlen))
            binranges.append([binmin,binmax])
    else:
        vectorrange = np.max(vector)-np.min(vector)
        dbin = vectorrange/Nsamples

        for bb in np.arange(Nsamples):
            if bb == 0:
                binmin = np.min(vector) - np.abs(np.min(vector)*0.01)
            else:
                binmin = np.min(vector)+dbin*bb
            if bb == Nsamples-1:
                binmax = np.max(vector) +  np.abs(np.max(vector)*0.01)
            else:
                binmax = np.min(vector) +dbin*(bb+1)
            binlen = len(vector[(vector>=binmin) & (vector<=binmax)])

            if verbose: print('   subsample '+str(bb+1)+'   ['+str("%12.4f" % binmin)+' '+str("%12.4f" % binmax)+
                              ']  containing '+str(binlen)+' objects')
            binranges.append([binmin,binmax])

    return binranges
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
